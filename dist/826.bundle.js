(self.webpackChunkvl_website=self.webpackChunkvl_website||[]).push([[826],{826:module=>{eval('{\r\n/*  Author: Ryan Taylor Montgomery\r\n *  Date: May 27th 2019\r\n *  License: MIT License\r\n *\r\n *\tCopyright (c) 2019 Vault Lambda LLC\r\n *\r\n *\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n *\tof this software and associated documentation files (the "Software"), to deal\r\n *\tin the Software without restriction, including without limitation the rights\r\n *\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *\tcopies of the Software, and to permit persons to whom the Software is\r\n *\tfurnished to do so, subject to the following conditions:\r\n *\r\n *\tThe above copyright notice and this permission notice shall be included in all\r\n *\tcopies or substantial portions of the Software.\r\n *\r\n *\tTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n *\tSOFTWARE.\r\n * \r\n */\r\nconst grul = new (function () {\r\n    /*  Function Name: this.docs\r\n     *  Description: Retrieves api information from source\r\n     */\r\n    this.docs = function () {\r\n        let grulref = this;\r\n        let Utilities = Object.keys(this);\r\n        let source = this.constructor.toString();\r\n        const regex = /\\/\\*?(?:\\t|\\ |\\r|\\n)*?Function\\ Name:(?:.|\\r|\\n)*?this\\.([a-zA-Z0-9]*)(?:.|\\r|\\n)*?Description:((?:.|\\r|\\n)*?)\\*\\//gmi;\r\n        let m;\r\n        let funcDetail = {};\r\n        while ((m = regex.exec(source)) !== null) {\r\n            // This is necessary to avoid infinite loops with zero-width matches\r\n            if (m.index === regex.lastIndex) {\r\n                regex.lastIndex++;\r\n            }\r\n\r\n            // The result can be accessed through the `m`-variable.\r\n            funcDetail[m[1]] = {\r\n                "description": m[2]\r\n            };\r\n        }\r\n        let docs = Utilities.map(function (key) {\r\n            return {\r\n                name: key,\r\n                args: grulref.funcArgs(grul[key]),\r\n                details: (key in funcDetail ? funcDetail[key] : { "description": "No description provided" })\r\n            };\r\n        });\r\n        return docs;\r\n    };\r\n    /*  Function Name: this.clone\r\n     *  Description: Clones data (breaking attachment to existing datasets)\r\n     */\r\n    this.clone = function (obj) {\r\n        return JSON.parse(JSON.stringify(obj));\r\n    };\r\n    /*  Function Name: this.funcArgs\r\n     *  Description: Retrieves functions arguments given a function definition\r\n     */\r\n    this.funcArgs = function (func) {\r\n        return (func + "")\r\n            .replace(/[/][/].*$/mg, "")\r\n            .replace(/\\s+/g, "")\r\n            .replace(/[/][*][^/*]*[*][/]/g, "")\r\n            .split("){", 1)[0].replace(/^[^(]*[(]/, "")\r\n            .replace(/=[^,]+/g, "")\r\n            .split(",").filter(Boolean);\r\n    };\r\n    /*  Function Name: this.executeLogic\r\n     *  Description: Executes logic of lambda depending on passed structure\r\n     */\r\n    this.executeLogic = function (logicController, location, patternIndex, aData, historicalTypePath, historicalLiteralPath, historicalObjectPath, initial) {\r\n        var logic = logicController;\r\n        var continueTraversal;\r\n        if (logic.constructor === Array) {\r\n            if (logic[patternIndex].constructor === Object) {\r\n                continueTraversal = location in logic[patternIndex] ? logic[patternIndex][location](aData, historicalTypePath, historicalLiteralPath, historicalObjectPath, initial) : true;\r\n            }\r\n            else {\r\n                continueTraversal = logic[patternIndex](aData, historicalTypePath, historicalLiteralPath, historicalObjectPath, initial);\r\n            }\r\n        }\r\n        else if (logic.constructor === Object) {\r\n            continueTraversal = location in logic ? logic[location](aData, historicalTypePath, historicalLiteralPath, historicalObjectPath, initial) : true;\r\n        }\r\n        else {\r\n            continueTraversal = logic(aData, historicalTypePath, historicalLiteralPath, historicalObjectPath, initial);\r\n        }\r\n        return continueTraversal;\r\n    };\r\n    /*  Variable Name: this.typeExtensions\r\n     *  Description: This variable holds a traversal map\r\n     */\r\n    this.typeExtensions = {\r\n        "Array": {\r\n            type: Array,\r\n            enumerators: () => {\r\n                return [];\r\n            }\r\n        }\r\n    }\r\n    /*  Function Name: this.extend\r\n     *  Description: This function configures a type extension for the enumerator specified\r\n     */\r\n    this.extend = function (type, enumerator) {\r\n        this.typeExtensions[type.name] = {\r\n            type: type,\r\n            enumerators: (enumerator.constructor === Array ? enumerator : [enumerator])\r\n        };\r\n    }\r\n    //Recursive Helper Functions\r\n    /*\tFunction Name: this.pluck\r\n     *\tDescription: This function traverses data given a path (array of literal traversals in order)\r\n     */\r\n    this.pluck = function (data, path, set = null) {\r\n        if (path.length > 1) {\r\n            return this.pluck(data[path[0]], path.slice(1), set);\r\n        }\r\n        else if (path.length === 0) {\r\n            if (set === null) {\r\n                return data;\r\n            }\r\n            else {\r\n                data = set;\r\n                return data;\r\n            }\r\n        }\r\n        else {\r\n            if (set === null) {\r\n                return data[path[0]];\r\n            }\r\n            else {\r\n                data[path[0]] = set;\r\n                return data[path[0]];\r\n            }\r\n        }\r\n\r\n    };\r\n    /* \tFunction Name: this.pathExists\r\n     *\tDescription: This function checks to see if given path exists in a set\r\n     */\r\n    this.pathExists = function (data, bindpath, curpath = []) {\r\n        let isEqual = this.arrEquals(bindpath, curpath) && bindpath.length === curpath.length;\r\n        if (!isEqual) {\r\n            curpath.push(bindpath[curpath.length]);\r\n        }\r\n        try {\r\n            if (this.pluck(data, curpath) !== undefined) {\r\n                if (isEqual === true) {\r\n                    return true;\r\n                }\r\n                return this.pathExists(data, bindpath, curpath);\r\n            }\r\n            else {\r\n                return bindpath.slice(curpath.length - 1);\r\n            }\r\n        }\r\n        catch (exception) {\r\n            return bindpath.slice(curpath.length - 1);\r\n        }\r\n    };\r\n    /*   Function Name: this.scaffold\r\n     *   Description: This function constructs a blank incoming typed item\r\n     */\r\n    this.scaffold = function (input) {\r\n        if (input.constructor === Object) {\r\n            return {};\r\n        }\r\n        else if (input.constructor === Array) {\r\n            return [];\r\n        }\r\n        else {\r\n            return input;\r\n        }\r\n    };\r\n    /*  Function Name: this.isPrimitive\r\n     *  Description: This function determines whether or not the argument is a primitive type in javascript\r\n     */\r\n    this.isPrimitive = function (arg) {\r\n        var type = typeof arg;\r\n        return arg === null || (type !== "object" && type !== "function");\r\n    };\r\n    /*\tFunction Name: this.arrEquals\r\n     *\tDescription: This function iterates through array elements to check equality\r\n     */\r\n    this.arrEquals = function (arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = parseInt(arr1.length); i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /*  Variable Name: this.accessMap\r\n     *  Description: This variable holds references to all objects that have been accessed via isCircular to remove __accessed__ key for later use\r\n     */\r\n    this.accessMap = {};\r\n    /*  Function Name: this.clearAccessMap\r\n     *  Description: This function clears an access map utilized by grul to halt at circular references.\r\n     */\r\n    this.clearAccessMap = function () {\r\n        Object.keys(this.accessMap).forEach(key => {\r\n            delete this.accessMap[key].__accessed__;    //clean up temporary member on accessed object\r\n            delete this.accessMap[key];                 //clean up temporary member on access map\r\n        });\r\n    };\r\n    /*  Function Name: this.isCircular\r\n     *  Description: This function determines given a dataset whether or not that traversed path is circular in nature\r\n     */\r\n    this.isCircular = function (data) {\r\n        if (this.isPrimitive(data)) {\r\n            return false;\r\n        }\r\n        else {\r\n            if ("__accessed__" in data && data.__accessed__) {\r\n                return true;\r\n            }\r\n            let accessMapKey = Object.keys(this.accessMap).length;\r\n            this.accessMap[accessMapKey] = data;\r\n            data.__accessed__ = true;\r\n            return false;\r\n        }\r\n    };\r\n    //Recursive Lambda\'s\r\n    /*  Function Name: this.atHierarchy\r\n     *  Description: This function traverses any static or dynamic template hierarchy executing any head, tail logic to restructure a 2 dimensional JSON set\r\n     *              into the defined hierarchical set and grouping rows by a unique dynamically generated head key\r\n     */\r\n    this.atHierarchy = function (data, hierarchy, historicalTypePath = [], historicalLiteralPath = [], root = this.scaffold(hierarchy)) {\r\n        if (hierarchy.constructor === Array) {\r\n            hierarchy.forEach((template) => {\r\n                let compound = {}; // defines data/hierarchy/path to be set for next \r\n                let heads = []; // defines head which generates hierarchical compound key\r\n                let tails = []; // defines tails which generates hierarchical values based on previous recursive action\r\n                let branches = []; // defined branches which reflect hierarchical child slots\r\n                let rHierarchy = template.constructor === Function ? template(data, historicalTypePath, historicalLiteralPath, hierarchy) : template;\r\n                let out = this.scaffold(rHierarchy); // defines scaffolding for template to be cloned into a segment instance\r\n                //build branches\r\n                this.atEvery(rHierarchy, (segmentInput, typePath, literalPath) => {\r\n                    if (segmentInput === null) {\r\n                        return false;\r\n                    }\r\n\r\n                    if (segmentInput.constructor === Array) {\r\n                        let segmentMap = {\r\n                            "segmentTypePath": typePath,\r\n                            "segmentLiteralPath": literalPath,\r\n                            "hierarchy": segmentInput\r\n                        };\r\n                        branches.push(segmentMap);\r\n                        this.pluck(out, literalPath, []);\r\n                        return false;\r\n                    }\r\n                    else if (segmentInput.constructor === Object && "head" in segmentInput && segmentInput.head.constructor === Function) {\r\n                        let segmentMap = {\r\n                            "segmentTypePath": typePath,\r\n                            "segmentLiteralPath": literalPath,\r\n                            "map": segmentInput.head\r\n                        };\r\n                        heads.push(segmentMap);\r\n                        this.pluck(out, segmentMap.segmentLiteralPath, "");\r\n                        return false;\r\n                    }\r\n                    else if (segmentInput.constructor === Object && "tail" in segmentInput && segmentInput.tail.constructor === Function) {\r\n                        let segmentMap = {\r\n                            "segmentTypePath": typePath,\r\n                            "segmentLiteralPath": literalPath,\r\n                            "map": segmentInput.tail\r\n                        };\r\n                        tails.push(segmentMap);\r\n                        this.pluck(out, segmentMap.segmentLiteralPath, "");\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        this.pluck(out, literalPath, this.scaffold(segmentInput));\r\n                    }\r\n                });\r\n                //fill segments\r\n                data.forEach((row) => {\r\n                    let segment = this.clone(out);\r\n                    let compoundKey = "";\r\n                    //fill segment with head results\r\n                    heads.forEach((head) => {\r\n                        let value = head.map(row,\r\n                            historicalTypePath.concat(head.segmentTypePath),\r\n                            historicalLiteralPath.concat(head.segmentLiteralPath));\r\n                        let set = this.pluck(segment, head.segmentLiteralPath, value);\r\n                        segment = head.segmentLiteralPath.length === 0 ? set : segment;\r\n                        compoundKey += JSON.stringify(value);\r\n                    });\r\n                    /* Future Recursively Enumerable Hierarchy Updates\r\n                    this.atPattern(segment,["head"],{"head":(data,htp,hlp)=>{\r\n                        Object.keys(this.accessMap).forEach(key=>{\r\n                            delete this.accessMap[key].__accessed__;    //clean up temporary member on accessed object\r\n                            delete this.accessMap[key];                 //clean up temporary member on access map\r\n                        });\r\n                        this.atHierarchy([row],segment,historicalTypePath.concat(htp),historicalLiteralPath.concat(hlp),root);\r\n                    }});\r\n                    */\r\n                    if (compoundKey in compound) {\r\n                        compound[compoundKey].rows.push(row);\r\n                    }\r\n                    else {\r\n                        compound[compoundKey] = {\r\n                            rows: [row],\r\n                            branches: branches,\r\n                            segment: segment\r\n                        };\r\n                    }\r\n                });\r\n                //fill segment with tail results\r\n                Object.keys(compound).forEach((key) => {\r\n                    let parent = this.pluck(root, historicalLiteralPath);\r\n                    parent.push(compound[key].segment);\r\n                    let typePath = historicalTypePath.concat(out.constructor);\r\n                    let literalPath = historicalLiteralPath.concat([parent.length - 1]);\r\n                    compound[key].branches.forEach((branch) => {\r\n                        let nTypePath = typePath.concat(branch.segmentTypePath);\r\n                        let nLiteralPath = literalPath.concat(branch.segmentLiteralPath);\r\n                        this.atHierarchy(compound[key].rows, branch.hierarchy, nTypePath, nLiteralPath, root);\r\n                    });\r\n                    tails.forEach((tail) => {\r\n                        this.pluck(compound[key].segment, tail.segmentLiteralPath, tail.map(\r\n                            compound[key].rows,\r\n                            historicalTypePath.concat(compound[key].segmentTypePath),\r\n                            historicalLiteralPath.concat(compound[key].segmentLiteralPath),\r\n                            rHierarchy,\r\n                            branches\r\n                        ));\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            let tails = [];\r\n            this.atEvery(hierarchy, (input, htp, hlp) => {\r\n                if (input.constructor === Array) {\r\n                    this.pluck(root, hlp, this.scaffold(input));\r\n                    this.atHierarchy(data, input, htp, hlp, root);\r\n                    return false;\r\n                }\r\n                else if (input.constructor === Object && "head" in input && input.head.constructor === Function) {\r\n                    this.pluck(root, hlp, input.head(data, htp, hlp, hierarchy));\r\n                    return false;\r\n                }\r\n                else if (input.constructor === Object && "tail" in input && input.tail.constructor === Function) {\r\n                    tails.push({\r\n                        segmentTypePath: htp,\r\n                        segmentLiteralPath: hlp,\r\n                        map: input.tail\r\n                    });\r\n                    this.pluck(root, hlp, "");\r\n                    return false;\r\n                }\r\n                else {\r\n                    this.pluck(root, hlp, this.scaffold(input));\r\n                }\r\n            })\r\n            tails.forEach((tail) => {\r\n                this.pluck(root, tail.segmentLiteralPath, tail.map(data, tail.segmentTypePath, tail.segmentLiteralPath, hierarchy));\r\n            });\r\n        }\r\n        return root;\r\n    };\r\n    /*  Function Name: this.atSubdivision\r\n     *  Description: This function subdivides any 2 dimensional array into a linked tree based on the number of subdivisions specified, providing the user with\r\n     *              a function at each subdivisions for making customizations to the subdivided area\r\n     */\r\n    this.atSubdivision = function (data, subdivisions = 2, logic, historicalTypePath = [], historicalLiteralPath = [], rootData = data) {\r\n        if (data.length === 1) {\r\n            let ntp = historicalTypePath.concat([Array]);\r\n            let nlp = historicalLiteralPath.concat([0]);\r\n            return data[0];\r\n        }\r\n        else {\r\n            let subdivision = new Array(subdivisions).fill(null);\r\n            let ntp = historicalTypePath.concat([Array, Object]);\r\n            subdivision = subdivision.map((blank, index) => {\r\n                let nlp = historicalLiteralPath.concat([index, "group"]);\r\n                return this.atSubdivision(data.slice(index * (data.length / subdivisions), (index + 1) * (data.length / subdivisions)), subdivisions, logic, ntp, nlp);\r\n            });\r\n            let subdivisionGroup = { group: subdivision };\r\n            logic(subdivisionGroup, historicalTypePath, historicalLiteralPath)\r\n            return subdivisionGroup;\r\n        }\r\n    };\r\n    /*  Function Name: this.atStructure\r\n     *  Description: This function traverses any multidimensional set and modifies the existing path structure (metaPath) to the specified desired path structure\r\n     */\r\n    this.atStructure = function (data, metaPath, logic, relativity = 0, historicalTypePath = [], historicalLiteralPath = [], rootData = data) {\r\n        /* [{... children:[{...}]}] \r\n         * oldMetaPath => ["children",Array]\r\n         * newMetaPath => ["children",Object]\r\n         * keyPaths => []\r\n         */\r\n    };\r\n    /*  Function Name: this.atSegment\r\n     *  Description: This function traverses a multidimensional set for the existence of the metaPath starting from the historicalLiteralPath, until it finds the\r\n     *               next existence of metaPath, or the ends are primitive and returns a shallow copy\r\n     */\r\n    this.atSegment = function (data, metaPath, logic, relativity = 0, historicalTypePath = [], historicalLiteralPath = [], rootData = data) {\r\n        let include, exclude, depth, lag;\r\n        if (metaPath.constructor === Object) {\r\n            include = metaPath.include;\r\n            exclude = metaPath.exclude;\r\n        }\r\n        else if (metaPath.constructor === Array) {\r\n            include = metaPath;\r\n        }\r\n        if (relativity.constructor === Array) {\r\n            depth = relativity[0] || 1;\r\n            lag = relativity[1] || 0;\r\n        }\r\n        else if (relativity.constructor === Object) {\r\n            depth = relativity.depth || 0;\r\n            lag = relativity.lag || 0;\r\n        }\r\n        else {\r\n            depth = relativity + 1;\r\n            lag = 0;\r\n        }\r\n        let start = this.pluck(data, historicalLiteralPath);\r\n        let includePaths = [];\r\n        let excludePaths = [];\r\n        this.atPattern(start, include, {\r\n            "head": (data, htp, hlp, hop) => {\r\n                if (hop.length === depth) {\r\n                    includePaths.push({\r\n                        historicalTypePath: htp.slice(0, htp.length + lag),\r\n                        historicalLiteralPath: hlp.slice(0, htp.length + lag),\r\n                        historicalObjectPath: hop\r\n                    });\r\n                }\r\n                else if (hop.length === (depth + 1)) {\r\n                    excludePaths.push({\r\n                        historicalTypePath: htp,\r\n                        historicalLiteralPath: hlp,\r\n                        historicalObjectPath: hop\r\n                    });\r\n                    return false;\r\n                }\r\n            }\r\n        }, lag);\r\n        if (exclude) {\r\n            this.atPattern(start, exclude, {\r\n                "head": (data, excludehtp, excludehlp, excludehop) => {\r\n                    for (let i = 0; i < includePaths.length; i++) {\r\n                        let include = includePaths[i];\r\n                        let includehlp = include.historicalLiteralPath;\r\n                        if (includehlp.join("<===>").indexOf(excludehlp.join("<===>")) > -1) {\r\n                            includePaths.splice(i, 1);\r\n                            i--;\r\n                        }\r\n                    }\r\n                    excludePaths.push({\r\n                        historicalTypePath: excludehtp,\r\n                        historicalLiteralPath: excludehlp,\r\n                        historicalObjectPath: excludehop\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        let segments = [];\r\n        let excludeMap = {};\r\n        excludePaths.forEach(exclude => {\r\n            excludeMap[exclude.historicalLiteralPath.join("<===>")] = true;\r\n        });\r\n        includePaths.forEach((include) => {\r\n            let reference = this.pluck(start, include.historicalLiteralPath);\r\n            let clone = this.scaffold(reference);\r\n            this.atEvery(reference, (data, htp, hlp, root) => {\r\n                let curPath = include.historicalLiteralPath.concat(hlp).join("<===>");\r\n                if (curPath in excludeMap) {\r\n                    return false;\r\n                }\r\n                this.pluck(clone, hlp, this.clone(this.scaffold(data)));\r\n            });\r\n            segments.push({\r\n                data: clone,\r\n                historicalTypePath: include.historicalTypePath,\r\n                historicalLiteralPath: include.historicalLiteralPath,\r\n                historicalObjectPath: include.historicalObjectPath\r\n            });\r\n            logic(clone, include.historicalTypePath, include.historicalLiteralPath, include.historicalObjectPath, data);\r\n        });\r\n        return segments;\r\n    };\r\n    /* \tFunction Name: this.atMeta\r\n     *\tDescription: This function iterates through values which have matching literal/typepaths from the base of the object\r\n     */\r\n    this.atMeta = function (data, metaPath, logic, relativity = 0, historicalTypePath = [], historicalLiteralPath = [], historicalObjectPath = [], rootData = data) {\r\n        return this.atPattern(data, metaPath, { "head": logic }, relativity, historicalTypePath, historicalLiteralPath, null, data, true);\r\n    };\r\n    /*\tFunction Name: this.atPattern\r\n     *\tDescription: This function iterates through values which have matching literal/typepaths throughout the entirety of an object \r\n     */\r\n    this.atPattern = function (data, metaPath, logic, relativity = 0, historicalTypePath = [], historicalLiteralPath = [], curMeta, rootData = data, direct = false) {\r\n        let matched = {};\r\n        let aData;\r\n        let metaTemplate = {\r\n            matchCount: 0,\r\n            hop: []\r\n        };\r\n        let newMeta = [];\r\n        if (metaPath[0].constructor === Array) {\r\n            if (curMeta) { }\r\n            else {\r\n                newMeta = [];\r\n                for (let i = 0; i < metaPath.length; i++) {\r\n                    newMeta.push(this.clone(metaTemplate));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            metaPath = [metaPath];\r\n            newMeta = [metaTemplate];\r\n        }\r\n\r\n\r\n\r\n        if (historicalLiteralPath.length > 0) {\r\n            let matchExists = false;\r\n            for (let i = 0; i < metaPath.length; i++) {\r\n                newMeta[i] = {\r\n                    matchCount: this.clone(curMeta[i].matchCount),\r\n                    hop: curMeta[i].hop\r\n                };\r\n                if (direct && historicalLiteralPath.length > metaPath[i].length) {\r\n                    newMeta[i].matchCount = metaPath[i].length + 1;\r\n                }\r\n                if (metaPath[i][newMeta[i].matchCount] !== undefined && historicalTypePath[historicalTypePath.length - 1].name === metaPath[i][newMeta[i].matchCount].name) {\r\n                    newMeta[i].matchCount++;\r\n                    matchExists = true;\r\n                }\r\n                else if (metaPath[i][newMeta[i].matchCount] !== undefined && historicalLiteralPath[historicalLiteralPath.length - 1] === metaPath[i][newMeta[i].matchCount]) {\r\n                    newMeta[i].matchCount++;\r\n                    matchExists = true;\r\n                }\r\n                else {\r\n                    newMeta[i].matchCount = 0;\r\n                }\r\n                if (newMeta[i].matchCount === metaPath[i].length) {\r\n                    var continueTraversal;\r\n                    aData = relativity === 0 ? data : this.pluck(rootData, historicalLiteralPath.slice(0, (historicalLiteralPath.length) + relativity));\r\n                    newMeta[i].hop = newMeta[i].hop.concat([{ data: aData }]);\r\n                    let frozenHopIndex = newMeta[i].hop.length - 1;\r\n                    let frozenMetaIndex = this.clone(i);\r\n                    if (frozenHopIndex > 0) {\r\n                        newMeta[i].hop[frozenHopIndex].previous = () => {\r\n                            return newMeta[frozenMetaIndex].hop[frozenHopIndex - 1];\r\n                        };\r\n                        newMeta[i].hop[frozenHopIndex].previous().next = () => {\r\n                            return newMeta[frozenMetaIndex].hop[frozenHopIndex];\r\n                        };\r\n                    }\r\n                    continueTraversal = this.executeLogic(logic, "head", i, aData, historicalTypePath, historicalLiteralPath, newMeta[i].hop, rootData);\r\n                    matched[i] = aData;\r\n                    if (continueTraversal === false) {\r\n                        return aData;\r\n                    }\r\n                    newMeta[i].matchCount = 0;\r\n                }\r\n            }\r\n            if (direct && !matchExists) {\r\n                return false;\r\n            }\r\n        }\r\n        if (data !== null) {\r\n            if ((!direct) && this.isCircular(data)) {\r\n                console.log("data traversal halted @ " + historicalLiteralPath.join("-"))\r\n                return data;\r\n            }\r\n            var nhtpath = historicalTypePath.slice(0);\r\n            nhtpath.push(data.constructor);\r\n            if (data.constructor === Array) {\r\n                for (let i = 0; i < data.length; i++) {\r\n                    let nhlpath = this.clone(historicalLiteralPath);\r\n                    nhlpath.push(i);\r\n                    this.atPattern(data[i], metaPath, logic, relativity, nhtpath, nhlpath, newMeta, rootData, direct);\r\n                }\r\n            }\r\n            else if (data.constructor === Object || (typeof data == \'object\' && data !== null)) {\r\n                if (data.constructor.name in this.typeExtensions) {\r\n                    this.typeExtensions[data.constructor.name].enumerators.forEach((enumerator) => {\r\n                        enumerator(data, metaPath, logic, relativity, nhtpath, historicalLiteralPath, newMeta, rootData, direct);\r\n                    });\r\n                }\r\n                else {\r\n                    Object.keys(data).forEach((key) => {\r\n                        let nhlpath = this.clone(historicalLiteralPath);\r\n                        nhlpath.push(key);\r\n                        this.atPattern(data[key], metaPath, logic, relativity, nhtpath, nhlpath, newMeta, rootData, direct);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < metaPath.length; i++) {\r\n            if (i in matched) {\r\n                continueTraversal = this.executeLogic(logic, "tail", i, aData, historicalTypePath, historicalLiteralPath, newMeta[i].hop, rootData);\r\n                if (continueTraversal === false) {\r\n                    return aData;\r\n                }\r\n            }\r\n        }\r\n        if (data === rootData) {\r\n            this.clearAccessMap();\r\n        }\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atShallowestPattern\r\n     *\tDescription: This function iterates this.atPattern, stores the inputs with the least depth to be executed logically\r\n     */\r\n    this.atShallowestPattern = function (data, metaPath, logic, relativity = 0) {\r\n        var leastDepth = Infinity;\r\n        let inputs = [];\r\n        this.atPattern(data, metaPath, {\r\n            "head": function (input, historicalTypePath, historicalLiteralPath, historicalObjectPath) {\r\n                if (historicalLiteralPath.length < leastDepth) {\r\n                    leastDepth = historicalLiteralPath.length;\r\n                    inputs = [];\r\n                }\r\n                else if (historicalLiteralPath.length > leastDepth) {\r\n                    return false;\r\n                }\r\n                inputs.push({\r\n                    data: input,\r\n                    historicalTypePath: historicalTypePath,\r\n                    historicalLiteralPath: historicalLiteralPath,\r\n                    historicalObjectPath: historicalObjectPath\r\n                });\r\n            }\r\n        }, relativity);\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            logic(inputs[i].data, inputs[i].historicalTypePath, inputs[i].historicalLiteralPath, inputs[i].historicalObjectPath);\r\n        }\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atDeepestPattern\r\n     *\tDescription: This function iterates this.atPattern, stores the inputs with most depth to be executed logically - (Returns false within .atPattern where depth is greater than)\r\n     */\r\n    this.atDeepestPattern = function (data, metaPath, logic, relativity = 0) {\r\n        var greatestDepth = -1;\r\n        let inputs = [];\r\n        this.atPattern(data, metaPath, function (input, historicalTypePath, historicalLiteralPath, historicalObjectPath) {\r\n            if (historicalLiteralPath.length > greatestDepth) {\r\n                greatestDepth = historicalLiteralPath.length;\r\n                inputs = [];\r\n            }\r\n            inputs.push({\r\n                data: input,\r\n                historicalTypePath: historicalTypePath,\r\n                historicalLiteralPath: historicalLiteralPath,\r\n                historicalObjectPath: historicalObjectPath\r\n            });\r\n        }, relativity);\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            logic(inputs[i].data, inputs[i].historicalTypePath, inputs[i].historicalLiteralPath, inputs[i].historicalObjectPath);\r\n        }\r\n        return data;\r\n    };\r\n    /* \tFunction Name: this.atEnds\r\n     *\tDescription: This function iterates through the primitive ends of objects\r\n     */\r\n    this.atEnds = function (data, logic, historicalTypePath = [], historicalLiteralPath = []) {\r\n        if (data === null) {\r\n            logic(data, historicalTypePath, historicalLiteralPath);\r\n        }\r\n        else if (data.constructor === Object) {\r\n            Object.keys(data).forEach((key) => {\r\n                let ntp = historicalTypePath.concat([Object]);\r\n                let nlp = historicalLiteralPath.concat([key]);\r\n                this.atEnds(data[key], logic, ntp, nlp);\r\n            })\r\n        }\r\n        else if (data.constructor === Array) {\r\n            for (let i = 0; i < data.length; i++) {\r\n                let ntp = historicalTypePath.concat([Array]);\r\n                let nlp = historicalLiteralPath.concat([i]);\r\n                this.atEnds(data[i], logic, ntp, nlp);\r\n            }\r\n        }\r\n        else if (data.constructor === Function) {\r\n            if (this.funcArgs(data).length === 0) {\r\n                let ntp = historicalTypePath.concat([Function]);\r\n                let nlp = historicalLiteralPath.concat(data);\r\n                this.atEnds(data(logic, ntp, nlp), logic, ntp, nlp)\r\n            }\r\n        }\r\n        else {\r\n            logic(data, historicalTypePath, historicalLiteralPath);\r\n        }\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atEvery\r\n     * \tDescription: This function runs passed logic at every potential traversal or endpoint\r\n     */\r\n    this.atEvery = function (data, logic, historicalTypePath = [], historicalLiteralPath = [], rootData = data) {\r\n        let iContinue = logic(data, historicalTypePath, historicalLiteralPath, rootData);\r\n        if (!(iContinue === true || iContinue === undefined || iContinue === null)) {\r\n            return;\r\n        }\r\n        var newTypePath = this.clone(historicalTypePath);\r\n        newTypePath.push(data.constructor);\r\n        if (data === null){}\r\n        else if (data.constructor === Array) {\r\n            for (let i = 0; i < data.length; i++) {\r\n                var newLitPath = this.clone(historicalLiteralPath);\r\n                newLitPath.push(i);\r\n                this.atEvery(data[i], logic, newTypePath, newLitPath, rootData);\r\n            }\r\n        }\r\n        else if (data.constructor === Object || (typeof data == \'object\')) {\r\n            Object.keys(data).forEach((key) => {\r\n                var newLitPath = this.clone(historicalLiteralPath);\r\n                newLitPath.push(key);\r\n                this.atEvery(data[key], logic, newTypePath, newLitPath, rootData);\r\n            });\r\n        }\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atMetaEnds\r\n     * \tDescription: This function runs this.atMeta, and then performs logic at the ends of the object returned to it by this.atMeta\r\n     */\r\n    this.atMetaEnds = function (data, metaPath, logic) {\r\n        var recursiveRef = this;\r\n        recursiveRef.atMeta(data, metaPath, {\r\n            "head": function (input) {\r\n                recursiveRef.atEnds(input, logic);\r\n            }\r\n        });\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atPatternEnds\r\n     *\tDescription: This function runs this.atPattern, and then performs logic at the pattern of the object returned to it by this.atPattern\r\n     */\r\n    this.atPatternEnds = function (data, metaPath, logic, relativity = 0) {\r\n        var recursiveRef = this;\r\n        recursiveRef.atPattern(data, metaPath, function (input) {\r\n            recursiveRef.atEnds(input, logic);\r\n        }, relativity);\r\n        return data;\r\n    };\r\n    /*\tFunction Name: this.atMatching\r\n     *\tDescription: This function traverses through set, determining if same path exists in data, and executes the associated path function "atMatchingFunction" or the sequence\r\n     */\r\n    this.atMatching = function (data, set, metaPath = [], literalPath = []) {\r\n        var curObj = this.pluck(set, metaPath);\r\n        var curData;\r\n        var exists = false;\r\n        try {\r\n            curData = this.pluck(data, metaPath);\r\n            exists = true;\r\n        }\r\n        catch (exception) {\r\n            exists = false;\r\n        }\r\n        if (curObj.constructor.name === "Object") {\r\n            Object.keys(curObj).forEach((key) => {\r\n                var nMetaPath = this.clone(metaPath);\r\n                nMetaPath.push(key);\r\n                var nLiteralPath = this.clone(literalPath);\r\n                nLiteralPath.push(key);\r\n                this.atMatching(data, set, nMetaPath, nLiteralPath);\r\n\r\n            });\r\n        }\r\n        else if (curObj.constructor.name === Array && exists) {\r\n            for (let i = 0; i < curObj.length; i++) {\r\n                var nMetaPath = this.clone(metaPath);\r\n                nMetaPath.push(i);\r\n                for (var x = 0; x < curData.length; x++) {\r\n                    var nLiteralPath = this.clone(literalPath);\r\n                    nLiteralPath.push(x);\r\n                    this.atMatching(data, set, nMetaPath, nLiteralPath);\r\n                }\r\n            }\r\n        }\r\n        else if (curObj.constructor === Function) {\r\n            if (metaPath[metaPath.length - 1] === "atMatchingFunction") {\r\n                //Perform Logic at Path of data object\r\n                curObj(this.pluck(data, literalPath.slice(0, - 1)), this)\r\n            }\r\n        }\r\n        else if (curObj.constructor.name === String) {\r\n            if (metaPath[metaPath.length - 1] === "atMatchingFunction") {\r\n                //Perform Logic at Path of data object\r\n                window[curObj](this.pluck(data, literalPath.slice(0, - 1)), this)\r\n            }\r\n            else if (exists) {\r\n                curData += curObj\r\n            }\r\n        }\r\n        else if (curObj.constructor === Number && exists) {\r\n            //Do an Equivalence Modifier\r\n            if (curData.constructor.name === curObj.constructor.name) {\r\n                curData += curObj;\r\n            }\r\n        }\r\n    };\r\n    /*\tFunction Name: this.atDepth\r\n     *\tDescription: This function traverses through set, pushing all items at a dimensional depth from base into an array and returning them\r\n     */\r\n    this.atDepth = function (data, depth = 0, logic, historicalTypePath = [], historicalLiteralPath = [], first = true, rootData = data) {\r\n        if (first === true) {\r\n            this.atDepthContainer = [];\r\n            first = false;\r\n        }\r\n        if (depth > 0) {\r\n            depth--\r\n            if (data.constructor.name === "Object") {\r\n                Object.keys(data).forEach((key) => {\r\n                    this.atDepth(data[key], depth, logic, first);\r\n                })\r\n            }\r\n            else if (data.constructor.name === "Array") {\r\n                for (let i = 0; i < data.length; i++) {\r\n                    this.atDepth(data[i], depth, logic, first);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            logic(data, historicalTypePath, historicalLiteralPath, rootData);\r\n            this.atDepthContainer.push(data);\r\n        }\r\n\r\n        return this.atDepthContainer;\r\n    };\r\n    /*\tFunction Name: this.atDiff\r\n     *\tDescription: This function traverses through multiple sets, keeping track of the structural and data differentials between all listed sets. Base sets must be held in array form. strict == true will modify contents to exactly match RFC 6902 standard\r\n     */\r\n    this.atDiff = function (data, logic = null, primary = 0, strict = false) {\r\n        let PatchDiffs = [];\r\n        if (data.constructor === Array) {\r\n            if (data.length > 1) {\r\n                //add, replace checks\r\n                this.atEvery(data[primary], (curData, historicalTypePath, historicalLiteralPath, rootData) => {\r\n                    for (var secondary = 0; secondary < data.length; secondary++) {\r\n                        if (secondary !== primary) {\r\n                            //compare primary set to others\r\n                            let secondaryPathExists = this.pathExists(data[secondary], historicalLiteralPath);\r\n                            if (secondaryPathExists && secondaryPathExists.constructor === Boolean) {\r\n                                if (curData.constructor !== Object && curData.constructor !== Array) {\r\n                                    let compareSetVal = this.pluck(data[secondary], historicalLiteralPath);\r\n                                    if (curData === compareSetVal) {\r\n                                        //set equivalent\r\n                                    }\r\n                                    else {\r\n                                        let nlp = historicalLiteralPath.slice(0);\r\n                                        //set requires updating to base set\r\n                                        let patch = this.RFC6902({ "op": "replace", "path": nlp, "value": curData, "ref": data[secondary], "#": secondary }, strict);\r\n                                        PatchDiffs.push(patch);\r\n                                        if (logic != null) {\r\n                                            logic(patch, historicalTypePath, historicalLiteralPath, rootData);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                let nlp = historicalLiteralPath.slice(0);\r\n                                let patch = this.RFC6902({ "op": "add", "path": nlp, "value": curData, "ref": data[secondary], "#": secondary }, strict);\r\n                                PatchDiffs.push(patch);\r\n                                if (logic != null) {\r\n                                    logic(patch, historicalTypePath, historicalLiteralPath, rootData);\r\n                                }\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                //removal checks\r\n                for (var secondary = 0; secondary < data.length; secondary++) {\r\n                    if (secondary !== primary) {\r\n                        this.atEvery(data[secondary], (curData, historicalTypePath, historicalLiteralPath, rootData) => {\r\n                            //compare secondary set to primary\r\n                            let primaryPathExists = this.pathExists(data[primary], historicalLiteralPath);\r\n                            if (!(primaryPathExists && primaryPathExists.constructor === Boolean)) {\r\n                                let nlp = historicalLiteralPath.slice(0);\r\n                                let patch = this.RFC6902({ "op": "remove", "path": nlp, "value": curData, "ref": data[secondary], "#": secondary }, strict);\r\n                                PatchDiffs.push(patch);\r\n                                if (logic != null) {\r\n                                    logic(patch, historicalTypePath, historicalLiteralPath, rootData);\r\n                                }\r\n                                return false;\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                console.log("Nothing to compare against");\r\n            }\r\n        }\r\n        else {\r\n            console.log("Base data is not an array");\r\n        }\r\n        return PatchDiffs;\r\n    };\r\n    this.RFC6902 = function (patch, strict = false) {\r\n        if (strict) {\r\n            delete patch["ref"];\r\n            delete patch["#"];\r\n            patch["path"] = "/" + patch["path"].join("/");\r\n        }\r\n        return patch;\r\n    }\r\n})();\r\n\r\ntry {\r\n    module.exports = grul;\r\n    console.log("Node Load");\r\n}\r\ncatch (exception) {\r\n    grul.pluck = function (data, path, set = null) {\r\n        if (path.length > 1) {\r\n            return this.pluck(data[path[0]], path.slice(1), set);\r\n        }\r\n        else if (path.length === 0) {\r\n            if (set === null) {\r\n                return data;\r\n            }\r\n            else {\r\n                data = set;\r\n                return data;\r\n            }\r\n        }\r\n        else {\r\n            if (set === null) {\r\n                if (data instanceof HTMLElement) {\r\n                    return data.getAttribute(path[0]);\r\n                }\r\n                else {\r\n                    return data[path[0]];\r\n                }\r\n            }\r\n            else {\r\n                data[path[0]] = set;\r\n                return data[path[0]];\r\n            }\r\n        }\r\n\r\n    };\r\n    console.log("Vanilla JavaScript Load");\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2dydWwvc3JjL2dydWwuanM/M2MyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyogIEF1dGhvcjogUnlhbiBUYXlsb3IgTW9udGdvbWVyeVxyXG4gKiAgRGF0ZTogTWF5IDI3dGggMjAxOVxyXG4gKiAgTGljZW5zZTogTUlUIExpY2Vuc2VcclxuICpcclxuICpcdENvcHlyaWdodCAoYykgMjAxOSBWYXVsdCBMYW1iZGEgTExDXHJcbiAqXHJcbiAqXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqXHR0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICpcdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuICpcdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICpcdEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKlx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKlx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICpcdE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqXHRTT0ZUV0FSRS5cclxuICogXHJcbiAqL1xyXG5jb25zdCBncnVsID0gbmV3IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5kb2NzXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IFJldHJpZXZlcyBhcGkgaW5mb3JtYXRpb24gZnJvbSBzb3VyY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kb2NzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBncnVscmVmID0gdGhpcztcclxuICAgICAgICBsZXQgVXRpbGl0aWVzID0gT2JqZWN0LmtleXModGhpcyk7XHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCByZWdleCA9IC9cXC9cXCo/KD86XFx0fFxcIHxcXHJ8XFxuKSo/RnVuY3Rpb25cXCBOYW1lOig/Oi58XFxyfFxcbikqP3RoaXNcXC4oW2EtekEtWjAtOV0qKSg/Oi58XFxyfFxcbikqP0Rlc2NyaXB0aW9uOigoPzoufFxccnxcXG4pKj8pXFwqXFwvL2dtaTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICBsZXQgZnVuY0RldGFpbCA9IHt9O1xyXG4gICAgICAgIHdoaWxlICgobSA9IHJlZ2V4LmV4ZWMoc291cmNlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMgd2l0aCB6ZXJvLXdpZHRoIG1hdGNoZXNcclxuICAgICAgICAgICAgaWYgKG0uaW5kZXggPT09IHJlZ2V4Lmxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlIGBtYC12YXJpYWJsZS5cclxuICAgICAgICAgICAgZnVuY0RldGFpbFttWzFdXSA9IHtcclxuICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbVsyXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZG9jcyA9IFV0aWxpdGllcy5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICAgICAgYXJnczogZ3J1bHJlZi5mdW5jQXJncyhncnVsW2tleV0pLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogKGtleSBpbiBmdW5jRGV0YWlsID8gZnVuY0RldGFpbFtrZXldIDogeyBcImRlc2NyaXB0aW9uXCI6IFwiTm8gZGVzY3JpcHRpb24gcHJvdmlkZWRcIiB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkb2NzO1xyXG4gICAgfTtcclxuICAgIC8qICBGdW5jdGlvbiBOYW1lOiB0aGlzLmNsb25lXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IENsb25lcyBkYXRhIChicmVha2luZyBhdHRhY2htZW50IHRvIGV4aXN0aW5nIGRhdGFzZXRzKVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xyXG4gICAgfTtcclxuICAgIC8qICBGdW5jdGlvbiBOYW1lOiB0aGlzLmZ1bmNBcmdzXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IFJldHJpZXZlcyBmdW5jdGlvbnMgYXJndW1lbnRzIGdpdmVuIGEgZnVuY3Rpb24gZGVmaW5pdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLmZ1bmNBcmdzID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gKGZ1bmMgKyBcIlwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvWy9dWy9dLiokL21nLCBcIlwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvWy9dWypdW14vKl0qWypdWy9dL2csIFwiXCIpXHJcbiAgICAgICAgICAgIC5zcGxpdChcIil7XCIsIDEpWzBdLnJlcGxhY2UoL15bXihdKlsoXS8sIFwiXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC89W14sXSsvZywgXCJcIilcclxuICAgICAgICAgICAgLnNwbGl0KFwiLFwiKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICB9O1xyXG4gICAgLyogIEZ1bmN0aW9uIE5hbWU6IHRoaXMuZXhlY3V0ZUxvZ2ljXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IEV4ZWN1dGVzIGxvZ2ljIG9mIGxhbWJkYSBkZXBlbmRpbmcgb24gcGFzc2VkIHN0cnVjdHVyZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4ZWN1dGVMb2dpYyA9IGZ1bmN0aW9uIChsb2dpY0NvbnRyb2xsZXIsIGxvY2F0aW9uLCBwYXR0ZXJuSW5kZXgsIGFEYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgaGlzdG9yaWNhbE9iamVjdFBhdGgsIGluaXRpYWwpIHtcclxuICAgICAgICB2YXIgbG9naWMgPSBsb2dpY0NvbnRyb2xsZXI7XHJcbiAgICAgICAgdmFyIGNvbnRpbnVlVHJhdmVyc2FsO1xyXG4gICAgICAgIGlmIChsb2dpYy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKGxvZ2ljW3BhdHRlcm5JbmRleF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVUcmF2ZXJzYWwgPSBsb2NhdGlvbiBpbiBsb2dpY1twYXR0ZXJuSW5kZXhdID8gbG9naWNbcGF0dGVybkluZGV4XVtsb2NhdGlvbl0oYURhdGEsIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCBoaXN0b3JpY2FsT2JqZWN0UGF0aCwgaW5pdGlhbCkgOiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVUcmF2ZXJzYWwgPSBsb2dpY1twYXR0ZXJuSW5kZXhdKGFEYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgaGlzdG9yaWNhbE9iamVjdFBhdGgsIGluaXRpYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvZ2ljLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgY29udGludWVUcmF2ZXJzYWwgPSBsb2NhdGlvbiBpbiBsb2dpYyA/IGxvZ2ljW2xvY2F0aW9uXShhRGF0YSwgaGlzdG9yaWNhbFR5cGVQYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIGhpc3RvcmljYWxPYmplY3RQYXRoLCBpbml0aWFsKSA6IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250aW51ZVRyYXZlcnNhbCA9IGxvZ2ljKGFEYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgaGlzdG9yaWNhbE9iamVjdFBhdGgsIGluaXRpYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGludWVUcmF2ZXJzYWw7XHJcbiAgICB9O1xyXG4gICAgLyogIFZhcmlhYmxlIE5hbWU6IHRoaXMudHlwZUV4dGVuc2lvbnNcclxuICAgICAqICBEZXNjcmlwdGlvbjogVGhpcyB2YXJpYWJsZSBob2xkcyBhIHRyYXZlcnNhbCBtYXBcclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlRXh0ZW5zaW9ucyA9IHtcclxuICAgICAgICBcIkFycmF5XCI6IHtcclxuICAgICAgICAgICAgdHlwZTogQXJyYXksXHJcbiAgICAgICAgICAgIGVudW1lcmF0b3JzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5leHRlbmRcclxuICAgICAqICBEZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiBjb25maWd1cmVzIGEgdHlwZSBleHRlbnNpb24gZm9yIHRoZSBlbnVtZXJhdG9yIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uICh0eXBlLCBlbnVtZXJhdG9yKSB7XHJcbiAgICAgICAgdGhpcy50eXBlRXh0ZW5zaW9uc1t0eXBlLm5hbWVdID0ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBlbnVtZXJhdG9yczogKGVudW1lcmF0b3IuY29uc3RydWN0b3IgPT09IEFycmF5ID8gZW51bWVyYXRvciA6IFtlbnVtZXJhdG9yXSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy9SZWN1cnNpdmUgSGVscGVyIEZ1bmN0aW9uc1xyXG4gICAgLypcdEZ1bmN0aW9uIE5hbWU6IHRoaXMucGx1Y2tcclxuICAgICAqXHREZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgZGF0YSBnaXZlbiBhIHBhdGggKGFycmF5IG9mIGxpdGVyYWwgdHJhdmVyc2FscyBpbiBvcmRlcilcclxuICAgICAqL1xyXG4gICAgdGhpcy5wbHVjayA9IGZ1bmN0aW9uIChkYXRhLCBwYXRoLCBzZXQgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbHVjayhkYXRhW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCBzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbcGF0aFswXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW3BhdGhbMF1dID0gc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbcGF0aFswXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIC8qIFx0RnVuY3Rpb24gTmFtZTogdGhpcy5wYXRoRXhpc3RzXHJcbiAgICAgKlx0RGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRvIHNlZSBpZiBnaXZlbiBwYXRoIGV4aXN0cyBpbiBhIHNldFxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhdGhFeGlzdHMgPSBmdW5jdGlvbiAoZGF0YSwgYmluZHBhdGgsIGN1cnBhdGggPSBbXSkge1xyXG4gICAgICAgIGxldCBpc0VxdWFsID0gdGhpcy5hcnJFcXVhbHMoYmluZHBhdGgsIGN1cnBhdGgpICYmIGJpbmRwYXRoLmxlbmd0aCA9PT0gY3VycGF0aC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFpc0VxdWFsKSB7XHJcbiAgICAgICAgICAgIGN1cnBhdGgucHVzaChiaW5kcGF0aFtjdXJwYXRoLmxlbmd0aF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wbHVjayhkYXRhLCBjdXJwYXRoKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aEV4aXN0cyhkYXRhLCBiaW5kcGF0aCwgY3VycGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZHBhdGguc2xpY2UoY3VycGF0aC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kcGF0aC5zbGljZShjdXJwYXRoLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiAgIEZ1bmN0aW9uIE5hbWU6IHRoaXMuc2NhZmZvbGRcclxuICAgICAqICAgRGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyBhIGJsYW5rIGluY29taW5nIHR5cGVkIGl0ZW1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY2FmZm9sZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIGlmIChpbnB1dC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogIEZ1bmN0aW9uIE5hbWU6IHRoaXMuaXNQcmltaXRpdmVcclxuICAgICAqICBEZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudCBpcyBhIHByaW1pdGl2ZSB0eXBlIGluIGphdmFzY3JpcHRcclxuICAgICAqL1xyXG4gICAgdGhpcy5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XHJcbiAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fCAodHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBcImZ1bmN0aW9uXCIpO1xyXG4gICAgfTtcclxuICAgIC8qXHRGdW5jdGlvbiBOYW1lOiB0aGlzLmFyckVxdWFsc1xyXG4gICAgICpcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHRocm91Z2ggYXJyYXkgZWxlbWVudHMgdG8gY2hlY2sgZXF1YWxpdHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5hcnJFcXVhbHMgPSBmdW5jdGlvbiAoYXJyMSwgYXJyMikge1xyXG4gICAgICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQoYXJyMS5sZW5ndGgpOyBpLS07KSB7XHJcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyogIFZhcmlhYmxlIE5hbWU6IHRoaXMuYWNjZXNzTWFwXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IFRoaXMgdmFyaWFibGUgaG9sZHMgcmVmZXJlbmNlcyB0byBhbGwgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBhY2Nlc3NlZCB2aWEgaXNDaXJjdWxhciB0byByZW1vdmUgX19hY2Nlc3NlZF9fIGtleSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWNjZXNzTWFwID0ge307XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5jbGVhckFjY2Vzc01hcFxyXG4gICAgICogIERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIGNsZWFycyBhbiBhY2Nlc3MgbWFwIHV0aWxpemVkIGJ5IGdydWwgdG8gaGFsdCBhdCBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsZWFyQWNjZXNzTWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjZXNzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjY2Vzc01hcFtrZXldLl9fYWNjZXNzZWRfXzsgICAgLy9jbGVhbiB1cCB0ZW1wb3JhcnkgbWVtYmVyIG9uIGFjY2Vzc2VkIG9iamVjdFxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY2Nlc3NNYXBba2V5XTsgICAgICAgICAgICAgICAgIC8vY2xlYW4gdXAgdGVtcG9yYXJ5IG1lbWJlciBvbiBhY2Nlc3MgbWFwXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogIEZ1bmN0aW9uIE5hbWU6IHRoaXMuaXNDaXJjdWxhclxyXG4gICAgICogIERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgZ2l2ZW4gYSBkYXRhc2V0IHdoZXRoZXIgb3Igbm90IHRoYXQgdHJhdmVyc2VkIHBhdGggaXMgY2lyY3VsYXIgaW4gbmF0dXJlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNDaXJjdWxhciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltaXRpdmUoZGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKFwiX19hY2Nlc3NlZF9fXCIgaW4gZGF0YSAmJiBkYXRhLl9fYWNjZXNzZWRfXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFjY2Vzc01hcEtleSA9IE9iamVjdC5rZXlzKHRoaXMuYWNjZXNzTWFwKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzTWFwW2FjY2Vzc01hcEtleV0gPSBkYXRhO1xyXG4gICAgICAgICAgICBkYXRhLl9fYWNjZXNzZWRfXyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy9SZWN1cnNpdmUgTGFtYmRhJ3NcclxuICAgIC8qICBGdW5jdGlvbiBOYW1lOiB0aGlzLmF0SGllcmFyY2h5XHJcbiAgICAgKiAgRGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIGFueSBzdGF0aWMgb3IgZHluYW1pYyB0ZW1wbGF0ZSBoaWVyYXJjaHkgZXhlY3V0aW5nIGFueSBoZWFkLCB0YWlsIGxvZ2ljIHRvIHJlc3RydWN0dXJlIGEgMiBkaW1lbnNpb25hbCBKU09OIHNldFxyXG4gICAgICogICAgICAgICAgICAgIGludG8gdGhlIGRlZmluZWQgaGllcmFyY2hpY2FsIHNldCBhbmQgZ3JvdXBpbmcgcm93cyBieSBhIHVuaXF1ZSBkeW5hbWljYWxseSBnZW5lcmF0ZWQgaGVhZCBrZXlcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdEhpZXJhcmNoeSA9IGZ1bmN0aW9uIChkYXRhLCBoaWVyYXJjaHksIGhpc3RvcmljYWxUeXBlUGF0aCA9IFtdLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGggPSBbXSwgcm9vdCA9IHRoaXMuc2NhZmZvbGQoaGllcmFyY2h5KSkge1xyXG4gICAgICAgIGlmIChoaWVyYXJjaHkuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5mb3JFYWNoKCh0ZW1wbGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvdW5kID0ge307IC8vIGRlZmluZXMgZGF0YS9oaWVyYXJjaHkvcGF0aCB0byBiZSBzZXQgZm9yIG5leHQgXHJcbiAgICAgICAgICAgICAgICBsZXQgaGVhZHMgPSBbXTsgLy8gZGVmaW5lcyBoZWFkIHdoaWNoIGdlbmVyYXRlcyBoaWVyYXJjaGljYWwgY29tcG91bmQga2V5XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFpbHMgPSBbXTsgLy8gZGVmaW5lcyB0YWlscyB3aGljaCBnZW5lcmF0ZXMgaGllcmFyY2hpY2FsIHZhbHVlcyBiYXNlZCBvbiBwcmV2aW91cyByZWN1cnNpdmUgYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBsZXQgYnJhbmNoZXMgPSBbXTsgLy8gZGVmaW5lZCBicmFuY2hlcyB3aGljaCByZWZsZWN0IGhpZXJhcmNoaWNhbCBjaGlsZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgbGV0IHJIaWVyYXJjaHkgPSB0ZW1wbGF0ZS5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24gPyB0ZW1wbGF0ZShkYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgaGllcmFyY2h5KSA6IHRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG91dCA9IHRoaXMuc2NhZmZvbGQockhpZXJhcmNoeSk7IC8vIGRlZmluZXMgc2NhZmZvbGRpbmcgZm9yIHRlbXBsYXRlIHRvIGJlIGNsb25lZCBpbnRvIGEgc2VnbWVudCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgLy9idWlsZCBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdEV2ZXJ5KHJIaWVyYXJjaHksIChzZWdtZW50SW5wdXQsIHR5cGVQYXRoLCBsaXRlcmFsUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50SW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRJbnB1dC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ21lbnRNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNlZ21lbnRUeXBlUGF0aFwiOiB0eXBlUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2VnbWVudExpdGVyYWxQYXRoXCI6IGxpdGVyYWxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoaWVyYXJjaHlcIjogc2VnbWVudElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goc2VnbWVudE1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Y2sob3V0LCBsaXRlcmFsUGF0aCwgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZ21lbnRJbnB1dC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIFwiaGVhZFwiIGluIHNlZ21lbnRJbnB1dCAmJiBzZWdtZW50SW5wdXQuaGVhZC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ21lbnRNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNlZ21lbnRUeXBlUGF0aFwiOiB0eXBlUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2VnbWVudExpdGVyYWxQYXRoXCI6IGxpdGVyYWxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXBcIjogc2VnbWVudElucHV0LmhlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZHMucHVzaChzZWdtZW50TWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVjayhvdXQsIHNlZ21lbnRNYXAuc2VnbWVudExpdGVyYWxQYXRoLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWdtZW50SW5wdXQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBcInRhaWxcIiBpbiBzZWdtZW50SW5wdXQgJiYgc2VnbWVudElucHV0LnRhaWwuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50TWFwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWdtZW50VHlwZVBhdGhcIjogdHlwZVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNlZ21lbnRMaXRlcmFsUGF0aFwiOiBsaXRlcmFsUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFwXCI6IHNlZ21lbnRJbnB1dC50YWlsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxzLnB1c2goc2VnbWVudE1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Y2sob3V0LCBzZWdtZW50TWFwLnNlZ21lbnRMaXRlcmFsUGF0aCwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Y2sob3V0LCBsaXRlcmFsUGF0aCwgdGhpcy5zY2FmZm9sZChzZWdtZW50SW5wdXQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vZmlsbCBzZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChyb3cpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY2xvbmUob3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcG91bmRLZXkgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlsbCBzZWdtZW50IHdpdGggaGVhZCByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZHMuZm9yRWFjaCgoaGVhZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBoZWFkLm1hcChyb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsVHlwZVBhdGguY29uY2F0KGhlYWQuc2VnbWVudFR5cGVQYXRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcmljYWxMaXRlcmFsUGF0aC5jb25jYXQoaGVhZC5zZWdtZW50TGl0ZXJhbFBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNldCA9IHRoaXMucGx1Y2soc2VnbWVudCwgaGVhZC5zZWdtZW50TGl0ZXJhbFBhdGgsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGhlYWQuc2VnbWVudExpdGVyYWxQYXRoLmxlbmd0aCA9PT0gMCA/IHNldCA6IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kS2V5ICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBGdXR1cmUgUmVjdXJzaXZlbHkgRW51bWVyYWJsZSBIaWVyYXJjaHkgVXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRQYXR0ZXJuKHNlZ21lbnQsW1wiaGVhZFwiXSx7XCJoZWFkXCI6KGRhdGEsaHRwLGhscCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2Nlc3NNYXApLmZvckVhY2goa2V5PT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hY2Nlc3NNYXBba2V5XS5fX2FjY2Vzc2VkX187ICAgIC8vY2xlYW4gdXAgdGVtcG9yYXJ5IG1lbWJlciBvbiBhY2Nlc3NlZCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjY2Vzc01hcFtrZXldOyAgICAgICAgICAgICAgICAgLy9jbGVhbiB1cCB0ZW1wb3JhcnkgbWVtYmVyIG9uIGFjY2VzcyBtYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXRIaWVyYXJjaHkoW3Jvd10sc2VnbWVudCxoaXN0b3JpY2FsVHlwZVBhdGguY29uY2F0KGh0cCksaGlzdG9yaWNhbExpdGVyYWxQYXRoLmNvbmNhdChobHApLHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH19KTtcclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3VuZEtleSBpbiBjb21wb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFtjb21wb3VuZEtleV0ucm93cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFtjb21wb3VuZEtleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzOiBbcm93XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzOiBicmFuY2hlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vZmlsbCBzZWdtZW50IHdpdGggdGFpbCByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb21wb3VuZCkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGx1Y2socm9vdCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucHVzaChjb21wb3VuZFtrZXldLnNlZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlUGF0aCA9IGhpc3RvcmljYWxUeXBlUGF0aC5jb25jYXQob3V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGl0ZXJhbFBhdGggPSBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguY29uY2F0KFtwYXJlbnQubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kW2tleV0uYnJhbmNoZXMuZm9yRWFjaCgoYnJhbmNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuVHlwZVBhdGggPSB0eXBlUGF0aC5jb25jYXQoYnJhbmNoLnNlZ21lbnRUeXBlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuTGl0ZXJhbFBhdGggPSBsaXRlcmFsUGF0aC5jb25jYXQoYnJhbmNoLnNlZ21lbnRMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXRIaWVyYXJjaHkoY29tcG91bmRba2V5XS5yb3dzLCBicmFuY2guaGllcmFyY2h5LCBuVHlwZVBhdGgsIG5MaXRlcmFsUGF0aCwgcm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFpbHMuZm9yRWFjaCgodGFpbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWNrKGNvbXBvdW5kW2tleV0uc2VnbWVudCwgdGFpbC5zZWdtZW50TGl0ZXJhbFBhdGgsIHRhaWwubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRba2V5XS5yb3dzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbFR5cGVQYXRoLmNvbmNhdChjb21wb3VuZFtrZXldLnNlZ21lbnRUeXBlUGF0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguY29uY2F0KGNvbXBvdW5kW2tleV0uc2VnbWVudExpdGVyYWxQYXRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJIaWVyYXJjaHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0YWlscyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmF0RXZlcnkoaGllcmFyY2h5LCAoaW5wdXQsIGh0cCwgaGxwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVjayhyb290LCBobHAsIHRoaXMuc2NhZmZvbGQoaW5wdXQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0SGllcmFyY2h5KGRhdGEsIGlucHV0LCBodHAsIGhscCwgcm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBcImhlYWRcIiBpbiBpbnB1dCAmJiBpbnB1dC5oZWFkLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Y2socm9vdCwgaGxwLCBpbnB1dC5oZWFkKGRhdGEsIGh0cCwgaGxwLCBoaWVyYXJjaHkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIFwidGFpbFwiIGluIGlucHV0ICYmIGlucHV0LnRhaWwuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFpbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRUeXBlUGF0aDogaHRwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50TGl0ZXJhbFBhdGg6IGhscCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBpbnB1dC50YWlsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVjayhyb290LCBobHAsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Y2socm9vdCwgaGxwLCB0aGlzLnNjYWZmb2xkKGlucHV0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRhaWxzLmZvckVhY2goKHRhaWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Y2socm9vdCwgdGFpbC5zZWdtZW50TGl0ZXJhbFBhdGgsIHRhaWwubWFwKGRhdGEsIHRhaWwuc2VnbWVudFR5cGVQYXRoLCB0YWlsLnNlZ21lbnRMaXRlcmFsUGF0aCwgaGllcmFyY2h5KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH07XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5hdFN1YmRpdmlzaW9uXHJcbiAgICAgKiAgRGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyBhbnkgMiBkaW1lbnNpb25hbCBhcnJheSBpbnRvIGEgbGlua2VkIHRyZWUgYmFzZWQgb24gdGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgc3BlY2lmaWVkLCBwcm92aWRpbmcgdGhlIHVzZXIgd2l0aFxyXG4gICAgICogICAgICAgICAgICAgIGEgZnVuY3Rpb24gYXQgZWFjaCBzdWJkaXZpc2lvbnMgZm9yIG1ha2luZyBjdXN0b21pemF0aW9ucyB0byB0aGUgc3ViZGl2aWRlZCBhcmVhXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXRTdWJkaXZpc2lvbiA9IGZ1bmN0aW9uIChkYXRhLCBzdWJkaXZpc2lvbnMgPSAyLCBsb2dpYywgaGlzdG9yaWNhbFR5cGVQYXRoID0gW10sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCA9IFtdLCByb290RGF0YSA9IGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgbGV0IG50cCA9IGhpc3RvcmljYWxUeXBlUGF0aC5jb25jYXQoW0FycmF5XSk7XHJcbiAgICAgICAgICAgIGxldCBubHAgPSBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguY29uY2F0KFswXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHN1YmRpdmlzaW9uID0gbmV3IEFycmF5KHN1YmRpdmlzaW9ucykuZmlsbChudWxsKTtcclxuICAgICAgICAgICAgbGV0IG50cCA9IGhpc3RvcmljYWxUeXBlUGF0aC5jb25jYXQoW0FycmF5LCBPYmplY3RdKTtcclxuICAgICAgICAgICAgc3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbi5tYXAoKGJsYW5rLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5scCA9IGhpc3RvcmljYWxMaXRlcmFsUGF0aC5jb25jYXQoW2luZGV4LCBcImdyb3VwXCJdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0U3ViZGl2aXNpb24oZGF0YS5zbGljZShpbmRleCAqIChkYXRhLmxlbmd0aCAvIHN1YmRpdmlzaW9ucyksIChpbmRleCArIDEpICogKGRhdGEubGVuZ3RoIC8gc3ViZGl2aXNpb25zKSksIHN1YmRpdmlzaW9ucywgbG9naWMsIG50cCwgbmxwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBzdWJkaXZpc2lvbkdyb3VwID0geyBncm91cDogc3ViZGl2aXNpb24gfTtcclxuICAgICAgICAgICAgbG9naWMoc3ViZGl2aXNpb25Hcm91cCwgaGlzdG9yaWNhbFR5cGVQYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgpXHJcbiAgICAgICAgICAgIHJldHVybiBzdWJkaXZpc2lvbkdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5hdFN0cnVjdHVyZVxyXG4gICAgICogIERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyBhbnkgbXVsdGlkaW1lbnNpb25hbCBzZXQgYW5kIG1vZGlmaWVzIHRoZSBleGlzdGluZyBwYXRoIHN0cnVjdHVyZSAobWV0YVBhdGgpIHRvIHRoZSBzcGVjaWZpZWQgZGVzaXJlZCBwYXRoIHN0cnVjdHVyZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0U3RydWN0dXJlID0gZnVuY3Rpb24gKGRhdGEsIG1ldGFQYXRoLCBsb2dpYywgcmVsYXRpdml0eSA9IDAsIGhpc3RvcmljYWxUeXBlUGF0aCA9IFtdLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGggPSBbXSwgcm9vdERhdGEgPSBkYXRhKSB7XHJcbiAgICAgICAgLyogW3suLi4gY2hpbGRyZW46W3suLi59XX1dIFxyXG4gICAgICAgICAqIG9sZE1ldGFQYXRoID0+IFtcImNoaWxkcmVuXCIsQXJyYXldXHJcbiAgICAgICAgICogbmV3TWV0YVBhdGggPT4gW1wiY2hpbGRyZW5cIixPYmplY3RdXHJcbiAgICAgICAgICoga2V5UGF0aHMgPT4gW11cclxuICAgICAgICAgKi9cclxuICAgIH07XHJcbiAgICAvKiAgRnVuY3Rpb24gTmFtZTogdGhpcy5hdFNlZ21lbnRcclxuICAgICAqICBEZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgYSBtdWx0aWRpbWVuc2lvbmFsIHNldCBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgbWV0YVBhdGggc3RhcnRpbmcgZnJvbSB0aGUgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCB1bnRpbCBpdCBmaW5kcyB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgbmV4dCBleGlzdGVuY2Ugb2YgbWV0YVBhdGgsIG9yIHRoZSBlbmRzIGFyZSBwcmltaXRpdmUgYW5kIHJldHVybnMgYSBzaGFsbG93IGNvcHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdFNlZ21lbnQgPSBmdW5jdGlvbiAoZGF0YSwgbWV0YVBhdGgsIGxvZ2ljLCByZWxhdGl2aXR5ID0gMCwgaGlzdG9yaWNhbFR5cGVQYXRoID0gW10sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCA9IFtdLCByb290RGF0YSA9IGRhdGEpIHtcclxuICAgICAgICBsZXQgaW5jbHVkZSwgZXhjbHVkZSwgZGVwdGgsIGxhZztcclxuICAgICAgICBpZiAobWV0YVBhdGguY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICBpbmNsdWRlID0gbWV0YVBhdGguaW5jbHVkZTtcclxuICAgICAgICAgICAgZXhjbHVkZSA9IG1ldGFQYXRoLmV4Y2x1ZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1ldGFQYXRoLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAgICAgICBpbmNsdWRlID0gbWV0YVBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2aXR5LmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAgICAgICBkZXB0aCA9IHJlbGF0aXZpdHlbMF0gfHwgMTtcclxuICAgICAgICAgICAgbGFnID0gcmVsYXRpdml0eVsxXSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWxhdGl2aXR5LmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgZGVwdGggPSByZWxhdGl2aXR5LmRlcHRoIHx8IDA7XHJcbiAgICAgICAgICAgIGxhZyA9IHJlbGF0aXZpdHkubGFnIHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXB0aCA9IHJlbGF0aXZpdHkgKyAxO1xyXG4gICAgICAgICAgICBsYWcgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBsdWNrKGRhdGEsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgbGV0IGluY2x1ZGVQYXRocyA9IFtdO1xyXG4gICAgICAgIGxldCBleGNsdWRlUGF0aHMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0UGF0dGVybihzdGFydCwgaW5jbHVkZSwge1xyXG4gICAgICAgICAgICBcImhlYWRcIjogKGRhdGEsIGh0cCwgaGxwLCBob3ApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChob3AubGVuZ3RoID09PSBkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVQYXRocy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbFR5cGVQYXRoOiBodHAuc2xpY2UoMCwgaHRwLmxlbmd0aCArIGxhZyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcmljYWxMaXRlcmFsUGF0aDogaGxwLnNsaWNlKDAsIGh0cC5sZW5ndGggKyBsYWcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsT2JqZWN0UGF0aDogaG9wXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChob3AubGVuZ3RoID09PSAoZGVwdGggKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVQYXRocy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbFR5cGVQYXRoOiBodHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcmljYWxMaXRlcmFsUGF0aDogaGxwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsT2JqZWN0UGF0aDogaG9wXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgbGFnKTtcclxuICAgICAgICBpZiAoZXhjbHVkZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0UGF0dGVybihzdGFydCwgZXhjbHVkZSwge1xyXG4gICAgICAgICAgICAgICAgXCJoZWFkXCI6IChkYXRhLCBleGNsdWRlaHRwLCBleGNsdWRlaGxwLCBleGNsdWRlaG9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNsdWRlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluY2x1ZGUgPSBpbmNsdWRlUGF0aHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmNsdWRlaGxwID0gaW5jbHVkZS5oaXN0b3JpY2FsTGl0ZXJhbFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlaGxwLmpvaW4oXCI8PT09PlwiKS5pbmRleE9mKGV4Y2x1ZGVobHAuam9pbihcIjw9PT0+XCIpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUGF0aHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVQYXRocy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbFR5cGVQYXRoOiBleGNsdWRlaHRwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsTGl0ZXJhbFBhdGg6IGV4Y2x1ZGVobHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcmljYWxPYmplY3RQYXRoOiBleGNsdWRlaG9wXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgZXhjbHVkZU1hcCA9IHt9O1xyXG4gICAgICAgIGV4Y2x1ZGVQYXRocy5mb3JFYWNoKGV4Y2x1ZGUgPT4ge1xyXG4gICAgICAgICAgICBleGNsdWRlTWFwW2V4Y2x1ZGUuaGlzdG9yaWNhbExpdGVyYWxQYXRoLmpvaW4oXCI8PT09PlwiKV0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGluY2x1ZGVQYXRocy5mb3JFYWNoKChpbmNsdWRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZWZlcmVuY2UgPSB0aGlzLnBsdWNrKHN0YXJ0LCBpbmNsdWRlLmhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgIGxldCBjbG9uZSA9IHRoaXMuc2NhZmZvbGQocmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5hdEV2ZXJ5KHJlZmVyZW5jZSwgKGRhdGEsIGh0cCwgaGxwLCByb290KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VyUGF0aCA9IGluY2x1ZGUuaGlzdG9yaWNhbExpdGVyYWxQYXRoLmNvbmNhdChobHApLmpvaW4oXCI8PT09PlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJQYXRoIGluIGV4Y2x1ZGVNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWNrKGNsb25lLCBobHAsIHRoaXMuY2xvbmUodGhpcy5zY2FmZm9sZChkYXRhKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjbG9uZSxcclxuICAgICAgICAgICAgICAgIGhpc3RvcmljYWxUeXBlUGF0aDogaW5jbHVkZS5oaXN0b3JpY2FsVHlwZVBhdGgsXHJcbiAgICAgICAgICAgICAgICBoaXN0b3JpY2FsTGl0ZXJhbFBhdGg6IGluY2x1ZGUuaGlzdG9yaWNhbExpdGVyYWxQYXRoLFxyXG4gICAgICAgICAgICAgICAgaGlzdG9yaWNhbE9iamVjdFBhdGg6IGluY2x1ZGUuaGlzdG9yaWNhbE9iamVjdFBhdGhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2ljKGNsb25lLCBpbmNsdWRlLmhpc3RvcmljYWxUeXBlUGF0aCwgaW5jbHVkZS5oaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIGluY2x1ZGUuaGlzdG9yaWNhbE9iamVjdFBhdGgsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdtZW50cztcclxuICAgIH07XHJcbiAgICAvKiBcdEZ1bmN0aW9uIE5hbWU6IHRoaXMuYXRNZXRhXHJcbiAgICAgKlx0RGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdGhyb3VnaCB2YWx1ZXMgd2hpY2ggaGF2ZSBtYXRjaGluZyBsaXRlcmFsL3R5cGVwYXRocyBmcm9tIHRoZSBiYXNlIG9mIHRoZSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgbWV0YVBhdGgsIGxvZ2ljLCByZWxhdGl2aXR5ID0gMCwgaGlzdG9yaWNhbFR5cGVQYXRoID0gW10sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCA9IFtdLCBoaXN0b3JpY2FsT2JqZWN0UGF0aCA9IFtdLCByb290RGF0YSA9IGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdFBhdHRlcm4oZGF0YSwgbWV0YVBhdGgsIHsgXCJoZWFkXCI6IGxvZ2ljIH0sIHJlbGF0aXZpdHksIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCBudWxsLCBkYXRhLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICAvKlx0RnVuY3Rpb24gTmFtZTogdGhpcy5hdFBhdHRlcm5cclxuICAgICAqXHREZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0aHJvdWdoIHZhbHVlcyB3aGljaCBoYXZlIG1hdGNoaW5nIGxpdGVyYWwvdHlwZXBhdGhzIHRocm91Z2hvdXQgdGhlIGVudGlyZXR5IG9mIGFuIG9iamVjdCBcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdFBhdHRlcm4gPSBmdW5jdGlvbiAoZGF0YSwgbWV0YVBhdGgsIGxvZ2ljLCByZWxhdGl2aXR5ID0gMCwgaGlzdG9yaWNhbFR5cGVQYXRoID0gW10sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCA9IFtdLCBjdXJNZXRhLCByb290RGF0YSA9IGRhdGEsIGRpcmVjdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoZWQgPSB7fTtcclxuICAgICAgICBsZXQgYURhdGE7XHJcbiAgICAgICAgbGV0IG1ldGFUZW1wbGF0ZSA9IHtcclxuICAgICAgICAgICAgbWF0Y2hDb3VudDogMCxcclxuICAgICAgICAgICAgaG9wOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG5ld01ldGEgPSBbXTtcclxuICAgICAgICBpZiAobWV0YVBhdGhbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJNZXRhKSB7IH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdNZXRhID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFQYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TWV0YS5wdXNoKHRoaXMuY2xvbmUobWV0YVRlbXBsYXRlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGFQYXRoID0gW21ldGFQYXRoXTtcclxuICAgICAgICAgICAgbmV3TWV0YSA9IFttZXRhVGVtcGxhdGVdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBpZiAoaGlzdG9yaWNhbExpdGVyYWxQYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IG1hdGNoRXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YVBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG5ld01ldGFbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb3VudDogdGhpcy5jbG9uZShjdXJNZXRhW2ldLm1hdGNoQ291bnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvcDogY3VyTWV0YVtpXS5ob3BcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0ICYmIGhpc3RvcmljYWxMaXRlcmFsUGF0aC5sZW5ndGggPiBtZXRhUGF0aFtpXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNZXRhW2ldLm1hdGNoQ291bnQgPSBtZXRhUGF0aFtpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFQYXRoW2ldW25ld01ldGFbaV0ubWF0Y2hDb3VudF0gIT09IHVuZGVmaW5lZCAmJiBoaXN0b3JpY2FsVHlwZVBhdGhbaGlzdG9yaWNhbFR5cGVQYXRoLmxlbmd0aCAtIDFdLm5hbWUgPT09IG1ldGFQYXRoW2ldW25ld01ldGFbaV0ubWF0Y2hDb3VudF0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01ldGFbaV0ubWF0Y2hDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRXhpc3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFQYXRoW2ldW25ld01ldGFbaV0ubWF0Y2hDb3VudF0gIT09IHVuZGVmaW5lZCAmJiBoaXN0b3JpY2FsTGl0ZXJhbFBhdGhbaGlzdG9yaWNhbExpdGVyYWxQYXRoLmxlbmd0aCAtIDFdID09PSBtZXRhUGF0aFtpXVtuZXdNZXRhW2ldLm1hdGNoQ291bnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TWV0YVtpXS5tYXRjaENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hFeGlzdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TWV0YVtpXS5tYXRjaENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdNZXRhW2ldLm1hdGNoQ291bnQgPT09IG1ldGFQYXRoW2ldLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51ZVRyYXZlcnNhbDtcclxuICAgICAgICAgICAgICAgICAgICBhRGF0YSA9IHJlbGF0aXZpdHkgPT09IDAgPyBkYXRhIDogdGhpcy5wbHVjayhyb290RGF0YSwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLnNsaWNlKDAsIChoaXN0b3JpY2FsTGl0ZXJhbFBhdGgubGVuZ3RoKSArIHJlbGF0aXZpdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNZXRhW2ldLmhvcCA9IG5ld01ldGFbaV0uaG9wLmNvbmNhdChbeyBkYXRhOiBhRGF0YSB9XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb3plbkhvcEluZGV4ID0gbmV3TWV0YVtpXS5ob3AubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvemVuTWV0YUluZGV4ID0gdGhpcy5jbG9uZShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvemVuSG9wSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01ldGFbaV0uaG9wW2Zyb3plbkhvcEluZGV4XS5wcmV2aW91cyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdNZXRhW2Zyb3plbk1ldGFJbmRleF0uaG9wW2Zyb3plbkhvcEluZGV4IC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01ldGFbaV0uaG9wW2Zyb3plbkhvcEluZGV4XS5wcmV2aW91cygpLm5leHQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3TWV0YVtmcm96ZW5NZXRhSW5kZXhdLmhvcFtmcm96ZW5Ib3BJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlVHJhdmVyc2FsID0gdGhpcy5leGVjdXRlTG9naWMobG9naWMsIFwiaGVhZFwiLCBpLCBhRGF0YSwgaGlzdG9yaWNhbFR5cGVQYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIG5ld01ldGFbaV0uaG9wLCByb290RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFtpXSA9IGFEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVRyYXZlcnNhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXdNZXRhW2ldLm1hdGNoQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3QgJiYgIW1hdGNoRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCghZGlyZWN0KSAmJiB0aGlzLmlzQ2lyY3VsYXIoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YSB0cmF2ZXJzYWwgaGFsdGVkIEAgXCIgKyBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguam9pbihcIi1cIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmh0cGF0aCA9IGhpc3RvcmljYWxUeXBlUGF0aC5zbGljZSgwKTtcclxuICAgICAgICAgICAgbmh0cGF0aC5wdXNoKGRhdGEuY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuaGxwYXRoID0gdGhpcy5jbG9uZShoaXN0b3JpY2FsTGl0ZXJhbFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5obHBhdGgucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0UGF0dGVybihkYXRhW2ldLCBtZXRhUGF0aCwgbG9naWMsIHJlbGF0aXZpdHksIG5odHBhdGgsIG5obHBhdGgsIG5ld01ldGEsIHJvb3REYXRhLCBkaXJlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCAodHlwZW9mIGRhdGEgPT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnN0cnVjdG9yLm5hbWUgaW4gdGhpcy50eXBlRXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZUV4dGVuc2lvbnNbZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXS5lbnVtZXJhdG9ycy5mb3JFYWNoKChlbnVtZXJhdG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IoZGF0YSwgbWV0YVBhdGgsIGxvZ2ljLCByZWxhdGl2aXR5LCBuaHRwYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIG5ld01ldGEsIHJvb3REYXRhLCBkaXJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuaGxwYXRoID0gdGhpcy5jbG9uZShoaXN0b3JpY2FsTGl0ZXJhbFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaGxwYXRoLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdFBhdHRlcm4oZGF0YVtrZXldLCBtZXRhUGF0aCwgbG9naWMsIHJlbGF0aXZpdHksIG5odHBhdGgsIG5obHBhdGgsIG5ld01ldGEsIHJvb3REYXRhLCBkaXJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YVBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gbWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVUcmF2ZXJzYWwgPSB0aGlzLmV4ZWN1dGVMb2dpYyhsb2dpYywgXCJ0YWlsXCIsIGksIGFEYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgbmV3TWV0YVtpXS5ob3AsIHJvb3REYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVRyYXZlcnNhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYURhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEgPT09IHJvb3REYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBY2Nlc3NNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgLypcdEZ1bmN0aW9uIE5hbWU6IHRoaXMuYXRTaGFsbG93ZXN0UGF0dGVyblxyXG4gICAgICpcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHRoaXMuYXRQYXR0ZXJuLCBzdG9yZXMgdGhlIGlucHV0cyB3aXRoIHRoZSBsZWFzdCBkZXB0aCB0byBiZSBleGVjdXRlZCBsb2dpY2FsbHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdFNoYWxsb3dlc3RQYXR0ZXJuID0gZnVuY3Rpb24gKGRhdGEsIG1ldGFQYXRoLCBsb2dpYywgcmVsYXRpdml0eSA9IDApIHtcclxuICAgICAgICB2YXIgbGVhc3REZXB0aCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0UGF0dGVybihkYXRhLCBtZXRhUGF0aCwge1xyXG4gICAgICAgICAgICBcImhlYWRcIjogZnVuY3Rpb24gKGlucHV0LCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgaGlzdG9yaWNhbE9iamVjdFBhdGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoaXN0b3JpY2FsTGl0ZXJhbFBhdGgubGVuZ3RoIDwgbGVhc3REZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXN0RGVwdGggPSBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlzdG9yaWNhbExpdGVyYWxQYXRoLmxlbmd0aCA+IGxlYXN0RGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnB1dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5wdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbFR5cGVQYXRoOiBoaXN0b3JpY2FsVHlwZVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbExpdGVyYWxQYXRoOiBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbE9iamVjdFBhdGg6IGhpc3RvcmljYWxPYmplY3RQYXRoXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHJlbGF0aXZpdHkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxvZ2ljKGlucHV0c1tpXS5kYXRhLCBpbnB1dHNbaV0uaGlzdG9yaWNhbFR5cGVQYXRoLCBpbnB1dHNbaV0uaGlzdG9yaWNhbExpdGVyYWxQYXRoLCBpbnB1dHNbaV0uaGlzdG9yaWNhbE9iamVjdFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICAvKlx0RnVuY3Rpb24gTmFtZTogdGhpcy5hdERlZXBlc3RQYXR0ZXJuXHJcbiAgICAgKlx0RGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdGhpcy5hdFBhdHRlcm4sIHN0b3JlcyB0aGUgaW5wdXRzIHdpdGggbW9zdCBkZXB0aCB0byBiZSBleGVjdXRlZCBsb2dpY2FsbHkgLSAoUmV0dXJucyBmYWxzZSB3aXRoaW4gLmF0UGF0dGVybiB3aGVyZSBkZXB0aCBpcyBncmVhdGVyIHRoYW4pXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXREZWVwZXN0UGF0dGVybiA9IGZ1bmN0aW9uIChkYXRhLCBtZXRhUGF0aCwgbG9naWMsIHJlbGF0aXZpdHkgPSAwKSB7XHJcbiAgICAgICAgdmFyIGdyZWF0ZXN0RGVwdGggPSAtMTtcclxuICAgICAgICBsZXQgaW5wdXRzID0gW107XHJcbiAgICAgICAgdGhpcy5hdFBhdHRlcm4oZGF0YSwgbWV0YVBhdGgsIGZ1bmN0aW9uIChpbnB1dCwgaGlzdG9yaWNhbFR5cGVQYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIGhpc3RvcmljYWxPYmplY3RQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChoaXN0b3JpY2FsTGl0ZXJhbFBhdGgubGVuZ3RoID4gZ3JlYXRlc3REZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgZ3JlYXRlc3REZXB0aCA9IGhpc3RvcmljYWxMaXRlcmFsUGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnB1dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dCxcclxuICAgICAgICAgICAgICAgIGhpc3RvcmljYWxUeXBlUGF0aDogaGlzdG9yaWNhbFR5cGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgaGlzdG9yaWNhbExpdGVyYWxQYXRoOiBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsXHJcbiAgICAgICAgICAgICAgICBoaXN0b3JpY2FsT2JqZWN0UGF0aDogaGlzdG9yaWNhbE9iamVjdFBhdGhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgcmVsYXRpdml0eSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbG9naWMoaW5wdXRzW2ldLmRhdGEsIGlucHV0c1tpXS5oaXN0b3JpY2FsVHlwZVBhdGgsIGlucHV0c1tpXS5oaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIGlucHV0c1tpXS5oaXN0b3JpY2FsT2JqZWN0UGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIC8qIFx0RnVuY3Rpb24gTmFtZTogdGhpcy5hdEVuZHNcclxuICAgICAqXHREZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0aHJvdWdoIHRoZSBwcmltaXRpdmUgZW5kcyBvZiBvYmplY3RzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXRFbmRzID0gZnVuY3Rpb24gKGRhdGEsIGxvZ2ljLCBoaXN0b3JpY2FsVHlwZVBhdGggPSBbXSwgaGlzdG9yaWNhbExpdGVyYWxQYXRoID0gW10pIHtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsb2dpYyhkYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBudHAgPSBoaXN0b3JpY2FsVHlwZVBhdGguY29uY2F0KFtPYmplY3RdKTtcclxuICAgICAgICAgICAgICAgIGxldCBubHAgPSBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguY29uY2F0KFtrZXldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXRFbmRzKGRhdGFba2V5XSwgbG9naWMsIG50cCwgbmxwKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnRwID0gaGlzdG9yaWNhbFR5cGVQYXRoLmNvbmNhdChbQXJyYXldKTtcclxuICAgICAgICAgICAgICAgIGxldCBubHAgPSBoaXN0b3JpY2FsTGl0ZXJhbFBhdGguY29uY2F0KFtpXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0RW5kcyhkYXRhW2ldLCBsb2dpYywgbnRwLCBubHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bmNBcmdzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG50cCA9IGhpc3RvcmljYWxUeXBlUGF0aC5jb25jYXQoW0Z1bmN0aW9uXSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmxwID0gaGlzdG9yaWNhbExpdGVyYWxQYXRoLmNvbmNhdChkYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXRFbmRzKGRhdGEobG9naWMsIG50cCwgbmxwKSwgbG9naWMsIG50cCwgbmxwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dpYyhkYXRhLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIC8qXHRGdW5jdGlvbiBOYW1lOiB0aGlzLmF0RXZlcnlcclxuICAgICAqIFx0RGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gcnVucyBwYXNzZWQgbG9naWMgYXQgZXZlcnkgcG90ZW50aWFsIHRyYXZlcnNhbCBvciBlbmRwb2ludFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0RXZlcnkgPSBmdW5jdGlvbiAoZGF0YSwgbG9naWMsIGhpc3RvcmljYWxUeXBlUGF0aCA9IFtdLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGggPSBbXSwgcm9vdERhdGEgPSBkYXRhKSB7XHJcbiAgICAgICAgbGV0IGlDb250aW51ZSA9IGxvZ2ljKGRhdGEsIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCByb290RGF0YSk7XHJcbiAgICAgICAgaWYgKCEoaUNvbnRpbnVlID09PSB0cnVlIHx8IGlDb250aW51ZSA9PT0gdW5kZWZpbmVkIHx8IGlDb250aW51ZSA9PT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3VHlwZVBhdGggPSB0aGlzLmNsb25lKGhpc3RvcmljYWxUeXBlUGF0aCk7XHJcbiAgICAgICAgbmV3VHlwZVBhdGgucHVzaChkYXRhLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCl7fVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0xpdFBhdGggPSB0aGlzLmNsb25lKGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBuZXdMaXRQYXRoLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0RXZlcnkoZGF0YVtpXSwgbG9naWMsIG5ld1R5cGVQYXRoLCBuZXdMaXRQYXRoLCByb290RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8ICh0eXBlb2YgZGF0YSA9PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3TGl0UGF0aCA9IHRoaXMuY2xvbmUoaGlzdG9yaWNhbExpdGVyYWxQYXRoKTtcclxuICAgICAgICAgICAgICAgIG5ld0xpdFBhdGgucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdEV2ZXJ5KGRhdGFba2V5XSwgbG9naWMsIG5ld1R5cGVQYXRoLCBuZXdMaXRQYXRoLCByb290RGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICAvKlx0RnVuY3Rpb24gTmFtZTogdGhpcy5hdE1ldGFFbmRzXHJcbiAgICAgKiBcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIHJ1bnMgdGhpcy5hdE1ldGEsIGFuZCB0aGVuIHBlcmZvcm1zIGxvZ2ljIGF0IHRoZSBlbmRzIG9mIHRoZSBvYmplY3QgcmV0dXJuZWQgdG8gaXQgYnkgdGhpcy5hdE1ldGFcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdE1ldGFFbmRzID0gZnVuY3Rpb24gKGRhdGEsIG1ldGFQYXRoLCBsb2dpYykge1xyXG4gICAgICAgIHZhciByZWN1cnNpdmVSZWYgPSB0aGlzO1xyXG4gICAgICAgIHJlY3Vyc2l2ZVJlZi5hdE1ldGEoZGF0YSwgbWV0YVBhdGgsIHtcclxuICAgICAgICAgICAgXCJoZWFkXCI6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlUmVmLmF0RW5kcyhpbnB1dCwgbG9naWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgLypcdEZ1bmN0aW9uIE5hbWU6IHRoaXMuYXRQYXR0ZXJuRW5kc1xyXG4gICAgICpcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIHJ1bnMgdGhpcy5hdFBhdHRlcm4sIGFuZCB0aGVuIHBlcmZvcm1zIGxvZ2ljIGF0IHRoZSBwYXR0ZXJuIG9mIHRoZSBvYmplY3QgcmV0dXJuZWQgdG8gaXQgYnkgdGhpcy5hdFBhdHRlcm5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hdFBhdHRlcm5FbmRzID0gZnVuY3Rpb24gKGRhdGEsIG1ldGFQYXRoLCBsb2dpYywgcmVsYXRpdml0eSA9IDApIHtcclxuICAgICAgICB2YXIgcmVjdXJzaXZlUmVmID0gdGhpcztcclxuICAgICAgICByZWN1cnNpdmVSZWYuYXRQYXR0ZXJuKGRhdGEsIG1ldGFQYXRoLCBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgcmVjdXJzaXZlUmVmLmF0RW5kcyhpbnB1dCwgbG9naWMpO1xyXG4gICAgICAgIH0sIHJlbGF0aXZpdHkpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIC8qXHRGdW5jdGlvbiBOYW1lOiB0aGlzLmF0TWF0Y2hpbmdcclxuICAgICAqXHREZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhyb3VnaCBzZXQsIGRldGVybWluaW5nIGlmIHNhbWUgcGF0aCBleGlzdHMgaW4gZGF0YSwgYW5kIGV4ZWN1dGVzIHRoZSBhc3NvY2lhdGVkIHBhdGggZnVuY3Rpb24gXCJhdE1hdGNoaW5nRnVuY3Rpb25cIiBvciB0aGUgc2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdE1hdGNoaW5nID0gZnVuY3Rpb24gKGRhdGEsIHNldCwgbWV0YVBhdGggPSBbXSwgbGl0ZXJhbFBhdGggPSBbXSkge1xyXG4gICAgICAgIHZhciBjdXJPYmogPSB0aGlzLnBsdWNrKHNldCwgbWV0YVBhdGgpO1xyXG4gICAgICAgIHZhciBjdXJEYXRhO1xyXG4gICAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjdXJEYXRhID0gdGhpcy5wbHVjayhkYXRhLCBtZXRhUGF0aCk7XHJcbiAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgZXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJPYmouY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjdXJPYmopLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5NZXRhUGF0aCA9IHRoaXMuY2xvbmUobWV0YVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgbk1ldGFQYXRoLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBuTGl0ZXJhbFBhdGggPSB0aGlzLmNsb25lKGxpdGVyYWxQYXRoKTtcclxuICAgICAgICAgICAgICAgIG5MaXRlcmFsUGF0aC5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0TWF0Y2hpbmcoZGF0YSwgc2V0LCBuTWV0YVBhdGgsIG5MaXRlcmFsUGF0aCk7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VyT2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFycmF5ICYmIGV4aXN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5NZXRhUGF0aCA9IHRoaXMuY2xvbmUobWV0YVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgbk1ldGFQYXRoLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGN1ckRhdGEubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbkxpdGVyYWxQYXRoID0gdGhpcy5jbG9uZShsaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbkxpdGVyYWxQYXRoLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdE1hdGNoaW5nKGRhdGEsIHNldCwgbk1ldGFQYXRoLCBuTGl0ZXJhbFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1ck9iai5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKG1ldGFQYXRoW21ldGFQYXRoLmxlbmd0aCAtIDFdID09PSBcImF0TWF0Y2hpbmdGdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvL1BlcmZvcm0gTG9naWMgYXQgUGF0aCBvZiBkYXRhIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgY3VyT2JqKHRoaXMucGx1Y2soZGF0YSwgbGl0ZXJhbFBhdGguc2xpY2UoMCwgLSAxKSksIHRoaXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VyT2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IFN0cmluZykge1xyXG4gICAgICAgICAgICBpZiAobWV0YVBhdGhbbWV0YVBhdGgubGVuZ3RoIC0gMV0gPT09IFwiYXRNYXRjaGluZ0Z1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vUGVyZm9ybSBMb2dpYyBhdCBQYXRoIG9mIGRhdGEgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dbY3VyT2JqXSh0aGlzLnBsdWNrKGRhdGEsIGxpdGVyYWxQYXRoLnNsaWNlKDAsIC0gMSkpLCB0aGlzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgY3VyRGF0YSArPSBjdXJPYmpcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXJPYmouY29uc3RydWN0b3IgPT09IE51bWJlciAmJiBleGlzdHMpIHtcclxuICAgICAgICAgICAgLy9EbyBhbiBFcXVpdmFsZW5jZSBNb2RpZmllclxyXG4gICAgICAgICAgICBpZiAoY3VyRGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBjdXJPYmouY29uc3RydWN0b3IubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyRGF0YSArPSBjdXJPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcdEZ1bmN0aW9uIE5hbWU6IHRoaXMuYXREZXB0aFxyXG4gICAgICpcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aHJvdWdoIHNldCwgcHVzaGluZyBhbGwgaXRlbXMgYXQgYSBkaW1lbnNpb25hbCBkZXB0aCBmcm9tIGJhc2UgaW50byBhbiBhcnJheSBhbmQgcmV0dXJuaW5nIHRoZW1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hdERlcHRoID0gZnVuY3Rpb24gKGRhdGEsIGRlcHRoID0gMCwgbG9naWMsIGhpc3RvcmljYWxUeXBlUGF0aCA9IFtdLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGggPSBbXSwgZmlyc3QgPSB0cnVlLCByb290RGF0YSA9IGRhdGEpIHtcclxuICAgICAgICBpZiAoZmlyc3QgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hdERlcHRoQ29udGFpbmVyID0gW107XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcclxuICAgICAgICAgICAgZGVwdGgtLVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0RGVwdGgoZGF0YVtrZXldLCBkZXB0aCwgbG9naWMsIGZpcnN0KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFycmF5XCIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXREZXB0aChkYXRhW2ldLCBkZXB0aCwgbG9naWMsIGZpcnN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9naWMoZGF0YSwgaGlzdG9yaWNhbFR5cGVQYXRoLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgsIHJvb3REYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5hdERlcHRoQ29udGFpbmVyLnB1c2goZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hdERlcHRoQ29udGFpbmVyO1xyXG4gICAgfTtcclxuICAgIC8qXHRGdW5jdGlvbiBOYW1lOiB0aGlzLmF0RGlmZlxyXG4gICAgICpcdERlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aHJvdWdoIG11bHRpcGxlIHNldHMsIGtlZXBpbmcgdHJhY2sgb2YgdGhlIHN0cnVjdHVyYWwgYW5kIGRhdGEgZGlmZmVyZW50aWFscyBiZXR3ZWVuIGFsbCBsaXN0ZWQgc2V0cy4gQmFzZSBzZXRzIG11c3QgYmUgaGVsZCBpbiBhcnJheSBmb3JtLiBzdHJpY3QgPT0gdHJ1ZSB3aWxsIG1vZGlmeSBjb250ZW50cyB0byBleGFjdGx5IG1hdGNoIFJGQyA2OTAyIHN0YW5kYXJkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXREaWZmID0gZnVuY3Rpb24gKGRhdGEsIGxvZ2ljID0gbnVsbCwgcHJpbWFyeSA9IDAsIHN0cmljdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IFBhdGNoRGlmZnMgPSBbXTtcclxuICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy9hZGQsIHJlcGxhY2UgY2hlY2tzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0RXZlcnkoZGF0YVtwcmltYXJ5XSwgKGN1ckRhdGEsIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCByb290RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNlY29uZGFyeSA9IDA7IHNlY29uZGFyeSA8IGRhdGEubGVuZ3RoOyBzZWNvbmRhcnkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kYXJ5ICE9PSBwcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXBhcmUgcHJpbWFyeSBzZXQgdG8gb3RoZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kYXJ5UGF0aEV4aXN0cyA9IHRoaXMucGF0aEV4aXN0cyhkYXRhW3NlY29uZGFyeV0sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kYXJ5UGF0aEV4aXN0cyAmJiBzZWNvbmRhcnlQYXRoRXhpc3RzLmNvbnN0cnVjdG9yID09PSBCb29sZWFuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCAmJiBjdXJEYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29tcGFyZVNldFZhbCA9IHRoaXMucGx1Y2soZGF0YVtzZWNvbmRhcnldLCBoaXN0b3JpY2FsTGl0ZXJhbFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRGF0YSA9PT0gY29tcGFyZVNldFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgZXF1aXZhbGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5scCA9IGhpc3RvcmljYWxMaXRlcmFsUGF0aC5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHJlcXVpcmVzIHVwZGF0aW5nIHRvIGJhc2Ugc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0Y2ggPSB0aGlzLlJGQzY5MDIoeyBcIm9wXCI6IFwicmVwbGFjZVwiLCBcInBhdGhcIjogbmxwLCBcInZhbHVlXCI6IGN1ckRhdGEsIFwicmVmXCI6IGRhdGFbc2Vjb25kYXJ5XSwgXCIjXCI6IHNlY29uZGFyeSB9LCBzdHJpY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGF0Y2hEaWZmcy5wdXNoKHBhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpYyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naWMocGF0Y2gsIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCByb290RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmxwID0gaGlzdG9yaWNhbExpdGVyYWxQYXRoLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRjaCA9IHRoaXMuUkZDNjkwMih7IFwib3BcIjogXCJhZGRcIiwgXCJwYXRoXCI6IG5scCwgXCJ2YWx1ZVwiOiBjdXJEYXRhLCBcInJlZlwiOiBkYXRhW3NlY29uZGFyeV0sIFwiI1wiOiBzZWNvbmRhcnkgfSwgc3RyaWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXRjaERpZmZzLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpYyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljKHBhdGNoLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgcm9vdERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZhbCBjaGVja3NcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNlY29uZGFyeSA9IDA7IHNlY29uZGFyeSA8IGRhdGEubGVuZ3RoOyBzZWNvbmRhcnkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRhcnkgIT09IHByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdEV2ZXJ5KGRhdGFbc2Vjb25kYXJ5XSwgKGN1ckRhdGEsIGhpc3RvcmljYWxUeXBlUGF0aCwgaGlzdG9yaWNhbExpdGVyYWxQYXRoLCByb290RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wYXJlIHNlY29uZGFyeSBzZXQgdG8gcHJpbWFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByaW1hcnlQYXRoRXhpc3RzID0gdGhpcy5wYXRoRXhpc3RzKGRhdGFbcHJpbWFyeV0sIGhpc3RvcmljYWxMaXRlcmFsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwcmltYXJ5UGF0aEV4aXN0cyAmJiBwcmltYXJ5UGF0aEV4aXN0cy5jb25zdHJ1Y3RvciA9PT0gQm9vbGVhbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmxwID0gaGlzdG9yaWNhbExpdGVyYWxQYXRoLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRjaCA9IHRoaXMuUkZDNjkwMih7IFwib3BcIjogXCJyZW1vdmVcIiwgXCJwYXRoXCI6IG5scCwgXCJ2YWx1ZVwiOiBjdXJEYXRhLCBcInJlZlwiOiBkYXRhW3NlY29uZGFyeV0sIFwiI1wiOiBzZWNvbmRhcnkgfSwgc3RyaWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXRjaERpZmZzLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpYyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljKHBhdGNoLCBoaXN0b3JpY2FsVHlwZVBhdGgsIGhpc3RvcmljYWxMaXRlcmFsUGF0aCwgcm9vdERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm90aGluZyB0byBjb21wYXJlIGFnYWluc3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmFzZSBkYXRhIGlzIG5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhdGNoRGlmZnM7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5SRkM2OTAyID0gZnVuY3Rpb24gKHBhdGNoLCBzdHJpY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChzdHJpY3QpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHBhdGNoW1wicmVmXCJdO1xyXG4gICAgICAgICAgICBkZWxldGUgcGF0Y2hbXCIjXCJdO1xyXG4gICAgICAgICAgICBwYXRjaFtcInBhdGhcIl0gPSBcIi9cIiArIHBhdGNoW1wicGF0aFwiXS5qb2luKFwiL1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGNoO1xyXG4gICAgfVxyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3J1bDtcclxuICAgIGNvbnNvbGUubG9nKFwiTm9kZSBMb2FkXCIpO1xyXG59XHJcbmNhdGNoIChleGNlcHRpb24pIHtcclxuICAgIGdydWwucGx1Y2sgPSBmdW5jdGlvbiAoZGF0YSwgcGF0aCwgc2V0ID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Y2soZGF0YVtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5nZXRBdHRyaWJ1dGUocGF0aFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtwYXRoWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbcGF0aFswXV0gPSBzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtwYXRoWzBdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgY29uc29sZS5sb2coXCJWYW5pbGxhIEphdmFTY3JpcHQgTG9hZFwiKTtcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///826\n\n}')}}]);