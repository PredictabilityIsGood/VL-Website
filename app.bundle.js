(self.webpackChunkvl_website=self.webpackChunkvl_website||[]).push([[524],{9:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ reload)\n/* harmony export */ });\n/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(904);\n/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(403);\n\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (document).querySelectorAll(selector) :\n    selector\n  )\n}\n\nconst { cssManager } = riot__WEBPACK_IMPORTED_MODULE_1__.__;\nconst { DOM_COMPONENT_INSTANCE_PROPERTY } = riot__WEBPACK_IMPORTED_MODULE_1__.__.globals;\n\nfunction reload(componentAPI) {\n  const { name } = componentAPI;\n\n  if (!name) {\n    console.warn('Anonymous components can not be reloaded'); \n    return []\n  }\n\n  return $(`${name}, [is=${name}]`).map((el) => {\n    const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n    // early return in case there is no riot instance found\n    if (!oldTag) return\n\n    // remove the tag template from the DOM\n    oldTag.unmount(true);\n    // delete the old css from the css manager\n    cssManager.remove(name);\n\n    // create the new tag\n    const newTag = (0,riot__WEBPACK_IMPORTED_MODULE_0__/* .component */ .s)(componentAPI)(el, oldTag.props);\n    newTag.update(oldTag.state);\n\n    return newTag\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AcmlvdGpzL2hvdC1yZWxvYWQvaW5kZXguanM/OTcyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfXywgY29tcG9uZW50IH0gZnJvbSAncmlvdCc7XG5cbi8qKlxuICogQ29udmVydHMgYW55IERPTSBub2RlL3MgdG8gYSBsb29wYWJsZSBhcnJheVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdCB9IGVscyAtIHNpbmdsZSBodG1sIGVsZW1lbnQgb3IgYSBub2RlIGxpc3RcbiAqIEByZXR1cm5zIHsgQXJyYXkgfSBhbHdheXMgYSBsb29wYWJsZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZG9tVG9BcnJheShlbHMpIHtcbiAgLy8gY2FuIHRoaXMgb2JqZWN0IGJlIGFscmVhZHkgbG9vcGVkP1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxzKSkge1xuICAgIC8vIGlzIGl0IGEgbm9kZSBsaXN0P1xuICAgIGlmIChcbiAgICAgIC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC9cbiAgICAgICAgLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVscykpXG4gICAgICAgICYmIHR5cGVvZiBlbHMubGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGVscylcbiAgICBlbHNlXG4gICAgICAvLyBpZiBpdCdzIGEgc2luZ2xlIG5vZGVcbiAgICAgIC8vIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgXCJhcnJheVwiIHdpdGggb25lIHNpbmdsZSBlbnRyeVxuICAgICAgcmV0dXJuIFtlbHNdXG4gIH1cbiAgLy8gdGhpcyBvYmplY3QgY291bGQgYmUgbG9vcGVkIG91dCBvZiB0aGUgYm94XG4gIHJldHVybiBlbHNcbn1cblxuLyoqXG4gKiBTaW1wbGUgaGVscGVyIHRvIGZpbmQgRE9NIG5vZGVzIHJldHVybmluZyB0aGVtIGFzIGFycmF5IGxpa2UgbG9vcGFibGUgb2JqZWN0XG4gKiBAcGFyYW0gICB7IHN0cmluZ3xET01Ob2RlTGlzdCB9IHNlbGVjdG9yIC0gZWl0aGVyIHRoZSBxdWVyeSBvciB0aGUgRE9NIG5vZGVzIHRvIGFycmFpZnlcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgICAgICAgc2NvcGUgICAgICAtIGNvbnRleHQgZGVmaW5pbmcgd2hlcmUgdGhlIHF1ZXJ5IHdpbGwgc2VhcmNoIGZvciB0aGUgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gRE9NIG5vZGVzIGZvdW5kIGFzIGFycmF5XG4gKi9cbmZ1bmN0aW9uICQoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHJldHVybiBkb21Ub0FycmF5KHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycgP1xuICAgIChkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgOlxuICAgIHNlbGVjdG9yXG4gIClcbn1cblxuY29uc3QgeyBjc3NNYW5hZ2VyIH0gPSBfXztcbmNvbnN0IHsgRE9NX0NPTVBPTkVOVF9JTlNUQU5DRV9QUk9QRVJUWSB9ID0gX18uZ2xvYmFscztcblxuZnVuY3Rpb24gcmVsb2FkKGNvbXBvbmVudEFQSSkge1xuICBjb25zdCB7IG5hbWUgfSA9IGNvbXBvbmVudEFQSTtcblxuICBpZiAoIW5hbWUpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Fub255bW91cyBjb21wb25lbnRzIGNhbiBub3QgYmUgcmVsb2FkZWQnKTsgXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gJChgJHtuYW1lfSwgW2lzPSR7bmFtZX1dYCkubWFwKChlbCkgPT4ge1xuICAgIGNvbnN0IG9sZFRhZyA9IGVsW0RPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFldO1xuXG4gICAgLy8gZWFybHkgcmV0dXJuIGluIGNhc2UgdGhlcmUgaXMgbm8gcmlvdCBpbnN0YW5jZSBmb3VuZFxuICAgIGlmICghb2xkVGFnKSByZXR1cm5cblxuICAgIC8vIHJlbW92ZSB0aGUgdGFnIHRlbXBsYXRlIGZyb20gdGhlIERPTVxuICAgIG9sZFRhZy51bm1vdW50KHRydWUpO1xuICAgIC8vIGRlbGV0ZSB0aGUgb2xkIGNzcyBmcm9tIHRoZSBjc3MgbWFuYWdlclxuICAgIGNzc01hbmFnZXIucmVtb3ZlKG5hbWUpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBuZXcgdGFnXG4gICAgY29uc3QgbmV3VGFnID0gY29tcG9uZW50KGNvbXBvbmVudEFQSSkoZWwsIG9sZFRhZy5wcm9wcyk7XG4gICAgbmV3VGFnLnVwZGF0ZShvbGRUYWcuc3RhdGUpO1xuXG4gICAgcmV0dXJuIG5ld1RhZ1xuICB9KVxufVxuXG5leHBvcnQgeyByZWxvYWQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n\n}")},21:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BT: () => (/* binding */ moveChildren),\n/* harmony export */   Br: () => (/* binding */ replaceChild),\n/* harmony export */   nc: () => (/* binding */ insertBefore),\n/* harmony export */   uN: () => (/* binding */ cleanNode),\n/* harmony export */   v7: () => (/* binding */ clearChildren),\n/* harmony export */   wN: () => (/* binding */ DOMattributesToObject),\n/* harmony export */   zz: () => (/* binding */ removeChild)\n/* harmony export */ });\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(867);\n/* Riot WIP, @license MIT */\n\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[(0,_strings_js__WEBPACK_IMPORTED_MODULE_0__/* .dashToCamelCase */ .I)(attribute.name)] = attribute.value;\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n\n// Ignore this helper because it's needed only for svg tags\nfunction moveChildren(source, target) {\n  // eslint-disable-next-line fp/no-loops\n  while (source.firstChild) target.appendChild(source.firstChild);\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild);\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nfunction clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0; i < children.length; i++) removeChild(children[i]);\n}\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nconst removeChild = (node) => node.remove();\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nconst insertBefore = (newNode, refNode) =>\n  refNode &&\n  refNode.parentNode &&\n  refNode.parentNode.insertBefore(newNode, refNode);\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nconst replaceChild = (newNode, replaced) =>\n  replaced &&\n  replaced.parentNode &&\n  replaced.parentNode.replaceChild(newNode, replaced);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9kb20uanM/NTBhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBkYXNoVG9DYW1lbENhc2UgfSBmcm9tICcuL3N0cmluZ3MuanMnO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGVsZW1lbnQgYXR0cmlidXRlcyBhcyBvYmplY3RcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIERPTSBub2RlIHdlIHdhbnQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCB0aGUgYXR0cmlidXRlcyBmb3VuZCBhcyBhIGtleSB2YWx1ZSBwYWlyc1xuICovXG5mdW5jdGlvbiBET01hdHRyaWJ1dGVzVG9PYmplY3QoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmF0dHJpYnV0ZXMpLnJlZHVjZSgoYWNjLCBhdHRyaWJ1dGUpID0+IHtcbiAgICBhY2NbZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZS5uYW1lKV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSlcbn1cblxuLyoqXG4gKiBNb3ZlIGFsbCB0aGUgY2hpbGQgbm9kZXMgZnJvbSBhIHNvdXJjZSB0YWcgdG8gYW5vdGhlclxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBzb3VyY2UgLSBzb3VyY2Ugbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgbm9kZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaXQncyBhIHZvaWQgbWV0aG9kIMKvXFxfKOODhClfL8KvXG4gKi9cblxuLy8gSWdub3JlIHRoaXMgaGVscGVyIGJlY2F1c2UgaXQncyBuZWVkZWQgb25seSBmb3Igc3ZnIHRhZ3NcbmZ1bmN0aW9uIG1vdmVDaGlsZHJlbihzb3VyY2UsIHRhcmdldCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnAvbm8tbG9vcHNcbiAgd2hpbGUgKHNvdXJjZS5maXJzdENoaWxkKSB0YXJnZXQuYXBwZW5kQ2hpbGQoc291cmNlLmZpcnN0Q2hpbGQpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgY2hpbGQgbm9kZXMgZnJvbSBhbnkgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjbGVhbk5vZGUobm9kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnAvbm8tbG9vcHNcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xufVxuXG4vKipcbiAqIENsZWFyIG11bHRpcGxlIGNoaWxkcmVuIGluIGEgbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50W119IGNoaWxkcmVuIC0gZGlyZWN0IGNoaWxkcmVuIG5vZGVzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjbGVhckNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmcC9uby1sb29wcyxmcC9uby1sZXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgcmVtb3ZlQ2hpbGQoY2hpbGRyZW5baV0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9bm9kZSAtIG5vZGUgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5jb25zdCByZW1vdmVDaGlsZCA9IChub2RlKSA9PiBub2RlLnJlbW92ZSgpO1xuXG4vKipcbiAqIEluc2VydCBiZWZvcmUgYSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuZXdOb2RlIC0gbm9kZSB0byBpbnNlcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZk5vZGUgLSByZWYgY2hpbGRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGluc2VydEJlZm9yZSA9IChuZXdOb2RlLCByZWZOb2RlKSA9PlxuICByZWZOb2RlICYmXG4gIHJlZk5vZGUucGFyZW50Tm9kZSAmJlxuICByZWZOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZk5vZGUpO1xuXG4vKipcbiAqIFJlcGxhY2UgYSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuZXdOb2RlIC0gbmV3IG5vZGUgdG8gYWRkIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlcGxhY2VkIC0gbm9kZSB0byByZXBsYWNlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5jb25zdCByZXBsYWNlQ2hpbGQgPSAobmV3Tm9kZSwgcmVwbGFjZWQpID0+XG4gIHJlcGxhY2VkICYmXG4gIHJlcGxhY2VkLnBhcmVudE5vZGUgJiZcbiAgcmVwbGFjZWQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgcmVwbGFjZWQpO1xuXG5leHBvcnQgeyBET01hdHRyaWJ1dGVzVG9PYmplY3QsIGNsZWFuTm9kZSwgY2xlYXJDaGlsZHJlbiwgaW5zZXJ0QmVmb3JlLCBtb3ZlQ2hpbGRyZW4sIHJlbW92ZUNoaWxkLCByZXBsYWNlQ2hpbGQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n\n}")},80:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ay: () => (/* binding */ bindingTypes),\n/* harmony export */   Dk: () => (/* binding */ TAG),\n/* harmony export */   IF: () => (/* binding */ IF),\n/* harmony export */   RB: () => (/* binding */ SIMPLE),\n/* harmony export */   We: () => (/* binding */ EACH),\n/* harmony export */   rt: () => (/* binding */ SLOT)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\n\nconst bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9iaW5kaW5nLXR5cGVzLmpzPzBkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogUmlvdCBXSVAsIEBsaWNlbnNlIE1JVCAqL1xuY29uc3QgRUFDSCA9IDA7XG5jb25zdCBJRiA9IDE7XG5jb25zdCBTSU1QTEUgPSAyO1xuY29uc3QgVEFHID0gMztcbmNvbnN0IFNMT1QgPSA0O1xuXG5jb25zdCBiaW5kaW5nVHlwZXMgPSB7XG4gIEVBQ0gsXG4gIElGLFxuICBTSU1QTEUsXG4gIFRBRyxcbiAgU0xPVCxcbn07XG5cbmV4cG9ydCB7IEVBQ0gsIElGLCBTSU1QTEUsIFNMT1QsIFRBRywgYmluZGluZ1R5cGVzIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80\n\n}")},116:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KF: () => (/* binding */ create$1),\n/* harmony export */   Lg: () => (/* binding */ create$4),\n/* harmony export */   vs: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _util_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/* harmony import */ var _util_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(604);\n/* harmony import */ var _util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);\n/* harmony import */ var _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(359);\n/* harmony import */ var _util_objects_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(765);\n/* harmony import */ var _util_checks_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(732);\n/* harmony import */ var _util_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(569);\n/* Riot WIP, @license MIT */\n\n\n\n\n\n\n\n\n\n\nconst HEAD_SYMBOL = Symbol();\nconst TAIL_SYMBOL = Symbol();\n\n/**\n * Create the <template> fragments text nodes\n * @returns {object} {{head: Text, tail: Text}}\n */\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n\n  return { head, tail }\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const { head, tail } = createHeadTailPlaceholders();\n\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail],\n  }\n}\n\n/* c8 ignore start */\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nconst udomdiff = (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node =\n        bEnd < bLength\n          ? bStart\n            ? get(b[bStart - 1], -0).nextSibling\n            : get(b[bEnd - bStart], 0)\n          : before;\n      while (bStart < bEnd) (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n            while (bStart < index) (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .replaceChild */ .Br)(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(get(a[aStart++], -1));\n    }\n  }\n  return b\n};\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\n\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const { placeholder, nodes, childrenMap } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n\n    // prepare the diffing\n    const { newChildrenMap, batches, futureNodes } = createPatch(\n      items,\n      scope,\n      parentScope,\n      this,\n    );\n\n    // patch the DOM only if there are new nodes\n    udomdiff(\n      nodes,\n      futureNodes,\n      patch(Array.from(childrenMap.values()), parentScope),\n      placeholder,\n    );\n\n    // trigger the mounts and the updates\n    batches.forEach((fn) => fn());\n\n    // update the children map\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n\n    return this\n  },\n};\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const { template, nodes, context } = element;\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop();\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item\n  }\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {object} scope - current template scope\n * @param   {object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {object} enhanced scope object\n */\nfunction extendScope(scope, { itemName, indexName, index, item }) {\n  (0,_util_objects_js__WEBPACK_IMPORTED_MODULE_4__/* .defineProperty */ .n8)(scope, itemName, item);\n  if (indexName) (0,_util_objects_js__WEBPACK_IMPORTED_MODULE_4__/* .defineProperty */ .n8)(scope, indexName, index);\n\n  return scope\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {object} data - An object containing:\n * @property {Map} newChildrenMap - a Map containing the new children template structure\n * @property {Array} batches - array containing the template lifecycle functions to trigger\n * @property {Array} futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag,\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item,\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta =\n      isTemplateTag && mustMount\n        ? createTemplateMeta(componentTemplate)\n        : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() =>\n        componentTemplate.mount(el, context, parentScope, meta),\n      );\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key);\n    futureNodes.push(...nodes);\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index,\n    });\n  });\n\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes,\n  }\n}\n\nfunction create$6(\n  node,\n  { evaluate, condition, itemName, indexName, getKey, template },\n) {\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n\n  (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(placeholder, node);\n  (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(node);\n\n  return {\n    ...EachBinding,\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isTemplate */ .Fl)(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder,\n  }\n}\n\n/**\n * Binding responsible for the `if` directive\n */\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n\n      (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break\n      case mustUnmount:\n        this.unmount(scope);\n        break\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n\n    return this\n  },\n};\n\nfunction create$5(node, { evaluate, template }) {\n  const placeholder = document.createTextNode('');\n\n  (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(placeholder, node);\n  (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(node);\n\n  return {\n    ...IfBinding,\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node),\n  }\n}\n\n/**\n * This method handles the REF attribute expressions\n * @param   {object} expression - expression data\n * @param   {HTMLElement} expression.node - target node\n * @param   {*} expression.value - the old expression cached value\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction refExpression({ node, value: oldValue }, value) {\n  // called on mount and update\n  if (value) value(node);\n  // called on unmount\n  // in this case the node value is null\n  else oldValue(null);\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nfunction normalizeStringValue(value) {\n  return (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isNil */ .gD)(value) ? '' : value\n}\n\n/**\n * This methods handles the input fields value updates\n * @param   {object} expression - expression data\n * @param   {HTMLElement} expression.node - target node\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction valueExpression({ node }, value) {\n  node.value = normalizeStringValue(value);\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = (value) =>\n  Array.isArray(value) ? value : [value, false];\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  },\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = (node) => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener\n};\n\n/**\n * Set a new event listener\n * @param   {object}  expression - event expression data\n * @param   {HTMLElement} expression.node - target node\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction eventExpression({ node, name }, value) {\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/* c8 ignore next */\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = (0,_util_misc_js__WEBPACK_IMPORTED_MODULE_6__/* .memoize */ .Bj)(\n  (name) => ElementProto.hasOwnProperty(name), // eslint-disable-line\n);\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {object} attributes - object containing the attributes names and values\n * @param   {*} oldAttributes - the old expression cached value\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes, oldAttributes) {\n  Object.entries(attributes)\n    // filter out the attributes that didn't change their value\n    .filter(([name, value]) => value !== oldAttributes?.[name])\n    .forEach(([name, value]) => {\n      switch (true) {\n        case name === _util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .REF_ATTRIBUTE */ .tg:\n          return refExpression({ node }, value)\n        case name === _util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .VALUE_ATTRIBUTE */ .jj:\n          return valueExpression({ node }, value)\n        case (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isEventAttribute */ .B_)(name):\n          return eventExpression({ node, name }, value)\n        default:\n          return attributeExpression({ node, name }, value)\n      }\n    });\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {object} newAttributes - object containing all the new attribute names\n * @param   {object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n\n  Object.entries(oldAttributes)\n    .filter(([name]) => !newKeys.includes(name))\n    .forEach(([name, value]) => {\n      switch (true) {\n        case name === _util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .REF_ATTRIBUTE */ .tg:\n          return refExpression({ node, value })\n        case name === _util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .VALUE_ATTRIBUTE */ .jj:\n          node.removeAttribute('value');\n          node.value = '';\n          return\n        case (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isEventAttribute */ .B_)(name):\n          return eventExpression({ node, name }, null)\n        default:\n          return node.removeAttribute(name)\n      }\n    });\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return ['string', 'number', 'boolean'].includes(typeof value)\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @param   {boolean} isBoolean - flag to handle boolean attributes\n * @returns {boolean} boolean - true if the attribute can be removed\n */\nfunction shouldRemoveAttribute(value, isBoolean) {\n  // boolean attributes should be removed if the value is falsy\n  if (isBoolean) return !value\n\n  // null and undefined values will remove the attribute as well\n  return (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isNil */ .gD)(value)\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {object} expression - attribute expression data\n * @param   {HTMLElement} expression.node - target node\n * @param   {string} expression.name - attribute name\n * @param   {boolean} expression.isBoolean - flag to handle boolean attributes\n * @param   {*} expression.value - the old expression cached value\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction attributeExpression(\n  { node, name, isBoolean: isBoolean$1, value: oldValue },\n  value,\n) {\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value, oldValue);\n    }\n\n    return\n  }\n\n  // store the attribute on the node to make it compatible with native custom elements\n  if (\n    !isNativeHtmlProperty(name) &&\n    ((0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isBoolean */ .Lm)(value) || (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isObject */ .Gv)(value) || (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isFunction */ .Tn)(value))\n  ) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value, isBoolean$1)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value, isBoolean$1));\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @param   {boolean} isBoolean - boolean attributes flag\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value, isBoolean) {\n  // be sure that expressions like selected={ true } will always be rendered as selected='selected'\n  // fix https://github.com/riot/riot/issues/2975\n  return !!value && isBoolean ? name : value\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nconst getTextNode = (node, childNodeIndex) => {\n  return node.childNodes[childNodeIndex]\n};\n\n/**\n * This methods handles a simple text expression update\n * @param   {object} expression - expression data\n * @param   {HTMLElement} expression.node - target node\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction textExpression({ node }, value) {\n  node.data = normalizeStringValue(value);\n}\n\nconst expressions = {\n  [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .ATTRIBUTE */ .bc]: attributeExpression,\n  [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .EVENT */ .ll]: eventExpression,\n  [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .TEXT */ .a$]: textExpression,\n  [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .VALUE */ .Qg]: valueExpression,\n  [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .REF */ .g4]: refExpression,\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    const value = this.evaluate(scope);\n\n    // IO() DOM updates\n    expressions[this.type](this, value);\n\n    // store the computed value for the update calls\n    this.value = value;\n\n    return this\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      expressions[this.type](this, value);\n      this.value = value;\n    }\n\n    return this\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount event and ref expressions\n    if (\n      [_util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .EVENT */ .ll, _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .REF */ .g4].includes(this.type) ||\n      // spread attributes might contain events or refs that must be unmounted\n      (this.type === _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .ATTRIBUTE */ .bc && !this.name)\n    )\n      expressions[this.type](this, null);\n\n    return this\n  },\n};\n\nfunction create$4(node, data) {\n  return {\n    ...Expression,\n    ...data,\n    node: data.type === _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .TEXT */ .a$ ? getTextNode(node, data.childNodeIndex) : node,\n  }\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return {\n      ...acc,\n      [method]: (scope) => {\n        return collection.map((item) => item[method](scope)) && context\n      },\n    }\n  }, {})\n}\n\nfunction create$3(node, { expressions }) {\n  return flattenCollectionMethods(\n    expressions.map((expression) => create$4(node, expression)),\n    ['mount', 'update', 'unmount'],\n  )\n}\n\nconst extendParentScope = (attributes, scope, parentScope) => {\n  if (!attributes || !attributes.length) return parentScope\n\n  return Object.assign(\n    Object.create(parentScope || null),\n    (0,_util_misc_js__WEBPACK_IMPORTED_MODULE_6__/* .generatePropsFromAttributes */ .bJ)(attributes, scope),\n  )\n};\n\nconst findSlotById = (id, slots) => slots?.find((slot) => slot.id === id);\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) =>\n  scope[_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .PARENT_KEY_SYMBOL */ .e5] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // templateData: null,\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope)\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots\n      ? findSlotById(this.name, scope.slots)\n      : false;\n    const { parentNode } = this.node;\n\n    // if the slot did not pass any content, we will use the self slot for optional fallback content (https://github.com/riot/riot/issues/3024)\n    const realParent = templateData ? getRealParent(scope, parentScope) : scope;\n\n    // if there is no html for the current slot detected we rely on the parent slots (https://github.com/riot/riot/issues/3055)\n    this.templateData = templateData?.html\n      ? templateData\n      : findSlotById(this.name, realParent.slots);\n\n    // override the template property if the slot needs to be replaced\n    this.template =\n      (this.templateData &&\n        create(this.templateData.html, this.templateData.bindings).createDOM(\n          parentNode,\n        )) ||\n      // otherwise use the optional template fallback if provided by the compiler see also https://github.com/riot/riot/issues/3014\n      this.template?.clone();\n\n    if (this.template) {\n      (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .cleanNode */ .uN)(this.node);\n      this.template.mount(\n        this.node,\n        this.getTemplateScope(scope, realParent),\n        realParent,\n      );\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(this.node);\n\n    return this\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = this.templateData\n        ? getRealParent(scope, parentScope)\n        : scope;\n\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(\n        this.getTemplateScope(scope, parentScope),\n        null,\n        mustRemoveRoot,\n      );\n    }\n\n    return this\n  },\n};\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n\n  if (!child) return\n\n  ;(0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .insertBefore */ .nc)(child, slot);\n  moveSlotInnerContent(slot);\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {object} data - slot binding data\n * @param   {string} data.name - slot id\n * @param   {AttributeExpressionData[]} data.attributes - slot attributes\n * @param   {TemplateChunk} data.template - slot fallback template\n * @returns {object} Slot binding object\n */\nfunction createSlot(node, { name, attributes, template }) {\n  return {\n    ...SlotBinding,\n    attributes,\n    template,\n    node,\n    name,\n  }\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots = [], attributes = []) {\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({ slots, attributes })\n  }\n\n  // otherwise we return a template chunk\n  return create(slotsToMarkup(slots), [\n    ...slotBindings(slots),\n    {\n      // the attributes should be registered as binding\n      // if we fallback to a normal template chunk\n      expressions: attributes.map((attr) => {\n        return {\n          type: _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .ATTRIBUTE */ .bc,\n          ...attr,\n        }\n      }),\n    },\n  ])\n}\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, { bindings }) => acc.concat(bindings), [])\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html\n  }, '')\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope)\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope);\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true);\n\n      // mount the new tag\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this\n  },\n};\n\nfunction create$2(\n  node,\n  { evaluate, getComponent, slots, attributes },\n) {\n  return {\n    ...TagBinding,\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent,\n  }\n}\n\nconst bindings = {\n  [_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__.IF]: create$5,\n  [_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SIMPLE */ .RB]: create$3,\n  [_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__/* .EACH */ .We]: create$6,\n  [_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__/* .TAG */ .Dk]: create$2,\n  [_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SLOT */ .rt]: createSlot,\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map((e) =>\n    e.type === _util_expression_types_js__WEBPACK_IMPORTED_MODULE_3__/* .TEXT */ .a$\n      ? {\n          ...e,\n          childNodeIndex: e.childNodeIndex + textExpressionsOffset,\n        }\n      : e,\n  )\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nfunction create$1(root, binding, templateTagOffset) {\n  const { selector, type, redundantAttribute, expressions } = binding;\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root;\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || [];\n\n  // init the binding\n  return (bindings[type] || bindings[_util_binding_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SIMPLE */ .RB])(node, {\n    ...binding,\n    expressions:\n      templateTagOffset && !selector\n        ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset)\n        : bindingExpressions,\n  })\n}\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isTemplate */ .Fl)(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content\n}\n\n// for svg nodes we need a bit more work\n/* c8 ignore start */\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(\n    new window.DOMParser().parseFromString(\n      `<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`,\n      'application/xml',\n    ).documentElement,\n    true,\n  );\n\n  return svgNode\n}\n/* c8 ignore end */\n\n/**\n * Create the DOM that will be injected\n * @param {object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nfunction createDOMTree(root, html) {\n  /* c8 ignore next */\n  if ((0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isSvg */ .$D)(root)) return createSVGTree(html, root)\n\n  return createHTMLTree(html, root)\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isSvg */ .$D)(el):\n      (0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .moveChildren */ .BT)(dom, el);\n      break\n    case (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isTemplate */ .Fl)(el):\n      el.parentNode.replaceChild(dom, el);\n      break\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html)\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0)\n}\n\n/**\n * Template Chunk model\n * @type {object}\n */\nconst TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom =\n      this.dom ||\n      createTemplateDOM(el, this.html) ||\n      document.createDocumentFragment();\n\n    return this\n  },\n\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta = {}) {\n    if (!el) (0,_util_misc_js__WEBPACK_IMPORTED_MODULE_6__/* .panic */ .WQ)('Please provide DOM node to mount properly your template');\n\n    if (this.el) this.unmount(scope);\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const { fragment, children, avoidDOMInjection } = meta;\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const { parentNode } = children ? children[0] : el;\n    const isTemplateTag = (0,_util_checks_js__WEBPACK_IMPORTED_MODULE_5__/* .isTemplate */ .Fl)(el);\n    const templateTagOffset = isTemplateTag\n      ? getTemplateTagOffset(parentNode, el, meta)\n      : null;\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el);\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true);\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el;\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag\n      ? children || Array.from(cloneNode.childNodes)\n      : null;\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);\n\n    // create the bindings\n    this.bindings = this.bindingsData.map((binding) =>\n      create$1(this.el, binding, templateTagOffset),\n    );\n    this.bindings.forEach((b) => b.mount(scope, parentScope));\n\n    // store the template meta properties\n    this.meta = meta;\n\n    return this\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach((b) => b.update(scope, parentScope));\n\n    return this\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot = false) {\n    const el = this.el;\n\n    if (!el) {\n      return this\n    }\n\n    this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .IS_PURE_SYMBOL */ .Db] || mustRemoveRoot === null:\n        break\n\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n      case Array.isArray(this.children):\n        ;(0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .clearChildren */ .v7)(this.children);\n        break\n\n      // clean the node children only\n      case !mustRemoveRoot:\n        ;(0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .cleanNode */ .uN)(el);\n        break\n\n      // remove the root node only if the mustRemoveRoot is truly\n      case !!mustRemoveRoot:\n        ;(0,_util_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .removeChild */ .zz)(el);\n        break\n    }\n\n    this.el = null;\n\n    return this\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return {\n      ...this,\n      meta: {},\n      el: null,\n    }\n  },\n};\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nfunction create(html, bindings = []) {\n  return {\n    ...TemplateChunk,\n    html,\n    bindingsData: bindings,\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2RlcGVuZGVuY2llcy9AcmlvdGpzL2RvbS1iaW5kaW5ncy9kaXN0L2RvbS1iaW5kaW5ncy5qcz80YzJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgV0lQLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IGluc2VydEJlZm9yZSwgcmVtb3ZlQ2hpbGQsIGNsZWFuTm9kZSwgY2xlYXJDaGlsZHJlbiwgbW92ZUNoaWxkcmVuLCByZXBsYWNlQ2hpbGQgfSBmcm9tICcuLi8uLi91dGlsL2RvbS5qcyc7XG5pbXBvcnQgeyBJU19QVVJFX1NZTUJPTCwgVkFMVUVfQVRUUklCVVRFLCBSRUZfQVRUUklCVVRFLCBQQVJFTlRfS0VZX1NZTUJPTCB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFNJTVBMRSwgU0xPVCwgVEFHLCBFQUNILCBJRiB9IGZyb20gJy4uLy4uL3V0aWwvYmluZGluZy10eXBlcy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJpbmRpbmdUeXBlcyB9IGZyb20gJy4uLy4uL3V0aWwvYmluZGluZy10eXBlcy5qcyc7XG5pbXBvcnQgeyBURVhULCBFVkVOVCwgUkVGLCBBVFRSSUJVVEUsIFZBTFVFIH0gZnJvbSAnLi4vLi4vdXRpbC9leHByZXNzaW9uLXR5cGVzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXhwcmVzc2lvblR5cGVzIH0gZnJvbSAnLi4vLi4vdXRpbC9leHByZXNzaW9uLXR5cGVzLmpzJztcbmltcG9ydCB7IGRlZmluZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vdXRpbC9vYmplY3RzLmpzJztcbmltcG9ydCB7IGlzVGVtcGxhdGUsIGlzQm9vbGVhbiwgaXNPYmplY3QsIGlzRnVuY3Rpb24sIGlzU3ZnLCBpc05pbCwgaXNFdmVudEF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL3V0aWwvY2hlY2tzLmpzJztcbmltcG9ydCB7IHBhbmljLCBtZW1vaXplLCBnZW5lcmF0ZVByb3BzRnJvbUF0dHJpYnV0ZXMgfSBmcm9tICcuLi8uLi91dGlsL21pc2MuanMnO1xuXG5jb25zdCBIRUFEX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgVEFJTF9TWU1CT0wgPSBTeW1ib2woKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIDx0ZW1wbGF0ZT4gZnJhZ21lbnRzIHRleHQgbm9kZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IHt7aGVhZDogVGV4dCwgdGFpbDogVGV4dH19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRUYWlsUGxhY2Vob2xkZXJzKCkge1xuICBjb25zdCBoZWFkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBjb25zdCB0YWlsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXG4gIGhlYWRbSEVBRF9TWU1CT0xdID0gdHJ1ZTtcbiAgdGFpbFtUQUlMX1NZTUJPTF0gPSB0cnVlO1xuXG4gIHJldHVybiB7IGhlYWQsIHRhaWwgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgdGVtcGxhdGUgbWV0YSBvYmplY3QgaW4gY2FzZSBvZiA8dGVtcGxhdGU+IGZyYWdtZW50c1xuICogQHBhcmFtICAge1RlbXBsYXRlQ2h1bmt9IGNvbXBvbmVudFRlbXBsYXRlIC0gdGVtcGxhdGUgY2h1bmsgb2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgbWV0YSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtb3VudCBmdW5jdGlvbiBvZiB0aGUgVGVtcGxhdGVDaHVua1xuICovXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZU1ldGEoY29tcG9uZW50VGVtcGxhdGUpIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBjb21wb25lbnRUZW1wbGF0ZS5kb20uY2xvbmVOb2RlKHRydWUpO1xuICBjb25zdCB7IGhlYWQsIHRhaWwgfSA9IGNyZWF0ZUhlYWRUYWlsUGxhY2Vob2xkZXJzKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBhdm9pZERPTUluamVjdGlvbjogdHJ1ZSxcbiAgICBmcmFnbWVudCxcbiAgICBoZWFkLFxuICAgIHRhaWwsXG4gICAgY2hpbGRyZW46IFtoZWFkLCAuLi5BcnJheS5mcm9tKGZyYWdtZW50LmNoaWxkTm9kZXMpLCB0YWlsXSxcbiAgfVxufVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogSVNDIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAsIEFuZHJlYSBHaWFtbWFyY2hpLCBAV2ViUmVmbGVjdGlvblxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gKiBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbiAqIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbiAqIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICogTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0VcbiAqIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcbiAqIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKi9cblxuLy8gZm9yayBvZiBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi91ZG9tZGlmZiB2ZXJzaW9uIDEuMS4wXG4vLyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vdWRvbWRpZmYvcHVsbC8yXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZVtdfSBhIFRoZSBsaXN0IG9mIGN1cnJlbnQvbGl2ZSBjaGlsZHJlblxuICogQHBhcmFtIHtOb2RlW119IGIgVGhlIGxpc3Qgb2YgZnV0dXJlIGNoaWxkcmVuXG4gKiBAcGFyYW0geyhlbnRyeTogTm9kZSwgYWN0aW9uOiBudW1iZXIpID0+IE5vZGV9IGdldFxuICogVGhlIGNhbGxiYWNrIGludm9rZWQgcGVyIGVhY2ggZW50cnkgcmVsYXRlZCBET00gb3BlcmF0aW9uLlxuICogQHBhcmFtIHtOb2RlfSBbYmVmb3JlXSBUaGUgb3B0aW9uYWwgbm9kZSB1c2VkIGFzIGFuY2hvciB0byBpbnNlcnQgYmVmb3JlLlxuICogQHJldHVybnMge05vZGVbXX0gVGhlIHNhbWUgbGlzdCBvZiBmdXR1cmUgY2hpbGRyZW4uXG4gKi9cbmNvbnN0IHVkb21kaWZmID0gKGEsIGIsIGdldCwgYmVmb3JlKSA9PiB7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGFFbmQgPSBhLmxlbmd0aDtcbiAgbGV0IGJFbmQgPSBiTGVuZ3RoO1xuICBsZXQgYVN0YXJ0ID0gMDtcbiAgbGV0IGJTdGFydCA9IDA7XG4gIGxldCBtYXAgPSBudWxsO1xuICB3aGlsZSAoYVN0YXJ0IDwgYUVuZCB8fCBiU3RhcnQgPCBiRW5kKSB7XG4gICAgLy8gYXBwZW5kIGhlYWQsIHRhaWwsIG9yIG5vZGVzIGluIGJldHdlZW46IGZhc3QgcGF0aFxuICAgIGlmIChhRW5kID09PSBhU3RhcnQpIHtcbiAgICAgIC8vIHdlIGNvdWxkIGJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSByZXN0IG9mIG5vZGVzIHRoYXRcbiAgICAgIC8vIG5lZWQgdG8gYmUgYWRkZWQgYXJlIG5vdCBhdCB0aGUgZW5kLCBhbmQgaW4gc3VjaCBjYXNlXG4gICAgICAvLyB0aGUgbm9kZSB0byBgaW5zZXJ0QmVmb3JlYCwgaWYgdGhlIGluZGV4IGlzIG1vcmUgdGhhbiAwXG4gICAgICAvLyBtdXN0IGJlIHJldHJpZXZlZCwgb3RoZXJ3aXNlIGl0J3MgZ29ubmEgYmUgdGhlIGZpcnN0IGl0ZW0uXG4gICAgICBjb25zdCBub2RlID1cbiAgICAgICAgYkVuZCA8IGJMZW5ndGhcbiAgICAgICAgICA/IGJTdGFydFxuICAgICAgICAgICAgPyBnZXQoYltiU3RhcnQgLSAxXSwgLTApLm5leHRTaWJsaW5nXG4gICAgICAgICAgICA6IGdldChiW2JFbmQgLSBiU3RhcnRdLCAwKVxuICAgICAgICAgIDogYmVmb3JlO1xuICAgICAgd2hpbGUgKGJTdGFydCA8IGJFbmQpIGluc2VydEJlZm9yZShnZXQoYltiU3RhcnQrK10sIDEpLCBub2RlKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGhlYWQgb3IgdGFpbDogZmFzdCBwYXRoXG4gICAgZWxzZSBpZiAoYkVuZCA9PT0gYlN0YXJ0KSB7XG4gICAgICB3aGlsZSAoYVN0YXJ0IDwgYUVuZCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG5vZGUgb25seSBpZiBpdCdzIHVua25vd24gb3Igbm90IGxpdmVcbiAgICAgICAgaWYgKCFtYXAgfHwgIW1hcC5oYXMoYVthU3RhcnRdKSkgcmVtb3ZlQ2hpbGQoZ2V0KGFbYVN0YXJ0XSwgLTEpKTtcbiAgICAgICAgYVN0YXJ0Kys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNhbWUgbm9kZTogZmFzdCBwYXRoXG4gICAgZWxzZSBpZiAoYVthU3RhcnRdID09PSBiW2JTdGFydF0pIHtcbiAgICAgIGFTdGFydCsrO1xuICAgICAgYlN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIHNhbWUgdGFpbDogZmFzdCBwYXRoXG4gICAgZWxzZSBpZiAoYVthRW5kIC0gMV0gPT09IGJbYkVuZCAtIDFdKSB7XG4gICAgICBhRW5kLS07XG4gICAgICBiRW5kLS07XG4gICAgfVxuICAgIC8vIFRoZSBvbmNlIGhlcmUgc2luZ2xlIGxhc3Qgc3dhcCBcImZhc3QgcGF0aFwiIGhhcyBiZWVuIHJlbW92ZWQgaW4gdjEuMS4wXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vdWRvbWRpZmYvYmxvYi9zaW5nbGUtZmluYWwtc3dhcC9lc20vaW5kZXguanMjTDY5LUw4NVxuICAgIC8vIHJldmVyc2Ugc3dhcDogYWxzbyBmYXN0IHBhdGhcbiAgICBlbHNlIGlmIChhW2FTdGFydF0gPT09IGJbYkVuZCAtIDFdICYmIGJbYlN0YXJ0XSA9PT0gYVthRW5kIC0gMV0pIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBcInNocmlua1wiIG9wZXJhdGlvbiB0aGF0IGNvdWxkIGhhcHBlbiBpbiB0aGVzZSBjYXNlczpcbiAgICAgIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgICAgLy8gWzEsIDQsIDMsIDIsIDVdXG4gICAgICAvLyBvciBhc3ltbWV0cmljIHRvb1xuICAgICAgLy8gWzEsIDIsIDMsIDQsIDVdXG4gICAgICAvLyBbMSwgMiwgMywgNSwgNiwgNF1cbiAgICAgIGNvbnN0IG5vZGUgPSBnZXQoYVstLWFFbmRdLCAtMSkubmV4dFNpYmxpbmc7XG4gICAgICBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkubmV4dFNpYmxpbmcpO1xuICAgICAgaW5zZXJ0QmVmb3JlKGdldChiWy0tYkVuZF0sIDEpLCBub2RlKTtcbiAgICAgIC8vIG1hcmsgdGhlIGZ1dHVyZSBpbmRleCBhcyBpZGVudGljYWwgKHllYWgsIGl0J3MgZGlydHksIGJ1dCBjaGVhcCDwn5GNKVxuICAgICAgLy8gVGhlIG1haW4gcmVhc29uIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2hlbiBhW2FFbmRdIHdpbGwgYmUgcmVhY2hlZCxcbiAgICAgIC8vIHRoZSBsb29wIHdpbGwgbGlrZWx5IGJlIG9uIHRoZSBmYXN0IHBhdGgsIGFzIGlkZW50aWNhbCB0byBiW2JFbmRdLlxuICAgICAgLy8gSW4gdGhlIGJlc3QgY2FzZSBzY2VuYXJpbywgdGhlIG5leHQgbG9vcCB3aWxsIHNraXAgdGhlIHRhaWwsXG4gICAgICAvLyBidXQgaW4gdGhlIHdvcnN0IG9uZSwgdGhpcyBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhbHJlYWR5XG4gICAgICAvLyBwcm9jZXNzZWQsIGJhaWxpbmcgb3V0IHByZXR0eSBxdWlja2x5IGZyb20gdGhlIG1hcCBpbmRleCBjaGVja1xuICAgICAgYVthRW5kXSA9IGJbYkVuZF07XG4gICAgfVxuICAgIC8vIG1hcCBiYXNlZCBmYWxsYmFjaywgXCJzbG93XCIgcGF0aFxuICAgIGVsc2Uge1xuICAgICAgLy8gdGhlIG1hcCByZXF1aXJlcyBhbiBPKGJFbmQgLSBiU3RhcnQpIG9wZXJhdGlvbiBvbmNlXG4gICAgICAvLyB0byBzdG9yZSBhbGwgZnV0dXJlIG5vZGVzIGluZGV4ZXMgZm9yIGxhdGVyIHB1cnBvc2VzLlxuICAgICAgLy8gSW4gdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8sIHRoaXMgaXMgYSBmdWxsIE8oTikgY29zdCxcbiAgICAgIC8vIGFuZCBzdWNoIHNjZW5hcmlvIGhhcHBlbnMgYXQgbGVhc3Qgd2hlbiBhbGwgbm9kZXMgYXJlIGRpZmZlcmVudCxcbiAgICAgIC8vIGJ1dCBhbHNvIGlmIGJvdGggZmlyc3QgYW5kIGxhc3QgaXRlbXMgb2YgdGhlIGxpc3RzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGkgPSBiU3RhcnQ7XG4gICAgICAgIHdoaWxlIChpIDwgYkVuZCkgbWFwLnNldChiW2ldLCBpKyspO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXQncyBhIGZ1dHVyZSBub2RlLCBoZW5jZSBpdCBuZWVkcyBzb21lIGhhbmRsaW5nXG4gICAgICBpZiAobWFwLmhhcyhhW2FTdGFydF0pKSB7XG4gICAgICAgIC8vIGdyYWIgdGhlIGluZGV4IG9mIHN1Y2ggbm9kZSwgJ2NhdXNlIGl0IG1pZ2h0IGhhdmUgYmVlbiBwcm9jZXNzZWRcbiAgICAgICAgY29uc3QgaW5kZXggPSBtYXAuZ2V0KGFbYVN0YXJ0XSk7XG4gICAgICAgIC8vIGlmIGl0J3Mgbm90IGFscmVhZHkgcHJvY2Vzc2VkLCBsb29rIG9uIGRlbWFuZCBmb3IgdGhlIG5leHQgTENTXG4gICAgICAgIGlmIChiU3RhcnQgPCBpbmRleCAmJiBpbmRleCA8IGJFbmQpIHtcbiAgICAgICAgICBsZXQgaSA9IGFTdGFydDtcbiAgICAgICAgICAvLyBjb3VudHMgdGhlIGFtb3VudCBvZiBub2RlcyB0aGF0IGFyZSB0aGUgc2FtZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgbGV0IHNlcXVlbmNlID0gMTtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgYUVuZCAmJiBpIDwgYkVuZCAmJiBtYXAuZ2V0KGFbaV0pID09PSBpbmRleCArIHNlcXVlbmNlKVxuICAgICAgICAgICAgc2VxdWVuY2UrKztcbiAgICAgICAgICAvLyBlZmZvcnQgZGVjaXNpb24gaGVyZTogaWYgdGhlIHNlcXVlbmNlIGlzIGxvbmdlciB0aGFuIHJlcGxhY2VzXG4gICAgICAgICAgLy8gbmVlZGVkIHRvIHJlYWNoIHN1Y2ggc2VxdWVuY2UsIHdoaWNoIHdvdWxkIGJyaW5ncyBhZ2FpbiB0aGlzIGxvb3BcbiAgICAgICAgICAvLyB0byB0aGUgZmFzdCBwYXRoLCBwcmVwZW5kIHRoZSBkaWZmZXJlbmNlIGJlZm9yZSBhIHNlcXVlbmNlLFxuICAgICAgICAgIC8vIGFuZCBtb3ZlIG9ubHkgdGhlIGZ1dHVyZSBsaXN0IGluZGV4IGZvcndhcmQsIHNvIHRoYXQgYVN0YXJ0XG4gICAgICAgICAgLy8gYW5kIGJTdGFydCB3aWxsIGJlIGFsaWduZWQgYWdhaW4sIGhlbmNlIG9uIHRoZSBmYXN0IHBhdGguXG4gICAgICAgICAgLy8gQW4gZXhhbXBsZSBjb25zaWRlcmluZyBhU3RhcnQgYW5kIGJTdGFydCBhcmUgYm90aCAwOlxuICAgICAgICAgIC8vIGE6IFsxLCAyLCAzLCA0XVxuICAgICAgICAgIC8vIGI6IFs3LCAxLCAyLCAzLCA2XVxuICAgICAgICAgIC8vIHRoaXMgd291bGQgcGxhY2UgNyBiZWZvcmUgMSBhbmQsIGZyb20gdGhhdCB0aW1lIG9uLCAxLCAyLCBhbmQgM1xuICAgICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGF0IHplcm8gY29zdFxuICAgICAgICAgIGlmIChzZXF1ZW5jZSA+IGluZGV4IC0gYlN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0KGFbYVN0YXJ0XSwgMCk7XG4gICAgICAgICAgICB3aGlsZSAoYlN0YXJ0IDwgaW5kZXgpIGluc2VydEJlZm9yZShnZXQoYltiU3RhcnQrK10sIDEpLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgdGhlIGVmZm9ydCB3YXNuJ3QgZ29vZCBlbm91Z2gsIGZhbGxiYWNrIHRvIGEgcmVwbGFjZSxcbiAgICAgICAgICAvLyBtb3ZpbmcgYm90aCBzb3VyY2UgYW5kIHRhcmdldCBpbmRleGVzIGZvcndhcmQsIGhvcGluZyB0aGF0IHNvbWVcbiAgICAgICAgICAvLyBzaW1pbGFyIG5vZGUgd2lsbCBiZSBmb3VuZCBsYXRlciBvbiwgdG8gZ28gYmFjayB0byB0aGUgZmFzdCBwYXRoXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlQ2hpbGQoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgbW92ZSB0aGUgc291cmNlIGZvcndhcmQsICdjYXVzZSB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgZWxzZSBhU3RhcnQrKztcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbm9kZSBoYXMgbm8gbWVhbmluZyBpbiB0aGUgZnV0dXJlIGxpc3QsIHNvIGl0J3MgbW9yZSB0aGFuIHNhZmVcbiAgICAgIC8vIHRvIHJlbW92ZSBpdCwgYW5kIGNoZWNrIHRoZSBuZXh0IGxpdmUgbm9kZSBvdXQgaW5zdGVhZCwgbWVhbmluZ1xuICAgICAgLy8gdGhhdCBvbmx5IHRoZSBsaXZlIGxpc3QgaW5kZXggc2hvdWxkIGJlIGZvcndhcmRlZFxuICAgICAgZWxzZSByZW1vdmVDaGlsZChnZXQoYVthU3RhcnQrK10sIC0xKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59O1xuXG5jb25zdCBVTk1PVU5UX1NDT1BFID0gU3ltYm9sKCd1bm1vdW50Jyk7XG5cbmNvbnN0IEVhY2hCaW5kaW5nID0ge1xuICAvLyBkeW5hbWljIGJpbmRpbmcgcHJvcGVydGllc1xuICAvLyBjaGlsZHJlbk1hcDogbnVsbCxcbiAgLy8gbm9kZTogbnVsbCxcbiAgLy8gcm9vdDogbnVsbCxcbiAgLy8gY29uZGl0aW9uOiBudWxsLFxuICAvLyBldmFsdWF0ZTogbnVsbCxcbiAgLy8gdGVtcGxhdGU6IG51bGwsXG4gIC8vIGlzVGVtcGxhdGVUYWc6IGZhbHNlLFxuICBub2RlczogW10sXG4gIC8vIGdldEtleTogbnVsbCxcbiAgLy8gaW5kZXhOYW1lOiBudWxsLFxuICAvLyBpdGVtTmFtZTogbnVsbCxcbiAgLy8gYWZ0ZXJQbGFjZWhvbGRlcjogbnVsbCxcbiAgLy8gcGxhY2Vob2xkZXI6IG51bGwsXG5cbiAgLy8gQVBJIG1ldGhvZHNcbiAgbW91bnQoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSlcbiAgfSxcbiAgdXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIsIG5vZGVzLCBjaGlsZHJlbk1hcCB9ID0gdGhpcztcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gc2NvcGUgPT09IFVOTU9VTlRfU0NPUEUgPyBudWxsIDogdGhpcy5ldmFsdWF0ZShzY29wZSk7XG4gICAgY29uc3QgaXRlbXMgPSBjb2xsZWN0aW9uID8gQXJyYXkuZnJvbShjb2xsZWN0aW9uKSA6IFtdO1xuXG4gICAgLy8gcHJlcGFyZSB0aGUgZGlmZmluZ1xuICAgIGNvbnN0IHsgbmV3Q2hpbGRyZW5NYXAsIGJhdGNoZXMsIGZ1dHVyZU5vZGVzIH0gPSBjcmVhdGVQYXRjaChcbiAgICAgIGl0ZW1zLFxuICAgICAgc2NvcGUsXG4gICAgICBwYXJlbnRTY29wZSxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIC8vIHBhdGNoIHRoZSBET00gb25seSBpZiB0aGVyZSBhcmUgbmV3IG5vZGVzXG4gICAgdWRvbWRpZmYoXG4gICAgICBub2RlcyxcbiAgICAgIGZ1dHVyZU5vZGVzLFxuICAgICAgcGF0Y2goQXJyYXkuZnJvbShjaGlsZHJlbk1hcC52YWx1ZXMoKSksIHBhcmVudFNjb3BlKSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICk7XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBtb3VudHMgYW5kIHRoZSB1cGRhdGVzXG4gICAgYmF0Y2hlcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGNoaWxkcmVuIG1hcFxuICAgIHRoaXMuY2hpbGRyZW5NYXAgPSBuZXdDaGlsZHJlbk1hcDtcbiAgICB0aGlzLm5vZGVzID0gZnV0dXJlTm9kZXM7XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIHRoaXMudXBkYXRlKFVOTU9VTlRfU0NPUEUsIHBhcmVudFNjb3BlKTtcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG59O1xuXG4vKipcbiAqIFBhdGNoIHRoZSBET00gd2hpbGUgZGlmZmluZ1xuICogQHBhcmFtICAge2FueVtdfSByZWR1bmRhbnQgLSBsaXN0IG9mIGFsbCB0aGUgY2hpbGRyZW4gKHRlbXBsYXRlLCBub2RlcywgY29udGV4dCkgYWRkZWQgdmlhIGVhY2hcbiAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gcGF0Y2ggZnVuY3Rpb24gdXNlZCBieSBkb21kaWZmXG4gKi9cbmZ1bmN0aW9uIHBhdGNoKHJlZHVuZGFudCwgcGFyZW50U2NvcGUpIHtcbiAgcmV0dXJuIChpdGVtLCBpbmZvKSA9PiB7XG4gICAgaWYgKGluZm8gPCAwKSB7XG4gICAgICAvLyBnZXQgdGhlIGxhc3QgZWxlbWVudCBhZGRlZCB0byB0aGUgY2hpbGRyZW5NYXAgc2F2ZWQgcHJldmlvdXNseVxuICAgICAgY29uc3QgZWxlbWVudCA9IHJlZHVuZGFudFtyZWR1bmRhbnQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIC8vIGdldCB0aGUgbm9kZXMgYW5kIHRoZSB0ZW1wbGF0ZSBpbiBzdG9yZWQgaW4gdGhlIGxhc3QgY2hpbGQgb2YgdGhlIGNoaWxkcmVuTWFwXG4gICAgICAgIGNvbnN0IHsgdGVtcGxhdGUsIG5vZGVzLCBjb250ZXh0IH0gPSBlbGVtZW50O1xuICAgICAgICAvLyByZW1vdmUgdGhlIGxhc3Qgbm9kZSAobm90aWNlIDx0ZW1wbGF0ZT4gdGFncyBtaWdodCBoYXZlIG1vcmUgY2hpbGRyZW4gbm9kZXMpXG4gICAgICAgIG5vZGVzLnBvcCgpO1xuXG4gICAgICAgIC8vIG5vdGljZSB0aGF0IHdlIHBhc3MgbnVsbCBhcyBsYXN0IGFyZ3VtZW50IGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHJvb3Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIHdpbGwgYmUgcmVtb3ZlZCBieSBkb21kaWZmXG4gICAgICAgIGlmICghbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gd2UgaGF2ZSBjbGVhcmVkIGFsbCB0aGUgY2hpbGRyZW4gbm9kZXMgYW5kIHdlIGNhbiB1bm1vdW50IHRoaXMgdGVtcGxhdGVcbiAgICAgICAgICByZWR1bmRhbnQucG9wKCk7XG4gICAgICAgICAgdGVtcGxhdGUudW5tb3VudChjb250ZXh0LCBwYXJlbnRTY29wZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHRlbXBsYXRlIG11c3QgYmUgZmlsdGVyZWQgZnJvbSBhIGxvb3BcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gY29uZGl0aW9uIC0gZmlsdGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBjb250ZXh0IC0gYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXRlbSBzaG91bGQgYmUgc2tpcHBlZFxuICovXG5mdW5jdGlvbiBtdXN0RmlsdGVySXRlbShjb25kaXRpb24sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbmRpdGlvbiA/ICFjb25kaXRpb24oY29udGV4dCkgOiBmYWxzZVxufVxuXG4vKipcbiAqIEV4dGVuZCB0aGUgc2NvcGUgb2YgdGhlIGxvb3BlZCB0ZW1wbGF0ZVxuICogQHBhcmFtICAge29iamVjdH0gc2NvcGUgLSBjdXJyZW50IHRlbXBsYXRlIHNjb3BlXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtICAge3N0cmluZ30gb3B0aW9ucy5pdGVtTmFtZSAtIGtleSB0byBpZGVudGlmeSB0aGUgbG9vcGVkIGl0ZW0gaW4gdGhlIG5ldyBjb250ZXh0XG4gKiBAcGFyYW0gICB7c3RyaW5nfSBvcHRpb25zLmluZGV4TmFtZSAtIGtleSB0byBpZGVudGlmeSB0aGUgaW5kZXggb2YgdGhlIGxvb3BlZCBpdGVtXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBvcHRpb25zLmluZGV4IC0gY3VycmVudCBpbmRleFxuICogQHBhcmFtICAgeyp9IG9wdGlvbnMuaXRlbSAtIGNvbGxlY3Rpb24gaXRlbSBsb29wZWRcbiAqIEByZXR1cm5zIHtvYmplY3R9IGVuaGFuY2VkIHNjb3BlIG9iamVjdFxuICovXG5mdW5jdGlvbiBleHRlbmRTY29wZShzY29wZSwgeyBpdGVtTmFtZSwgaW5kZXhOYW1lLCBpbmRleCwgaXRlbSB9KSB7XG4gIGRlZmluZVByb3BlcnR5KHNjb3BlLCBpdGVtTmFtZSwgaXRlbSk7XG4gIGlmIChpbmRleE5hbWUpIGRlZmluZVByb3BlcnR5KHNjb3BlLCBpbmRleE5hbWUsIGluZGV4KTtcblxuICByZXR1cm4gc2NvcGVcbn1cblxuLyoqXG4gKiBMb29wIHRoZSBjdXJyZW50IHRlbXBsYXRlIGl0ZW1zXG4gKiBAcGFyYW0gICB7QXJyYXl9IGl0ZW1zIC0gZXhwcmVzc2lvbiBjb2xsZWN0aW9uIHZhbHVlXG4gKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBzY29wZVxuICogQHBhcmFtICAgeyp9IHBhcmVudFNjb3BlIC0gc2NvcGUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtICAge0VhY2hCaW5kaW5nfSBiaW5kaW5nIC0gZWFjaCBiaW5kaW5nIG9iamVjdCBpbnN0YW5jZVxuICogQHJldHVybnMge29iamVjdH0gZGF0YSAtIEFuIG9iamVjdCBjb250YWluaW5nOlxuICogQHByb3BlcnR5IHtNYXB9IG5ld0NoaWxkcmVuTWFwIC0gYSBNYXAgY29udGFpbmluZyB0aGUgbmV3IGNoaWxkcmVuIHRlbXBsYXRlIHN0cnVjdHVyZVxuICogQHByb3BlcnR5IHtBcnJheX0gYmF0Y2hlcyAtIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIGxpZmVjeWNsZSBmdW5jdGlvbnMgdG8gdHJpZ2dlclxuICogQHByb3BlcnR5IHtBcnJheX0gZnV0dXJlTm9kZXMgLSBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyB3ZSBuZWVkIHRvIGRpZmZcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGF0Y2goaXRlbXMsIHNjb3BlLCBwYXJlbnRTY29wZSwgYmluZGluZykge1xuICBjb25zdCB7XG4gICAgY29uZGl0aW9uLFxuICAgIHRlbXBsYXRlLFxuICAgIGNoaWxkcmVuTWFwLFxuICAgIGl0ZW1OYW1lLFxuICAgIGdldEtleSxcbiAgICBpbmRleE5hbWUsXG4gICAgcm9vdCxcbiAgICBpc1RlbXBsYXRlVGFnLFxuICB9ID0gYmluZGluZztcbiAgY29uc3QgbmV3Q2hpbGRyZW5NYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGJhdGNoZXMgPSBbXTtcbiAgY29uc3QgZnV0dXJlTm9kZXMgPSBbXTtcblxuICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBleHRlbmRTY29wZShPYmplY3QuY3JlYXRlKHNjb3BlKSwge1xuICAgICAgaXRlbU5hbWUsXG4gICAgICBpbmRleE5hbWUsXG4gICAgICBpbmRleCxcbiAgICAgIGl0ZW0sXG4gICAgfSk7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5ID8gZ2V0S2V5KGNvbnRleHQpIDogaW5kZXg7XG4gICAgY29uc3Qgb2xkSXRlbSA9IGNoaWxkcmVuTWFwLmdldChrZXkpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICBpZiAobXVzdEZpbHRlckl0ZW0oY29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbXVzdE1vdW50ID0gIW9sZEl0ZW07XG4gICAgY29uc3QgY29tcG9uZW50VGVtcGxhdGUgPSBvbGRJdGVtID8gb2xkSXRlbS50ZW1wbGF0ZSA6IHRlbXBsYXRlLmNsb25lKCk7XG4gICAgY29uc3QgZWwgPSBjb21wb25lbnRUZW1wbGF0ZS5lbCB8fCByb290LmNsb25lTm9kZSgpO1xuICAgIGNvbnN0IG1ldGEgPVxuICAgICAgaXNUZW1wbGF0ZVRhZyAmJiBtdXN0TW91bnRcbiAgICAgICAgPyBjcmVhdGVUZW1wbGF0ZU1ldGEoY29tcG9uZW50VGVtcGxhdGUpXG4gICAgICAgIDogY29tcG9uZW50VGVtcGxhdGUubWV0YTtcblxuICAgIGlmIChtdXN0TW91bnQpIHtcbiAgICAgIGJhdGNoZXMucHVzaCgoKSA9PlxuICAgICAgICBjb21wb25lbnRUZW1wbGF0ZS5tb3VudChlbCwgY29udGV4dCwgcGFyZW50U2NvcGUsIG1ldGEpLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmF0Y2hlcy5wdXNoKCgpID0+IGNvbXBvbmVudFRlbXBsYXRlLnVwZGF0ZShjb250ZXh0LCBwYXJlbnRTY29wZSkpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgY29sbGVjdGlvbiBvZiBub2RlcyB0byB1cGRhdGUgb3IgdG8gYWRkXG4gICAgLy8gaW4gY2FzZSBvZiB0ZW1wbGF0ZSB0YWdzIHdlIG5lZWQgdG8gYWRkIGFsbCBpdHMgY2hpbGRyZW4gbm9kZXNcbiAgICBpZiAoaXNUZW1wbGF0ZVRhZykge1xuICAgICAgbm9kZXMucHVzaCguLi5tZXRhLmNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucHVzaChlbCk7XG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIHRoZSBvbGQgaXRlbSBmcm9tIHRoZSBjaGlsZHJlbiBtYXBcbiAgICBjaGlsZHJlbk1hcC5kZWxldGUoa2V5KTtcbiAgICBmdXR1cmVOb2Rlcy5wdXNoKC4uLm5vZGVzKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgY2hpbGRyZW4gbWFwXG4gICAgbmV3Q2hpbGRyZW5NYXAuc2V0KGtleSwge1xuICAgICAgbm9kZXMsXG4gICAgICB0ZW1wbGF0ZTogY29tcG9uZW50VGVtcGxhdGUsXG4gICAgICBjb250ZXh0LFxuICAgICAgaW5kZXgsXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbmV3Q2hpbGRyZW5NYXAsXG4gICAgYmF0Y2hlcyxcbiAgICBmdXR1cmVOb2RlcyxcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUkNihcbiAgbm9kZSxcbiAgeyBldmFsdWF0ZSwgY29uZGl0aW9uLCBpdGVtTmFtZSwgaW5kZXhOYW1lLCBnZXRLZXksIHRlbXBsYXRlIH0sXG4pIHtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIGNvbnN0IHJvb3QgPSBub2RlLmNsb25lTm9kZSgpO1xuXG4gIGluc2VydEJlZm9yZShwbGFjZWhvbGRlciwgbm9kZSk7XG4gIHJlbW92ZUNoaWxkKG5vZGUpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uRWFjaEJpbmRpbmcsXG4gICAgY2hpbGRyZW5NYXA6IG5ldyBNYXAoKSxcbiAgICBub2RlLFxuICAgIHJvb3QsXG4gICAgY29uZGl0aW9uLFxuICAgIGV2YWx1YXRlLFxuICAgIGlzVGVtcGxhdGVUYWc6IGlzVGVtcGxhdGUocm9vdCksXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLmNyZWF0ZURPTShub2RlKSxcbiAgICBnZXRLZXksXG4gICAgaW5kZXhOYW1lLFxuICAgIGl0ZW1OYW1lLFxuICAgIHBsYWNlaG9sZGVyLFxuICB9XG59XG5cbi8qKlxuICogQmluZGluZyByZXNwb25zaWJsZSBmb3IgdGhlIGBpZmAgZGlyZWN0aXZlXG4gKi9cbmNvbnN0IElmQmluZGluZyA9IHtcbiAgLy8gZHluYW1pYyBiaW5kaW5nIHByb3BlcnRpZXNcbiAgLy8gbm9kZTogbnVsbCxcbiAgLy8gZXZhbHVhdGU6IG51bGwsXG4gIC8vIGlzVGVtcGxhdGVUYWc6IGZhbHNlLFxuICAvLyBwbGFjZWhvbGRlcjogbnVsbCxcbiAgLy8gdGVtcGxhdGU6IG51bGwsXG5cbiAgLy8gQVBJIG1ldGhvZHNcbiAgbW91bnQoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSlcbiAgfSxcbiAgdXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIGNvbnN0IHZhbHVlID0gISF0aGlzLmV2YWx1YXRlKHNjb3BlKTtcbiAgICBjb25zdCBtdXN0TW91bnQgPSAhdGhpcy52YWx1ZSAmJiB2YWx1ZTtcbiAgICBjb25zdCBtdXN0VW5tb3VudCA9IHRoaXMudmFsdWUgJiYgIXZhbHVlO1xuICAgIGNvbnN0IG1vdW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJpc3RpbmUgPSB0aGlzLm5vZGUuY2xvbmVOb2RlKCk7XG5cbiAgICAgIGluc2VydEJlZm9yZShwcmlzdGluZSwgdGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5jbG9uZSgpO1xuICAgICAgdGhpcy50ZW1wbGF0ZS5tb3VudChwcmlzdGluZSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICB9O1xuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIG11c3RNb3VudDpcbiAgICAgICAgbW91bnQoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgbXVzdFVubW91bnQ6XG4gICAgICAgIHRoaXMudW5tb3VudChzY29wZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWUpIHRoaXMudGVtcGxhdGUudXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICB0aGlzLnRlbXBsYXRlLnVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCB0cnVlKTtcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGUkNShub2RlLCB7IGV2YWx1YXRlLCB0ZW1wbGF0ZSB9KSB7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXG4gIGluc2VydEJlZm9yZShwbGFjZWhvbGRlciwgbm9kZSk7XG4gIHJlbW92ZUNoaWxkKG5vZGUpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uSWZCaW5kaW5nLFxuICAgIG5vZGUsXG4gICAgZXZhbHVhdGUsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLmNyZWF0ZURPTShub2RlKSxcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIFJFRiBhdHRyaWJ1dGUgZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGV4cHJlc3Npb24gLSBleHByZXNzaW9uIGRhdGFcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZXhwcmVzc2lvbi5ub2RlIC0gdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSAgIHsqfSBleHByZXNzaW9uLnZhbHVlIC0gdGhlIG9sZCBleHByZXNzaW9uIGNhY2hlZCB2YWx1ZVxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gbmV3IGV4cHJlc3Npb24gdmFsdWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlZkV4cHJlc3Npb24oeyBub2RlLCB2YWx1ZTogb2xkVmFsdWUgfSwgdmFsdWUpIHtcbiAgLy8gY2FsbGVkIG9uIG1vdW50IGFuZCB1cGRhdGVcbiAgaWYgKHZhbHVlKSB2YWx1ZShub2RlKTtcbiAgLy8gY2FsbGVkIG9uIHVubW91bnRcbiAgLy8gaW4gdGhpcyBjYXNlIHRoZSBub2RlIHZhbHVlIGlzIG51bGxcbiAgZWxzZSBvbGRWYWx1ZShudWxsKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHVzZXIgdmFsdWUgaW4gb3JkZXIgdG8gcmVuZGVyIGEgZW1wdHkgc3RyaW5nIGluIGNhc2Ugb2YgZmFsc3kgdmFsdWVzXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB1c2VyIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBob3BlZnVsbHkgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTmlsKHZhbHVlKSA/ICcnIDogdmFsdWVcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgaGFuZGxlcyB0aGUgaW5wdXQgZmllbGRzIHZhbHVlIHVwZGF0ZXNcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGV4cHJlc3Npb24gLSBleHByZXNzaW9uIGRhdGFcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZXhwcmVzc2lvbi5ub2RlIC0gdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB2YWx1ZUV4cHJlc3Npb24oeyBub2RlIH0sIHZhbHVlKSB7XG4gIG5vZGUudmFsdWUgPSBub3JtYWxpemVTdHJpbmdWYWx1ZSh2YWx1ZSk7XG59XG5cbmNvbnN0IFJFX0VWRU5UU19QUkVGSVggPSAvXm9uLztcblxuY29uc3QgZ2V0Q2FsbGJhY2tBbmRPcHRpb25zID0gKHZhbHVlKSA9PlxuICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlLCBmYWxzZV07XG5cbi8vIHNlZSBhbHNvIGh0dHBzOi8vbWVkaXVtLmNvbS9AV2ViUmVmbGVjdGlvbi9kb20taGFuZGxlZXZlbnQtYS1jcm9zcy1wbGF0Zm9ybS1zdGFuZGFyZC1zaW5jZS15ZWFyLTIwMDAtNWJmMTcyODdmZDM4XG5jb25zdCBFdmVudExpc3RlbmVyID0ge1xuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIHRoaXNbZXZlbnQudHlwZV0oZXZlbnQpO1xuICB9LFxufTtcbmNvbnN0IExpc3RlbmVyc1dlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBjcmVhdGVMaXN0ZW5lciA9IChub2RlKSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gT2JqZWN0LmNyZWF0ZShFdmVudExpc3RlbmVyKTtcbiAgTGlzdGVuZXJzV2Vha01hcC5zZXQobm9kZSwgbGlzdGVuZXIpO1xuICByZXR1cm4gbGlzdGVuZXJcbn07XG5cbi8qKlxuICogU2V0IGEgbmV3IGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0gICB7b2JqZWN0fSAgZXhwcmVzc2lvbiAtIGV2ZW50IGV4cHJlc3Npb24gZGF0YVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBleHByZXNzaW9uLm5vZGUgLSB0YXJnZXQgbm9kZVxuICogQHBhcmFtICAge3N0cmluZ30gZXhwcmVzc2lvbi5uYW1lIC0gZXZlbnQgbmFtZVxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gbmV3IGV4cHJlc3Npb24gdmFsdWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGV2ZW50RXhwcmVzc2lvbih7IG5vZGUsIG5hbWUgfSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEV2ZW50TmFtZSA9IG5hbWUucmVwbGFjZShSRV9FVkVOVFNfUFJFRklYLCAnJyk7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSBMaXN0ZW5lcnNXZWFrTWFwLmdldChub2RlKSB8fCBjcmVhdGVMaXN0ZW5lcihub2RlKTtcbiAgY29uc3QgW2NhbGxiYWNrLCBvcHRpb25zXSA9IGdldENhbGxiYWNrQW5kT3B0aW9ucyh2YWx1ZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSBldmVudExpc3RlbmVyW25vcm1hbGl6ZWRFdmVudE5hbWVdO1xuICBjb25zdCBtdXN0UmVtb3ZlRXZlbnQgPSBoYW5kbGVyICYmICFjYWxsYmFjaztcbiAgY29uc3QgbXVzdEFkZEV2ZW50ID0gY2FsbGJhY2sgJiYgIWhhbmRsZXI7XG5cbiAgaWYgKG11c3RSZW1vdmVFdmVudCkge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihub3JtYWxpemVkRXZlbnROYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIGlmIChtdXN0QWRkRXZlbnQpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIobm9ybWFsaXplZEV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cblxuICBldmVudExpc3RlbmVyW25vcm1hbGl6ZWRFdmVudE5hbWVdID0gY2FsbGJhY2s7XG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCBFbGVtZW50UHJvdG8gPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IEVsZW1lbnQucHJvdG90eXBlO1xuY29uc3QgaXNOYXRpdmVIdG1sUHJvcGVydHkgPSBtZW1vaXplKFxuICAobmFtZSkgPT4gRWxlbWVudFByb3RvLmhhc093blByb3BlcnR5KG5hbWUpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4pO1xuXG4vKipcbiAqIEFkZCBhbGwgdGhlIGF0dHJpYnV0ZXMgcHJvdmlkZWRcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGF0dHJpYnV0ZXMgbmFtZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtICAgeyp9IG9sZEF0dHJpYnV0ZXMgLSB0aGUgb2xkIGV4cHJlc3Npb24gY2FjaGVkIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBzb3JyeSBpdCdzIGEgdm9pZCBmdW5jdGlvbiA6KFxuICovXG5mdW5jdGlvbiBzZXRBbGxBdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMsIG9sZEF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAvLyBmaWx0ZXIgb3V0IHRoZSBhdHRyaWJ1dGVzIHRoYXQgZGlkbid0IGNoYW5nZSB0aGVpciB2YWx1ZVxuICAgIC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHZhbHVlICE9PSBvbGRBdHRyaWJ1dGVzPy5bbmFtZV0pXG4gICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIG5hbWUgPT09IFJFRl9BVFRSSUJVVEU6XG4gICAgICAgICAgcmV0dXJuIHJlZkV4cHJlc3Npb24oeyBub2RlIH0sIHZhbHVlKVxuICAgICAgICBjYXNlIG5hbWUgPT09IFZBTFVFX0FUVFJJQlVURTpcbiAgICAgICAgICByZXR1cm4gdmFsdWVFeHByZXNzaW9uKHsgbm9kZSB9LCB2YWx1ZSlcbiAgICAgICAgY2FzZSBpc0V2ZW50QXR0cmlidXRlKG5hbWUpOlxuICAgICAgICAgIHJldHVybiBldmVudEV4cHJlc3Npb24oeyBub2RlLCBuYW1lIH0sIHZhbHVlKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVFeHByZXNzaW9uKHsgbm9kZSwgbmFtZSB9LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSBhdHRyaWJ1dGVzIHByb3ZpZGVkXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSB0YXJnZXQgbm9kZVxuICogQHBhcmFtICAge29iamVjdH0gbmV3QXR0cmlidXRlcyAtIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmV3IGF0dHJpYnV0ZSBuYW1lc1xuICogQHBhcmFtICAge29iamVjdH0gb2xkQXR0cmlidXRlcyAtIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgb2xkIGF0dHJpYnV0ZSBuYW1lc1xuICogQHJldHVybnMge3VuZGVmaW5lZH0gc29ycnkgaXQncyBhIHZvaWQgZnVuY3Rpb24gOihcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQWxsQXR0cmlidXRlcyhub2RlLCBuZXdBdHRyaWJ1dGVzLCBvbGRBdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IG5ld0tleXMgPSBuZXdBdHRyaWJ1dGVzID8gT2JqZWN0LmtleXMobmV3QXR0cmlidXRlcykgOiBbXTtcblxuICBPYmplY3QuZW50cmllcyhvbGRBdHRyaWJ1dGVzKVxuICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4gIW5ld0tleXMuaW5jbHVkZXMobmFtZSkpXG4gICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIG5hbWUgPT09IFJFRl9BVFRSSUJVVEU6XG4gICAgICAgICAgcmV0dXJuIHJlZkV4cHJlc3Npb24oeyBub2RlLCB2YWx1ZSB9KVxuICAgICAgICBjYXNlIG5hbWUgPT09IFZBTFVFX0FUVFJJQlVURTpcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGNhc2UgaXNFdmVudEF0dHJpYnV0ZShuYW1lKTpcbiAgICAgICAgICByZXR1cm4gZXZlbnRFeHByZXNzaW9uKHsgbm9kZSwgbmFtZSB9LCBudWxsKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKVxuICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBjYW4gYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBjYW4gcmVuZGVyIHRoaXMgYXR0cmlidXRlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNhblJlbmRlckF0dHJpYnV0ZSh2YWx1ZSkge1xuICByZXR1cm4gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpXG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSByZW1vdmVkXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gZXhwcmVzc2lvbiB2YWx1ZVxuICogQHBhcmFtICAge2Jvb2xlYW59IGlzQm9vbGVhbiAtIGZsYWcgdG8gaGFuZGxlIGJvb2xlYW4gYXR0cmlidXRlc1xuICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW4gLSB0cnVlIGlmIHRoZSBhdHRyaWJ1dGUgY2FuIGJlIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHZhbHVlLCBpc0Jvb2xlYW4pIHtcbiAgLy8gYm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSByZW1vdmVkIGlmIHRoZSB2YWx1ZSBpcyBmYWxzeVxuICBpZiAoaXNCb29sZWFuKSByZXR1cm4gIXZhbHVlXG5cbiAgLy8gbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGFzIHdlbGxcbiAgcmV0dXJuIGlzTmlsKHZhbHVlKVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kcyBoYW5kbGVzIHRoZSBET00gYXR0cmlidXRlcyB1cGRhdGVzXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBleHByZXNzaW9uIC0gYXR0cmlidXRlIGV4cHJlc3Npb24gZGF0YVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBleHByZXNzaW9uLm5vZGUgLSB0YXJnZXQgbm9kZVxuICogQHBhcmFtICAge3N0cmluZ30gZXhwcmVzc2lvbi5uYW1lIC0gYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSAgIHtib29sZWFufSBleHByZXNzaW9uLmlzQm9vbGVhbiAtIGZsYWcgdG8gaGFuZGxlIGJvb2xlYW4gYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyp9IGV4cHJlc3Npb24udmFsdWUgLSB0aGUgb2xkIGV4cHJlc3Npb24gY2FjaGVkIHZhbHVlXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSBuZXcgZXhwcmVzc2lvbiB2YWx1ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYXR0cmlidXRlRXhwcmVzc2lvbihcbiAgeyBub2RlLCBuYW1lLCBpc0Jvb2xlYW46IGlzQm9vbGVhbiQxLCB2YWx1ZTogb2xkVmFsdWUgfSxcbiAgdmFsdWUsXG4pIHtcbiAgLy8gaXMgaXQgYSBzcHJlYWQgb3BlcmF0b3I/IHsuLi5hdHRyaWJ1dGVzfVxuICBpZiAoIW5hbWUpIHtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdGhlIG9sZCBhdHRyaWJ1dGVzXG4gICAgICByZW1vdmVBbGxBdHRyaWJ1dGVzKG5vZGUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gaXMgdGhlIHZhbHVlIHN0aWxsIHRydXRoeT9cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHNldEFsbEF0dHJpYnV0ZXMobm9kZSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0b3JlIHRoZSBhdHRyaWJ1dGUgb24gdGhlIG5vZGUgdG8gbWFrZSBpdCBjb21wYXRpYmxlIHdpdGggbmF0aXZlIGN1c3RvbSBlbGVtZW50c1xuICBpZiAoXG4gICAgIWlzTmF0aXZlSHRtbFByb3BlcnR5KG5hbWUpICYmXG4gICAgKGlzQm9vbGVhbih2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpKVxuICApIHtcbiAgICBub2RlW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHZhbHVlLCBpc0Jvb2xlYW4kMSkpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIGlmIChjYW5SZW5kZXJBdHRyaWJ1dGUodmFsdWUpKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbm9ybWFsaXplVmFsdWUobmFtZSwgdmFsdWUsIGlzQm9vbGVhbiQxKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGFzIHN0cmluZ1xuICogQHBhcmFtICAge3N0cmluZ30gbmFtZSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB1c2VyIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gICB7Ym9vbGVhbn0gaXNCb29sZWFuIC0gYm9vbGVhbiBhdHRyaWJ1dGVzIGZsYWdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGlucHV0IHZhbHVlIGFzIHN0cmluZ1xuICovXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNCb29sZWFuKSB7XG4gIC8vIGJlIHN1cmUgdGhhdCBleHByZXNzaW9ucyBsaWtlIHNlbGVjdGVkPXsgdHJ1ZSB9IHdpbGwgYWx3YXlzIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkPSdzZWxlY3RlZCdcbiAgLy8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI5NzVcbiAgcmV0dXJuICEhdmFsdWUgJiYgaXNCb29sZWFuID8gbmFtZSA6IHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSB0aGUgdGFyZ2V0IHRleHQgbm9kZSB0byB1cGRhdGUgb3IgY3JlYXRlIG9uZSBmcm9tIG9mIGEgY29tbWVudCBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSBhbnkgaHRtbCBlbGVtZW50IGNvbnRhaW5pbmcgY2hpbGROb2Rlc1xuICogQHBhcmFtICAge251bWJlcn0gY2hpbGROb2RlSW5kZXggLSBpbmRleCBvZiB0aGUgdGV4dCBub2RlIGluIHRoZSBjaGlsZE5vZGVzIGxpc3RcbiAqIEByZXR1cm5zIHtUZXh0fSB0aGUgdGV4dCBub2RlIHRvIHVwZGF0ZVxuICovXG5jb25zdCBnZXRUZXh0Tm9kZSA9IChub2RlLCBjaGlsZE5vZGVJbmRleCkgPT4ge1xuICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW2NoaWxkTm9kZUluZGV4XVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgaGFuZGxlcyBhIHNpbXBsZSB0ZXh0IGV4cHJlc3Npb24gdXBkYXRlXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBkYXRhXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGV4cHJlc3Npb24ubm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSBuZXcgZXhwcmVzc2lvbiB2YWx1ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdGV4dEV4cHJlc3Npb24oeyBub2RlIH0sIHZhbHVlKSB7XG4gIG5vZGUuZGF0YSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbn1cblxuY29uc3QgZXhwcmVzc2lvbnMgPSB7XG4gIFtBVFRSSUJVVEVdOiBhdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBbRVZFTlRdOiBldmVudEV4cHJlc3Npb24sXG4gIFtURVhUXTogdGV4dEV4cHJlc3Npb24sXG4gIFtWQUxVRV06IHZhbHVlRXhwcmVzc2lvbixcbiAgW1JFRl06IHJlZkV4cHJlc3Npb24sXG59O1xuXG5jb25zdCBFeHByZXNzaW9uID0ge1xuICAvLyBTdGF0aWMgcHJvcHNcbiAgLy8gbm9kZTogbnVsbCxcbiAgLy8gdmFsdWU6IG51bGwsXG5cbiAgLy8gQVBJIG1ldGhvZHNcbiAgLyoqXG4gICAqIE1vdW50IHRoZSBleHByZXNzaW9uIGV2YWx1YXRpbmcgaXRzIGluaXRpYWwgdmFsdWVcbiAgICogQHBhcmFtICAgeyp9IHNjb3BlIC0gYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBleHByZXNzaW9uIHRvIGV2YWx1YXRlIGl0cyBjdXJyZW50IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gc2VsZlxuICAgKi9cbiAgbW91bnQoc2NvcGUpIHtcbiAgICAvLyBob3BlZnVsbHkgYSBwdXJlIGZ1bmN0aW9uXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKHNjb3BlKTtcblxuICAgIC8vIElPKCkgRE9NIHVwZGF0ZXNcbiAgICBleHByZXNzaW9uc1t0aGlzLnR5cGVdKHRoaXMsIHZhbHVlKTtcblxuICAgIC8vIHN0b3JlIHRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIHVwZGF0ZSBjYWxsc1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGV4cHJlc3Npb24gaWYgaXRzIHZhbHVlIGNoYW5nZWRcbiAgICogQHBhcmFtICAgeyp9IHNjb3BlIC0gYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBleHByZXNzaW9uIHRvIGV2YWx1YXRlIGl0cyBjdXJyZW50IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gc2VsZlxuICAgKi9cbiAgdXBkYXRlKHNjb3BlKSB7XG4gICAgLy8gcHVyZSBmdW5jdGlvblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ldmFsdWF0ZShzY29wZSk7XG5cbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIC8vIElPKCkgRE9NIHVwZGF0ZXNcbiAgICAgIGV4cHJlc3Npb25zW3RoaXMudHlwZV0odGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8qKlxuICAgKiBFeHByZXNzaW9uIHRlYXJkb3duIG1ldGhvZFxuICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gc2VsZlxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICAvLyB1bm1vdW50IGV2ZW50IGFuZCByZWYgZXhwcmVzc2lvbnNcbiAgICBpZiAoXG4gICAgICBbRVZFTlQsIFJFRl0uaW5jbHVkZXModGhpcy50eXBlKSB8fFxuICAgICAgLy8gc3ByZWFkIGF0dHJpYnV0ZXMgbWlnaHQgY29udGFpbiBldmVudHMgb3IgcmVmcyB0aGF0IG11c3QgYmUgdW5tb3VudGVkXG4gICAgICAodGhpcy50eXBlID09PSBBVFRSSUJVVEUgJiYgIXRoaXMubmFtZSlcbiAgICApXG4gICAgICBleHByZXNzaW9uc1t0aGlzLnR5cGVdKHRoaXMsIG51bGwpO1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZSQ0KG5vZGUsIGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5FeHByZXNzaW9uLFxuICAgIC4uLmRhdGEsXG4gICAgbm9kZTogZGF0YS50eXBlID09PSBURVhUID8gZ2V0VGV4dE5vZGUobm9kZSwgZGF0YS5jaGlsZE5vZGVJbmRleCkgOiBub2RlLFxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZmxhdCBvYmplY3QgaGF2aW5nIGFzIGtleXMgYSBsaXN0IG9mIG1ldGhvZHMgdGhhdCBpZiBkaXNwYXRjaGVkIHdpbGwgcHJvcGFnYXRlXG4gKiBvbiB0aGUgd2hvbGUgY29sbGVjdGlvblxuICogQHBhcmFtICAge0FycmF5fSBjb2xsZWN0aW9uIC0gY29sbGVjdGlvbiB0byBpdGVyYXRlXG4gKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gbWV0aG9kcyAtIG1ldGhvZHMgdG8gZXhlY3V0ZSBvbiBlYWNoIGl0ZW0gb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAgIHsqfSBjb250ZXh0IC0gY29udGV4dCByZXR1cm5lZCBieSB0aGUgbmV3IG1ldGhvZHMgY3JlYXRlZFxuICogQHJldHVybnMge29iamVjdH0gYSBuZXcgb2JqZWN0IHRvIHNpbXBsaWZ5IHRoZSB0aGUgbmVzdGVkIG1ldGhvZHMgZGlzcGF0Y2hpbmdcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNvbGxlY3Rpb25NZXRob2RzKGNvbGxlY3Rpb24sIG1ldGhvZHMsIGNvbnRleHQpIHtcbiAgcmV0dXJuIG1ldGhvZHMucmVkdWNlKChhY2MsIG1ldGhvZCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbbWV0aG9kXTogKHNjb3BlKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLm1hcCgoaXRlbSkgPT4gaXRlbVttZXRob2RdKHNjb3BlKSkgJiYgY29udGV4dFxuICAgICAgfSxcbiAgICB9XG4gIH0sIHt9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGUkMyhub2RlLCB7IGV4cHJlc3Npb25zIH0pIHtcbiAgcmV0dXJuIGZsYXR0ZW5Db2xsZWN0aW9uTWV0aG9kcyhcbiAgICBleHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24pID0+IGNyZWF0ZSQ0KG5vZGUsIGV4cHJlc3Npb24pKSxcbiAgICBbJ21vdW50JywgJ3VwZGF0ZScsICd1bm1vdW50J10sXG4gIClcbn1cblxuY29uc3QgZXh0ZW5kUGFyZW50U2NvcGUgPSAoYXR0cmlidXRlcywgc2NvcGUsIHBhcmVudFNjb3BlKSA9PiB7XG4gIGlmICghYXR0cmlidXRlcyB8fCAhYXR0cmlidXRlcy5sZW5ndGgpIHJldHVybiBwYXJlbnRTY29wZVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUgfHwgbnVsbCksXG4gICAgZ2VuZXJhdGVQcm9wc0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIHNjb3BlKSxcbiAgKVxufTtcblxuY29uc3QgZmluZFNsb3RCeUlkID0gKGlkLCBzbG90cykgPT4gc2xvdHM/LmZpbmQoKHNsb3QpID0+IHNsb3QuaWQgPT09IGlkKTtcblxuLy8gdGhpcyBmdW5jdGlvbiBpcyBvbmx5IG1lYW50IHRvIGZpeCBhbiBlZGdlIGNhc2Vcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI4NDJcbmNvbnN0IGdldFJlYWxQYXJlbnQgPSAoc2NvcGUsIHBhcmVudFNjb3BlKSA9PlxuICBzY29wZVtQQVJFTlRfS0VZX1NZTUJPTF0gfHwgcGFyZW50U2NvcGU7XG5cbmNvbnN0IFNsb3RCaW5kaW5nID0ge1xuICAvLyBkeW5hbWljIGJpbmRpbmcgcHJvcGVydGllc1xuICAvLyBub2RlOiBudWxsLFxuICAvLyBuYW1lOiBudWxsLFxuICBhdHRyaWJ1dGVzOiBbXSxcbiAgLy8gdGVtcGxhdGVEYXRhOiBudWxsLFxuICAvLyB0ZW1wbGF0ZTogbnVsbCxcblxuICBnZXRUZW1wbGF0ZVNjb3BlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIHJldHVybiBleHRlbmRQYXJlbnRTY29wZSh0aGlzLmF0dHJpYnV0ZXMsIHNjb3BlLCBwYXJlbnRTY29wZSlcbiAgfSxcblxuICAvLyBBUEkgbWV0aG9kc1xuICBtb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZURhdGEgPSBzY29wZS5zbG90c1xuICAgICAgPyBmaW5kU2xvdEJ5SWQodGhpcy5uYW1lLCBzY29wZS5zbG90cylcbiAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSB0aGlzLm5vZGU7XG5cbiAgICAvLyBpZiB0aGUgc2xvdCBkaWQgbm90IHBhc3MgYW55IGNvbnRlbnQsIHdlIHdpbGwgdXNlIHRoZSBzZWxmIHNsb3QgZm9yIG9wdGlvbmFsIGZhbGxiYWNrIGNvbnRlbnQgKGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzMwMjQpXG4gICAgY29uc3QgcmVhbFBhcmVudCA9IHRlbXBsYXRlRGF0YSA/IGdldFJlYWxQYXJlbnQoc2NvcGUsIHBhcmVudFNjb3BlKSA6IHNjb3BlO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gaHRtbCBmb3IgdGhlIGN1cnJlbnQgc2xvdCBkZXRlY3RlZCB3ZSByZWx5IG9uIHRoZSBwYXJlbnQgc2xvdHMgKGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzMwNTUpXG4gICAgdGhpcy50ZW1wbGF0ZURhdGEgPSB0ZW1wbGF0ZURhdGE/Lmh0bWxcbiAgICAgID8gdGVtcGxhdGVEYXRhXG4gICAgICA6IGZpbmRTbG90QnlJZCh0aGlzLm5hbWUsIHJlYWxQYXJlbnQuc2xvdHMpO1xuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIHRlbXBsYXRlIHByb3BlcnR5IGlmIHRoZSBzbG90IG5lZWRzIHRvIGJlIHJlcGxhY2VkXG4gICAgdGhpcy50ZW1wbGF0ZSA9XG4gICAgICAodGhpcy50ZW1wbGF0ZURhdGEgJiZcbiAgICAgICAgY3JlYXRlKHRoaXMudGVtcGxhdGVEYXRhLmh0bWwsIHRoaXMudGVtcGxhdGVEYXRhLmJpbmRpbmdzKS5jcmVhdGVET00oXG4gICAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgKSkgfHxcbiAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIG9wdGlvbmFsIHRlbXBsYXRlIGZhbGxiYWNrIGlmIHByb3ZpZGVkIGJ5IHRoZSBjb21waWxlciBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcmlvdC9yaW90L2lzc3Vlcy8zMDE0XG4gICAgICB0aGlzLnRlbXBsYXRlPy5jbG9uZSgpO1xuXG4gICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgIGNsZWFuTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy50ZW1wbGF0ZS5tb3VudChcbiAgICAgICAgdGhpcy5ub2RlLFxuICAgICAgICB0aGlzLmdldFRlbXBsYXRlU2NvcGUoc2NvcGUsIHJlYWxQYXJlbnQpLFxuICAgICAgICByZWFsUGFyZW50LFxuICAgICAgKTtcbiAgICAgIHRoaXMudGVtcGxhdGUuY2hpbGRyZW4gPSBBcnJheS5mcm9tKHRoaXMubm9kZS5jaGlsZE5vZGVzKTtcbiAgICB9XG5cbiAgICBtb3ZlU2xvdElubmVyQ29udGVudCh0aGlzLm5vZGUpO1xuICAgIHJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgIGNvbnN0IHJlYWxQYXJlbnQgPSB0aGlzLnRlbXBsYXRlRGF0YVxuICAgICAgICA/IGdldFJlYWxQYXJlbnQoc2NvcGUsIHBhcmVudFNjb3BlKVxuICAgICAgICA6IHNjb3BlO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnVwZGF0ZSh0aGlzLmdldFRlbXBsYXRlU2NvcGUoc2NvcGUsIHJlYWxQYXJlbnQpLCByZWFsUGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwgbXVzdFJlbW92ZVJvb3QpIHtcbiAgICBpZiAodGhpcy50ZW1wbGF0ZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS51bm1vdW50KFxuICAgICAgICB0aGlzLmdldFRlbXBsYXRlU2NvcGUoc2NvcGUsIHBhcmVudFNjb3BlKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbXVzdFJlbW92ZVJvb3QsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlIHNsb3RzIG91dHNpZGUgb2YgdGhlbVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBzbG90IC0gc2xvdCBub2RlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBpdCdzIGEgdm9pZCBtZXRob2Qgwq9cXF8o44OEKV8vwq9cbiAqL1xuZnVuY3Rpb24gbW92ZVNsb3RJbm5lckNvbnRlbnQoc2xvdCkge1xuICBjb25zdCBjaGlsZCA9IHNsb3QgJiYgc2xvdC5maXJzdENoaWxkO1xuXG4gIGlmICghY2hpbGQpIHJldHVyblxuXG4gIGluc2VydEJlZm9yZShjaGlsZCwgc2xvdCk7XG4gIG1vdmVTbG90SW5uZXJDb250ZW50KHNsb3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNpbmdsZSBzbG90IGJpbmRpbmdcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHNsb3Qgbm9kZVxuICogQHBhcmFtICAge29iamVjdH0gZGF0YSAtIHNsb3QgYmluZGluZyBkYXRhXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBkYXRhLm5hbWUgLSBzbG90IGlkXG4gKiBAcGFyYW0gICB7QXR0cmlidXRlRXhwcmVzc2lvbkRhdGFbXX0gZGF0YS5hdHRyaWJ1dGVzIC0gc2xvdCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7VGVtcGxhdGVDaHVua30gZGF0YS50ZW1wbGF0ZSAtIHNsb3QgZmFsbGJhY2sgdGVtcGxhdGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IFNsb3QgYmluZGluZyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2xvdChub2RlLCB7IG5hbWUsIGF0dHJpYnV0ZXMsIHRlbXBsYXRlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5TbG90QmluZGluZyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHRlbXBsYXRlLFxuICAgIG5vZGUsXG4gICAgbmFtZSxcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0YWcgb2JqZWN0IGlmIGl0IHdhcyByZWdpc3RlcmVkIGJlZm9yZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHRoZSBzaW1wbGVcbiAqIHRlbXBsYXRlIGNodW5rXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IGNvbXBvbmVudCAtIGNvbXBvbmVudCBmYWN0b3J5IGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7QXJyYXk8b2JqZWN0Pn0gc2xvdHMgLSBhcnJheSBjb250YWluaW5nIHRoZSBzbG90cyBtYXJrdXBcbiAqIEBwYXJhbSAgIHtBcnJheX0gYXR0cmlidXRlcyAtIGR5bmFtaWMgYXR0cmlidXRlcyB0aGF0IHdpbGwgYmUgcmVjZWl2ZWQgYnkgdGhlIHRhZyBlbGVtZW50XG4gKiBAcmV0dXJucyB7VGFnSW1wbGVtZW50YXRpb258VGVtcGxhdGVDaHVua30gYSB0YWcgaW1wbGVtZW50YXRpb24gb3IgYSB0ZW1wbGF0ZSBjaHVuayBhcyBmYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRUYWcoY29tcG9uZW50LCBzbG90cyA9IFtdLCBhdHRyaWJ1dGVzID0gW10pIHtcbiAgLy8gaWYgdGhpcyB0YWcgd2FzIHJlZ2lzdGVyZWQgYmVmb3JlIHdlIHdpbGwgcmV0dXJuIGl0cyBpbXBsZW1lbnRhdGlvblxuICBpZiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCh7IHNsb3RzLCBhdHRyaWJ1dGVzIH0pXG4gIH1cblxuICAvLyBvdGhlcndpc2Ugd2UgcmV0dXJuIGEgdGVtcGxhdGUgY2h1bmtcbiAgcmV0dXJuIGNyZWF0ZShzbG90c1RvTWFya3VwKHNsb3RzKSwgW1xuICAgIC4uLnNsb3RCaW5kaW5ncyhzbG90cyksXG4gICAge1xuICAgICAgLy8gdGhlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgYXMgYmluZGluZ1xuICAgICAgLy8gaWYgd2UgZmFsbGJhY2sgdG8gYSBub3JtYWwgdGVtcGxhdGUgY2h1bmtcbiAgICAgIGV4cHJlc3Npb25zOiBhdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAuLi5hdHRyLFxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICB9LFxuICBdKVxufVxuXG4vKipcbiAqIE1lcmdlIGFsbCB0aGUgc2xvdHMgYmluZGluZ3MgaW50byBhIHNpbmdsZSBhcnJheVxuICogQHBhcmFtICAge0FycmF5PG9iamVjdD59IHNsb3RzIC0gc2xvdHMgY29sbGVjdGlvblxuICogQHJldHVybnMge0FycmF5PEJpbmRpbmdzPn0gZmxhdHRlbiBiaW5kaW5ncyBhcnJheVxuICovXG5mdW5jdGlvbiBzbG90QmluZGluZ3Moc2xvdHMpIHtcbiAgcmV0dXJuIHNsb3RzLnJlZHVjZSgoYWNjLCB7IGJpbmRpbmdzIH0pID0+IGFjYy5jb25jYXQoYmluZGluZ3MpLCBbXSlcbn1cblxuLyoqXG4gKiBNZXJnZSBhbGwgdGhlIHNsb3RzIHRvZ2V0aGVyIGluIGEgc2luZ2xlIG1hcmt1cCBzdHJpbmdcbiAqIEBwYXJhbSAgIHtBcnJheTxvYmplY3Q+fSBzbG90cyAtIHNsb3RzIGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IG1hcmt1cCBvZiBhbGwgdGhlIHNsb3RzIGluIGEgc2luZ2xlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzbG90c1RvTWFya3VwKHNsb3RzKSB7XG4gIHJldHVybiBzbG90cy5yZWR1Y2UoKGFjYywgc2xvdCkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBzbG90Lmh0bWxcbiAgfSwgJycpXG59XG5cbmNvbnN0IFRhZ0JpbmRpbmcgPSB7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyBuYW1lOiBudWxsLFxuICAvLyBzbG90czogbnVsbCxcbiAgLy8gdGFnOiBudWxsLFxuICAvLyBhdHRyaWJ1dGVzOiBudWxsLFxuICAvLyBnZXRDb21wb25lbnQ6IG51bGwsXG5cbiAgbW91bnQoc2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUpXG4gIH0sXG4gIHVwZGF0ZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmFsdWF0ZShzY29wZSk7XG5cbiAgICAvLyBzaW1wbGUgdXBkYXRlXG4gICAgaWYgKG5hbWUgJiYgbmFtZSA9PT0gdGhpcy5uYW1lKSB7XG4gICAgICB0aGlzLnRhZy51cGRhdGUoc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bm1vdW50IHRoZSBvbGQgdGFnIGlmIGl0IGV4aXN0c1xuICAgICAgdGhpcy51bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwgdHJ1ZSk7XG5cbiAgICAgIC8vIG1vdW50IHRoZSBuZXcgdGFnXG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy50YWcgPSBnZXRUYWcodGhpcy5nZXRDb21wb25lbnQobmFtZSksIHRoaXMuc2xvdHMsIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLnRhZy5tb3VudCh0aGlzLm5vZGUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwga2VlcFJvb3RUYWcpIHtcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIC8vIGtlZXAgdGhlIHJvb3QgdGFnXG4gICAgICB0aGlzLnRhZy51bm1vdW50KGtlZXBSb290VGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlJDIoXG4gIG5vZGUsXG4gIHsgZXZhbHVhdGUsIGdldENvbXBvbmVudCwgc2xvdHMsIGF0dHJpYnV0ZXMgfSxcbikge1xuICByZXR1cm4ge1xuICAgIC4uLlRhZ0JpbmRpbmcsXG4gICAgbm9kZSxcbiAgICBldmFsdWF0ZSxcbiAgICBzbG90cyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGdldENvbXBvbmVudCxcbiAgfVxufVxuXG5jb25zdCBiaW5kaW5ncyA9IHtcbiAgW0lGXTogY3JlYXRlJDUsXG4gIFtTSU1QTEVdOiBjcmVhdGUkMyxcbiAgW0VBQ0hdOiBjcmVhdGUkNixcbiAgW1RBR106IGNyZWF0ZSQyLFxuICBbU0xPVF06IGNyZWF0ZVNsb3QsXG59O1xuXG4vKipcbiAqIFRleHQgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZSB0YWcgd2lsbCBnZXQgY2hpbGROb2RlSW5kZXggdmFsdWUgbm9ybWFsaXplZFxuICogZGVwZW5kaW5nIG9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgPHRlbXBsYXRlPiB0YWcgb2Zmc2V0XG4gKiBAcGFyYW0gICB7RXhwcmVzc2lvbltdfSBleHByZXNzaW9ucyAtIHJpb3QgZXhwcmVzc2lvbnMgYXJyYXlcbiAqIEBwYXJhbSAgIHtudW1iZXJ9IHRleHRFeHByZXNzaW9uc09mZnNldCAtIG9mZnNldCBvZiB0aGUgPHRlbXBsYXRlPiB0YWdcbiAqIEByZXR1cm5zIHtFeHByZXNzaW9uW119IGV4cHJlc3Npb25zIGNvbnRhaW5pbmcgdGhlIHRleHQgZXhwcmVzc2lvbnMgbm9ybWFsaXplZFxuICovXG5mdW5jdGlvbiBmaXhUZXh0RXhwcmVzc2lvbnNPZmZzZXQoZXhwcmVzc2lvbnMsIHRleHRFeHByZXNzaW9uc09mZnNldCkge1xuICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKChlKSA9PlxuICAgIGUudHlwZSA9PT0gVEVYVFxuICAgICAgPyB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICBjaGlsZE5vZGVJbmRleDogZS5jaGlsZE5vZGVJbmRleCArIHRleHRFeHByZXNzaW9uc09mZnNldCxcbiAgICAgICAgfVxuICAgICAgOiBlLFxuICApXG59XG5cbi8qKlxuICogQmluZCBhIG5ldyBleHByZXNzaW9uIG9iamVjdCB0byBhIERPTSBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IHJvb3QgLSBET00gbm9kZSB3aGVyZSB0byBiaW5kIHRoZSBleHByZXNzaW9uXG4gKiBAcGFyYW0gICB7VGFnQmluZGluZ0RhdGF9IGJpbmRpbmcgLSBiaW5kaW5nIGRhdGFcbiAqIEBwYXJhbSAgIHtudW1iZXJ8bnVsbH0gdGVtcGxhdGVUYWdPZmZzZXQgLSBpZiBpdCdzIGRlZmluZWQgd2UgbmVlZCB0byBmaXggdGhlIHRleHQgZXhwcmVzc2lvbnMgY2hpbGROb2RlSW5kZXggb2Zmc2V0XG4gKiBAcmV0dXJucyB7QmluZGluZ30gQmluZGluZyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlJDEocm9vdCwgYmluZGluZywgdGVtcGxhdGVUYWdPZmZzZXQpIHtcbiAgY29uc3QgeyBzZWxlY3RvciwgdHlwZSwgcmVkdW5kYW50QXR0cmlidXRlLCBleHByZXNzaW9ucyB9ID0gYmluZGluZztcbiAgLy8gZmluZCB0aGUgbm9kZSB0byBhcHBseSB0aGUgYmluZGluZ3NcbiAgY29uc3Qgbm9kZSA9IHNlbGVjdG9yID8gcm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IHJvb3Q7XG5cbiAgLy8gcmVtb3ZlIGV2ZW50dWFsbHkgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIGNyZWF0ZWQgb25seSB0byBzZWxlY3QgdGhpcyBub2RlXG4gIGlmIChyZWR1bmRhbnRBdHRyaWJ1dGUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKHJlZHVuZGFudEF0dHJpYnV0ZSk7XG4gIGNvbnN0IGJpbmRpbmdFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25zIHx8IFtdO1xuXG4gIC8vIGluaXQgdGhlIGJpbmRpbmdcbiAgcmV0dXJuIChiaW5kaW5nc1t0eXBlXSB8fCBiaW5kaW5nc1tTSU1QTEVdKShub2RlLCB7XG4gICAgLi4uYmluZGluZyxcbiAgICBleHByZXNzaW9uczpcbiAgICAgIHRlbXBsYXRlVGFnT2Zmc2V0ICYmICFzZWxlY3RvclxuICAgICAgICA/IGZpeFRleHRFeHByZXNzaW9uc09mZnNldChiaW5kaW5nRXhwcmVzc2lvbnMsIHRlbXBsYXRlVGFnT2Zmc2V0KVxuICAgICAgICA6IGJpbmRpbmdFeHByZXNzaW9ucyxcbiAgfSlcbn1cblxuLy8gaW4gdGhpcyBjYXNlIGEgc2ltcGxlIGlubmVySFRNTCBpcyBlbm91Z2hcbmZ1bmN0aW9uIGNyZWF0ZUhUTUxUcmVlKGh0bWwsIHJvb3QpIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBpc1RlbXBsYXRlKHJvb3QpID8gcm9vdCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG59XG5cbi8vIGZvciBzdmcgbm9kZXMgd2UgbmVlZCBhIGJpdCBtb3JlIHdvcmtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZnVuY3Rpb24gY3JlYXRlU1ZHVHJlZShodG1sLCBjb250YWluZXIpIHtcbiAgLy8gY3JlYXRlIHRoZSBTVkdOb2RlXG4gIGNvbnN0IHN2Z05vZGUgPSBjb250YWluZXIub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKFxuICAgIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFxuICAgICAgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPiR7aHRtbH08L3N2Zz5gLFxuICAgICAgJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgKS5kb2N1bWVudEVsZW1lbnQsXG4gICAgdHJ1ZSxcbiAgKTtcblxuICByZXR1cm4gc3ZnTm9kZVxufVxuLyogYzggaWdub3JlIGVuZCAqL1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgRE9NIHRoYXQgd2lsbCBiZSBpbmplY3RlZFxuICogQHBhcmFtIHtvYmplY3R9IHJvb3QgLSBET00gbm9kZSB0byBmaW5kIG91dCB0aGUgY29udGV4dCB3aGVyZSB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBodG1sIC0gRE9NIHRvIGNyZWF0ZSBhcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRG9jdW1lbnRGcmFnbWVudHxIVE1MRWxlbWVudH0gYSBuZXcgaHRtbCBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVET01UcmVlKHJvb3QsIGh0bWwpIHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgaWYgKGlzU3ZnKHJvb3QpKSByZXR1cm4gY3JlYXRlU1ZHVHJlZShodG1sLCByb290KVxuXG4gIHJldHVybiBjcmVhdGVIVE1MVHJlZShodG1sLCByb290KVxufVxuXG4vKipcbiAqIEluamVjdCB0aGUgRE9NIHRyZWUgaW50byBhIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsIC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtEb2N1bWVudEZyYWdtZW50fFNWR0VsZW1lbnR9IGRvbSAtIGRvbSB0cmVlIHRvIGluamVjdFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RE9NKGVsLCBkb20pIHtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1N2ZyhlbCk6XG4gICAgICBtb3ZlQ2hpbGRyZW4oZG9tLCBlbCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgaXNUZW1wbGF0ZShlbCk6XG4gICAgICBlbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb20sIGVsKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGVsLmFwcGVuZENoaWxkKGRvbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIFRlbXBsYXRlIERPTSBza2VsZXRvblxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbCAtIHJvb3Qgbm9kZSB3aGVyZSB0aGUgRE9NIHdpbGwgYmUgaW5qZWN0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGh0bWwgLSBIVE1MIG1hcmt1cCBvciBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgcm9vdCBub2RlXG4gKiBAcmV0dXJucyB7P0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVET00oZWwsIGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwgJiYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJyA/IGNyZWF0ZURPTVRyZWUoZWwsIGh0bWwpIDogaHRtbClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9mZnNldCBvZiB0aGUgPHRlbXBsYXRlPiB0YWdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudE5vZGUgLSB0ZW1wbGF0ZSB0YWcgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gdGhlIHRlbXBsYXRlIHRhZyB3ZSB3YW50IHRvIHJlbmRlclxuICogQHBhcmFtICAge29iamVjdH0gbWV0YSAtIG1ldGEgcHJvcGVydGllcyBuZWVkZWQgdG8gaGFuZGxlIHRoZSA8dGVtcGxhdGU+IHRhZ3MgaW4gbG9vcHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG9mZnNldCBvZiB0aGUgPHRlbXBsYXRlPiB0YWcgY2FsY3VsYXRlZCBmcm9tIGl0cyBzaWJsaW5ncyBET00gbm9kZXNcbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcGxhdGVUYWdPZmZzZXQocGFyZW50Tm9kZSwgZWwsIG1ldGEpIHtcbiAgY29uc3Qgc2libGluZ3MgPSBBcnJheS5mcm9tKHBhcmVudE5vZGUuY2hpbGROb2Rlcyk7XG5cbiAgcmV0dXJuIE1hdGgubWF4KHNpYmxpbmdzLmluZGV4T2YoZWwpLCBzaWJsaW5ncy5pbmRleE9mKG1ldGEuaGVhZCkgKyAxLCAwKVxufVxuXG4vKipcbiAqIFRlbXBsYXRlIENodW5rIG1vZGVsXG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5jb25zdCBUZW1wbGF0ZUNodW5rID0ge1xuICAvLyBTdGF0aWMgcHJvcHNcbiAgLy8gYmluZGluZ3M6IG51bGwsXG4gIC8vIGJpbmRpbmdzRGF0YTogbnVsbCxcbiAgLy8gaHRtbDogbnVsbCxcbiAgLy8gaXNUZW1wbGF0ZVRhZzogZmFsc2UsXG4gIC8vIGZyYWdtZW50OiBudWxsLFxuICAvLyBjaGlsZHJlbjogbnVsbCxcbiAgLy8gZG9tOiBudWxsLFxuICAvLyBlbDogbnVsbCxcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBET00gc3RydWN0dXJlIHRoYXQgd2lsbCBiZSBjbG9uZWQgb24gZWFjaCBtb3VudFxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsIC0gdGhlIHJvb3Qgbm9kZVxuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgY3JlYXRlRE9NKGVsKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIERPTSBnZXRzIGNyZWF0ZWQgYmVmb3JlIGNsb25pbmcgdGhlIHRlbXBsYXRlXG4gICAgdGhpcy5kb20gPVxuICAgICAgdGhpcy5kb20gfHxcbiAgICAgIGNyZWF0ZVRlbXBsYXRlRE9NKGVsLCB0aGlzLmh0bWwpIHx8XG4gICAgICBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8vIEFQSSBtZXRob2RzXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIHRlbXBsYXRlIHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbCAtIHRhcmdldCBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBkYXRhXG4gICAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGUgdGFnXG4gICAqIEBwYXJhbSAgIHtvYmplY3R9IG1ldGEgLSBtZXRhIHByb3BlcnRpZXMgbmVlZGVkIHRvIGhhbmRsZSB0aGUgPHRlbXBsYXRlPiB0YWdzIGluIGxvb3BzXG4gICAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSBzZWxmXG4gICAqL1xuICBtb3VudChlbCwgc2NvcGUsIHBhcmVudFNjb3BlLCBtZXRhID0ge30pIHtcbiAgICBpZiAoIWVsKSBwYW5pYygnUGxlYXNlIHByb3ZpZGUgRE9NIG5vZGUgdG8gbW91bnQgcHJvcGVybHkgeW91ciB0ZW1wbGF0ZScpO1xuXG4gICAgaWYgKHRoaXMuZWwpIHRoaXMudW5tb3VudChzY29wZSk7XG5cbiAgICAvLyA8dGVtcGxhdGU+IHRhZ3MgcmVxdWlyZSBhIGJpdCBtb3JlIHdvcmtcbiAgICAvLyB0aGUgdGVtcGxhdGUgZnJhZ21lbnQgbWlnaHQgYmUgYWxyZWFkeSBjcmVhdGVkIHZpYSBtZXRhIG91dHNpZGUgb2YgdGhpcyBjYWxsXG4gICAgY29uc3QgeyBmcmFnbWVudCwgY2hpbGRyZW4sIGF2b2lkRE9NSW5qZWN0aW9uIH0gPSBtZXRhO1xuICAgIC8vIDx0ZW1wbGF0ZT4gYmluZGluZ3Mgb2YgY291cnNlIGNhbiBub3QgaGF2ZSBhIHJvb3QgZWxlbWVudFxuICAgIC8vIHNvIHdlIGNoZWNrIHRoZSBwYXJlbnQgbm9kZSB0byBzZXQgdGhlIHF1ZXJ5IHNlbGVjdG9yIGJpbmRpbmdzXG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBjaGlsZHJlbiA/IGNoaWxkcmVuWzBdIDogZWw7XG4gICAgY29uc3QgaXNUZW1wbGF0ZVRhZyA9IGlzVGVtcGxhdGUoZWwpO1xuICAgIGNvbnN0IHRlbXBsYXRlVGFnT2Zmc2V0ID0gaXNUZW1wbGF0ZVRhZ1xuICAgICAgPyBnZXRUZW1wbGF0ZVRhZ09mZnNldChwYXJlbnROb2RlLCBlbCwgbWV0YSlcbiAgICAgIDogbnVsbDtcblxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIGlmIGl0IHdhc24ndCBjcmVhdGVkIGJlZm9yZVxuICAgIHRoaXMuY3JlYXRlRE9NKGVsKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIG9mIHRoaXMgdGVtcGxhdGUgY2xvbmluZyB0aGUgb3JpZ2luYWwgRE9NIHN0cnVjdHVyZSBzdG9yZWQgaW4gdGhpcyBpbnN0YW5jZVxuICAgIC8vIG5vdGljZSB0aGF0IGlmIGEgZG9jdW1lbnRGcmFnbWVudCB3YXMgcGFzc2VkICh2aWEgbWV0YSkgd2Ugd2lsbCB1c2UgaXQgaW5zdGVhZFxuICAgIGNvbnN0IGNsb25lTm9kZSA9IGZyYWdtZW50IHx8IHRoaXMuZG9tLmNsb25lTm9kZSh0cnVlKTtcblxuICAgIC8vIHN0b3JlIHJvb3Qgbm9kZVxuICAgIC8vIG5vdGljZSB0aGF0IGZvciB0ZW1wbGF0ZSB0YWdzIHRoZSByb290IG5vdGUgd2lsbCBiZSB0aGUgcGFyZW50IHRhZ1xuICAgIHRoaXMuZWwgPSBpc1RlbXBsYXRlVGFnID8gcGFyZW50Tm9kZSA6IGVsO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBjaGlsZHJlbiBhcnJheSBvbmx5IGZvciB0aGUgPHRlbXBsYXRlPiBmcmFnbWVudHNcbiAgICB0aGlzLmNoaWxkcmVuID0gaXNUZW1wbGF0ZVRhZ1xuICAgICAgPyBjaGlsZHJlbiB8fCBBcnJheS5mcm9tKGNsb25lTm9kZS5jaGlsZE5vZGVzKVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gaW5qZWN0IHRoZSBET00gaW50byB0aGUgZWwgb25seSBpZiBhIGZyYWdtZW50IGlzIGF2YWlsYWJsZVxuICAgIGlmICghYXZvaWRET01JbmplY3Rpb24gJiYgY2xvbmVOb2RlKSBpbmplY3RET00oZWwsIGNsb25lTm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGJpbmRpbmdzXG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3NEYXRhLm1hcCgoYmluZGluZykgPT5cbiAgICAgIGNyZWF0ZSQxKHRoaXMuZWwsIGJpbmRpbmcsIHRlbXBsYXRlVGFnT2Zmc2V0KSxcbiAgICApO1xuICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaCgoYikgPT4gYi5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpKTtcblxuICAgIC8vIHN0b3JlIHRoZSB0ZW1wbGF0ZSBtZXRhIHByb3BlcnRpZXNcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0ZW1wbGF0ZSB3aXRoIGZyZXNoIGRhdGFcbiAgICogQHBhcmFtICAgeyp9IHNjb3BlIC0gdGVtcGxhdGUgZGF0YVxuICAgKiBAcGFyYW0gICB7Kn0gcGFyZW50U2NvcGUgLSBzY29wZSBvZiB0aGUgcGFyZW50IHRlbXBsYXRlIHRhZ1xuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgdXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaCgoYikgPT4gYi51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSk7XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRlbXBsYXRlIGZyb20gdGhlIG5vZGUgd2hlcmUgaXQgd2FzIGluaXRpYWxseSBtb3VudGVkXG4gICAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIHRlbXBsYXRlIGRhdGFcbiAgICogQHBhcmFtICAgeyp9IHBhcmVudFNjb3BlIC0gc2NvcGUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZSB0YWdcbiAgICogQHBhcmFtICAge2Jvb2xlYW58bnVsbH0gbXVzdFJlbW92ZVJvb3QgLSBpZiB0cnVlIHJlbW92ZSB0aGUgcm9vdCBlbGVtZW50LFxuICAgKiBpZiBmYWxzZSBvciB1bmRlZmluZWQgY2xlYW4gdGhlIHJvb3QgdGFnIGNvbnRlbnQsIGlmIG51bGwgZG9uJ3QgdG91Y2ggdGhlIERPTVxuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUsIG11c3RSZW1vdmVSb290ID0gZmFsc2UpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWw7XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaCgoYikgPT4gYi51bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwgbXVzdFJlbW92ZVJvb3QpKTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgLy8gcHVyZSBjb21wb25lbnRzIHNob3VsZCBoYW5kbGUgdGhlIERPTSB1bm1vdW50IHVwZGF0ZXMgYnkgdGhlbXNlbHZlc1xuICAgICAgLy8gZm9yIG11c3RSZW1vdmVSb290ID09PSBudWxsIGRvbid0IHRvdWNoIHRoZSBET01cbiAgICAgIGNhc2UgZWxbSVNfUFVSRV9TWU1CT0xdIHx8IG11c3RSZW1vdmVSb290ID09PSBudWxsOlxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBpZiBjaGlsZHJlbiBhcmUgZGVjbGFyZWQsIGNsZWFyIHRoZW1cbiAgICAgIC8vIGFwcGxpY2FibGUgZm9yIDx0ZW1wbGF0ZT4gYW5kIDxzbG90Lz4gYmluZGluZ3NcbiAgICAgIGNhc2UgQXJyYXkuaXNBcnJheSh0aGlzLmNoaWxkcmVuKTpcbiAgICAgICAgY2xlYXJDaGlsZHJlbih0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gY2xlYW4gdGhlIG5vZGUgY2hpbGRyZW4gb25seVxuICAgICAgY2FzZSAhbXVzdFJlbW92ZVJvb3Q6XG4gICAgICAgIGNsZWFuTm9kZShlbCk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgcm9vdCBub2RlIG9ubHkgaWYgdGhlIG11c3RSZW1vdmVSb290IGlzIHRydWx5XG4gICAgICBjYXNlICEhbXVzdFJlbW92ZVJvb3Q6XG4gICAgICAgIHJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLmVsID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIHRoZSB0ZW1wbGF0ZSBjaHVua1xuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gYSBjbG9uZSBvZiB0aGlzIG9iamVjdCByZXNldHRpbmcgdGhlIHRoaXMuZWwgcHJvcGVydHlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLFxuICAgICAgbWV0YToge30sXG4gICAgICBlbDogbnVsbCxcbiAgICB9XG4gIH0sXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRlbXBsYXRlIGNodW5rIHdpcmluZyBhbHNvIHRoZSBiaW5kaW5nc1xuICogQHBhcmFtICAge3N0cmluZ3xIVE1MRWxlbWVudH0gaHRtbCAtIHRlbXBsYXRlIHN0cmluZ1xuICogQHBhcmFtICAge0JpbmRpbmdEYXRhW119IGJpbmRpbmdzIC0gYmluZGluZ3MgY29sbGVjdGlvblxuICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgbmV3IFRlbXBsYXRlQ2h1bmsgY29weVxuICovXG5mdW5jdGlvbiBjcmVhdGUoaHRtbCwgYmluZGluZ3MgPSBbXSkge1xuICByZXR1cm4ge1xuICAgIC4uLlRlbXBsYXRlQ2h1bmssXG4gICAgaHRtbCxcbiAgICBiaW5kaW5nc0RhdGE6IGJpbmRpbmdzLFxuICB9XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSQxIGFzIGNyZWF0ZUJpbmRpbmcsIGNyZWF0ZSQ0IGFzIGNyZWF0ZUV4cHJlc3Npb24sIGNyZWF0ZSBhcyB0ZW1wbGF0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///116\n\n}")},128:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _riotjs_route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(419);\n/* harmony import */ var _riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(989);\n/* harmony import */ var _pages_not_found_riot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(708);\n/* harmony import */ var _pages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(361);\n/* harmony import */ var _components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(823);\n/* harmony import */ var _riotjs_hot_reload__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n  css: null,\r\n\r\n  exports: {\r\n    components: {\r\n      Router: _riotjs_route__WEBPACK_IMPORTED_MODULE_0__/* .Router */ .Ix,\r\n      Route: _riotjs_route__WEBPACK_IMPORTED_MODULE_0__/* .Route */ .qh,\r\n      NotFound: _pages_not_found_riot__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A,\r\n      Home: (0,_riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(_components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A, () => __webpack_require__.e(/* import() | pages/home */ 845).then(__webpack_require__.bind(__webpack_require__, 595))),\r\n      Ideal: (0,_riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(_components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A, () => __webpack_require__.e(/* import() | pages/ideal */ 751).then(__webpack_require__.bind(__webpack_require__, 229))),\r\n      Team: (0,_riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(_components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A, () => Promise.all(/* import() | pages/team */[__webpack_require__.e(826), __webpack_require__.e(819)]).then(__webpack_require__.bind(__webpack_require__, 609))),\r\n      Projects: (0,_riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(_components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A, () => __webpack_require__.e(/* import() | pages/projects */ 694).then(__webpack_require__.bind(__webpack_require__, 90))),\r\n      Contact: (0,_riotjs_lazy__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(_components_includes_loader_loader_riot__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A, () => __webpack_require__.e(/* import() | pages/contact */ 364).then(__webpack_require__.bind(__webpack_require__, 992))),\r\n    },\r\n\r\n    state: {\r\n      pages: _pages__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A,\r\n      showNotFound: false,\r\n      activePage: null\r\n    },\r\n\r\n    onBeforeMount({ isServer }) {\r\n      // create a stream on all routes to catch the not-found page\r\n      this.anyRouteStream = (0,_riotjs_route__WEBPACK_IMPORTED_MODULE_0__/* .route */ .wE)('(.*)')\r\n      this.anyRouteStream.on.value(this.onAnyRoute)\r\n    },\r\n\r\n    onAnyRoute(path) {\r\n      // show the not found page if none of the page paths are matched\r\n      const activePage = _pages__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.find(p => (0,_riotjs_route__WEBPACK_IMPORTED_MODULE_0__/* .match */ .YW)(path.pathname, (0,_riotjs_route__WEBPACK_IMPORTED_MODULE_0__/* .toRegexp */ .Bi)(p.path)))\r\n\r\n      this.update({\r\n        activePage,\r\n        showNotFound: !activePage\r\n      })\r\n    },\r\n\r\n    onBeforeUnmount() {\r\n      this.anyRouteStream.end()\r\n    }\r\n  },\r\n\r\n  template: (\r\n    template,\r\n    expressionTypes,\r\n    bindingTypes,\r\n    getComponent\r\n  ) => template(\r\n    '<div class=\"d-flex flex-column h-100\"><div class=\"container-fluid\"><global-nav expr0=\"expr0\"></global-nav><router expr1=\"expr1\"></router></div><footer class=\"d-flex footer mt-auto py-3\"><div class=\"container text-center\"><span class=\"text-muted\"><small expr7=\"expr7\">Copyright Vault Lambda LLC<br/> </small></span></div></footer></div>',\r\n    [\r\n      {\r\n        expressions: [\r\n          {\r\n            type: expressionTypes.ATTRIBUTE,\r\n            isBoolean: false,\r\n            name: 'class',\r\n            evaluate: _scope => 'h-100'\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        type: bindingTypes.TAG,\r\n        getComponent: getComponent,\r\n        evaluate: _scope => 'global-nav',\r\n        slots: [],\r\n        attributes: [],\r\n        redundantAttribute: 'expr0',\r\n        selector: '[expr0]'\r\n      },\r\n      {\r\n        type: bindingTypes.TAG,\r\n        getComponent: getComponent,\r\n        evaluate: _scope => 'router',\r\n\r\n        slots: [\r\n          {\r\n            id: 'default',\r\n            html: '<div expr2=\"expr2\"></div><div expr4=\"expr4\"></div>',\r\n\r\n            bindings: [\r\n              {\r\n                type: bindingTypes.IF,\r\n                evaluate: _scope => _scope.state.showNotFound,\r\n                redundantAttribute: 'expr2',\r\n                selector: '[expr2]',\r\n\r\n                template: template(\r\n                  '<div class=\"column column-60\"><not-found expr3=\"expr3\"></not-found></div>',\r\n                  [\r\n                    {\r\n                      type: bindingTypes.TAG,\r\n                      getComponent: getComponent,\r\n                      evaluate: _scope => 'not-found',\r\n                      slots: [],\r\n                      attributes: [],\r\n                      redundantAttribute: 'expr3',\r\n                      selector: '[expr3]'\r\n                    }\r\n                  ]\r\n                )\r\n              },\r\n              {\r\n                type: bindingTypes.IF,\r\n                evaluate: _scope => !_scope.state.showNotFound,\r\n                redundantAttribute: 'expr4',\r\n                selector: '[expr4]',\r\n\r\n                template: template(\r\n                  '<div class=\"column column-60\"><route expr5=\"expr5\"></route></div>',\r\n                  [\r\n                    {\r\n                      type: bindingTypes.EACH,\r\n                      getKey: null,\r\n                      condition: null,\r\n\r\n                      template: template(\r\n                        null,\r\n                        [\r\n                          {\r\n                            type: bindingTypes.TAG,\r\n                            getComponent: getComponent,\r\n                            evaluate: _scope => 'route',\r\n\r\n                            slots: [\r\n                              {\r\n                                id: 'default',\r\n                                html: '<main expr6=\"expr6\"></main>',\r\n\r\n                                bindings: [\r\n                                  {\r\n                                    type: bindingTypes.TAG,\r\n                                    getComponent: getComponent,\r\n                                    evaluate: _scope => _scope.page.componentName,\r\n                                    slots: [],\r\n                                    attributes: [],\r\n                                    redundantAttribute: 'expr6',\r\n                                    selector: '[expr6]'\r\n                                  }\r\n                                ]\r\n                              }\r\n                            ],\r\n\r\n                            attributes: [\r\n                              {\r\n                                type: expressionTypes.ATTRIBUTE,\r\n                                isBoolean: false,\r\n                                name: 'path',\r\n                                evaluate: _scope => _scope.page.path\r\n                              }\r\n                            ]\r\n                          }\r\n                        ]\r\n                      ),\r\n\r\n                      redundantAttribute: 'expr5',\r\n                      selector: '[expr5]',\r\n                      itemName: 'page',\r\n                      indexName: null,\r\n                      evaluate: _scope => _scope.state.pages\r\n                    }\r\n                  ]\r\n                )\r\n              }\r\n            ]\r\n          }\r\n        ],\r\n\r\n        attributes: [],\r\n        redundantAttribute: 'expr1',\r\n        selector: '[expr1]'\r\n      },\r\n      {\r\n        redundantAttribute: 'expr7',\r\n        selector: '[expr7]',\r\n\r\n        expressions: [\r\n          {\r\n            type: expressionTypes.TEXT,\r\n            childNodeIndex: 2,\r\n\r\n            evaluate: _scope => [\r\n              '2018 - ',\r\n              (new Date()).getFullYear()\r\n            ].join(\r\n              ''\r\n            )\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  ),\r\n\r\n  name: 'app'\r\n});\n  \n  \n  ;(() => {\n    if (true) {\n      module.hot.accept()\n      if (module.hot.data) {\n        const component = (__webpack_require__(128)/* [\"default\"] */ .A);\n        (0,_riotjs_hot_reload__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A)(component)\n      }\n    }\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBM0VBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7O0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vc3JjL2FwcC5yaW90PzU2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiPGFwcCBjbGFzcz1cImgtMTAwXCI+XG4gIDxkaXYgY2xhc3M9XCJkLWZsZXggZmxleC1jb2x1bW4gaC0xMDBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XG4gICAgICA8Z2xvYmFsLW5hdj48L2dsb2JhbC1uYXY+XG4gICAgICA8cm91dGVyPlxuICAgICAgICA8ZGl2IGlmPXtzdGF0ZS5zaG93Tm90Rm91bmR9PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gY29sdW1uLTYwXCI+XG4gICAgICAgICAgICA8bm90LWZvdW5kIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGlmPXshc3RhdGUuc2hvd05vdEZvdW5kfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGNvbHVtbi02MFwiPlxuICAgICAgICAgICAgPHJvdXRlIGVhY2g9e3BhZ2UgaW4gc3RhdGUucGFnZXN9IHBhdGg9e3BhZ2UucGF0aH0+XG4gICAgICAgICAgICAgIDxtYWluIGlzPXtwYWdlLmNvbXBvbmVudE5hbWV9Lz5cbiAgICAgICAgICAgIDwvcm91dGU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9yb3V0ZXI+XG4gICAgPC9kaXY+XG4gICAgPGZvb3RlciBjbGFzcz1cImQtZmxleCBmb290ZXIgbXQtYXV0byBweS0zXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHRleHQtY2VudGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1tdXRlZFwiPjxzbWFsbD5Db3B5cmlnaHQgVmF1bHQgTGFtYmRhIExMQzxicj4yMDE4IC0geyAobmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKX08L3NtYWxsPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZm9vdGVyPlxuICA8L2Rpdj5cbiAgXG4gIDxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgUm91dGVyLCBSb3V0ZSwgcm91dGUsIHRvUmVnZXhwLCBtYXRjaCB9IGZyb20gJ0ByaW90anMvcm91dGUnXG4gICAgaW1wb3J0IGxhenkgZnJvbSAnQHJpb3Rqcy9sYXp5J1xuICAgIGltcG9ydCBOb3RGb3VuZCBmcm9tICcuL3BhZ2VzL25vdC1mb3VuZC5yaW90J1xuICAgIGltcG9ydCBwYWdlcyBmcm9tICcuL3BhZ2VzJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnLi9jb21wb25lbnRzL2luY2x1ZGVzL2xvYWRlci9sb2FkZXIucmlvdCdcblxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUm91dGVyLFxuICAgICAgICBSb3V0ZSxcbiAgICAgICAgTm90Rm91bmQsXG4gICAgICAgIEhvbWU6IGxhenkoTG9hZGVyLCAoKSA9PiBpbXBvcnQoXG4gICAgICAgICAgLyogd2VicGFja1ByZWZldGNoOiB0cnVlLCB3ZWJwYWNrQ2h1bmtOYW1lOiAncGFnZXMvaG9tZScgKi9cbiAgICAgICAgICAnLi9wYWdlcy9ob21lLnJpb3QnXG4gICAgICAgICkpLFxuICAgICAgICBJZGVhbDogbGF6eShMb2FkZXIsICgpID0+IGltcG9ydChcbiAgICAgICAgICAvKiB3ZWJwYWNrUHJlZmV0Y2g6IHRydWUsIHdlYnBhY2tDaHVua05hbWU6ICdwYWdlcy9pZGVhbCcgKi9cbiAgICAgICAgICAnLi9wYWdlcy9pZGVhbC5yaW90J1xuICAgICAgICApKSxcbiAgICAgICAgVGVhbTogbGF6eShMb2FkZXIsICgpID0+IGltcG9ydChcbiAgICAgICAgICAvKiB3ZWJwYWNrUHJlZmV0Y2g6IHRydWUsIHdlYnBhY2tDaHVua05hbWU6ICdwYWdlcy90ZWFtJyAqL1xuICAgICAgICAgICcuL3BhZ2VzL3RlYW0ucmlvdCdcbiAgICAgICAgKSksXG4gICAgICAgIFByb2plY3RzOiBsYXp5KExvYWRlciwgKCkgPT4gaW1wb3J0KFxuICAgICAgICAgIC8qIHdlYnBhY2tQcmVmZXRjaDogdHJ1ZSwgd2VicGFja0NodW5rTmFtZTogJ3BhZ2VzL3Byb2plY3RzJyAqL1xuICAgICAgICAgICcuL3BhZ2VzL3Byb2plY3RzLnJpb3QnXG4gICAgICAgICkpLFxuICAgICAgICBDb250YWN0OiBsYXp5KExvYWRlciwgKCkgPT4gaW1wb3J0KFxuICAgICAgICAgIC8qIHdlYnBhY2tQcmVmZXRjaDogdHJ1ZSwgd2VicGFja0NodW5rTmFtZTogJ3BhZ2VzL2NvbnRhY3QnICovXG4gICAgICAgICAgJy4vcGFnZXMvY29udGFjdC5yaW90J1xuICAgICAgICApKSxcbiAgICAgIH0sXG4gICAgICBzdGF0ZToge1xuICAgICAgICBwYWdlcyxcbiAgICAgICAgc2hvd05vdEZvdW5kOiBmYWxzZSxcbiAgICAgICAgYWN0aXZlUGFnZTogbnVsbFxuICAgICAgfSxcbiAgICAgIG9uQmVmb3JlTW91bnQoeyBpc1NlcnZlciB9KSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHN0cmVhbSBvbiBhbGwgcm91dGVzIHRvIGNhdGNoIHRoZSBub3QtZm91bmQgcGFnZVxuICAgICAgICB0aGlzLmFueVJvdXRlU3RyZWFtID0gcm91dGUoJyguKiknKVxuICAgICAgICB0aGlzLmFueVJvdXRlU3RyZWFtLm9uLnZhbHVlKHRoaXMub25BbnlSb3V0ZSlcbiAgICAgIH0sXG4gICAgICBvbkFueVJvdXRlKHBhdGgpIHtcbiAgICAgICAgLy8gc2hvdyB0aGUgbm90IGZvdW5kIHBhZ2UgaWYgbm9uZSBvZiB0aGUgcGFnZSBwYXRocyBhcmUgbWF0Y2hlZFxuICAgICAgICBjb25zdCBhY3RpdmVQYWdlID0gcGFnZXMuZmluZChwID0+IG1hdGNoKHBhdGgucGF0aG5hbWUsIHRvUmVnZXhwKHAucGF0aCkpKVxuXG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICBhY3RpdmVQYWdlLFxuICAgICAgICAgIHNob3dOb3RGb3VuZDogIWFjdGl2ZVBhZ2VcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBvbkJlZm9yZVVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuYW55Um91dGVTdHJlYW0uZW5kKClcbiAgICAgIH1cbiAgICB9XG4gIDwvc2NyaXB0PlxuPC9hcHA+XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///128\n\n}")},131:(n,t,e)=>{var g={"./global-nav/global-nav.riot":877};function I(n){var t=c(n);return e(t)}function c(n){if(!e.o(g,n)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return g[n]}I.keys=function(){return Object.keys(g)},I.resolve=c,n.exports=I,I.id=131},359:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ay: () => (/* binding */ expressionTypes),\n/* harmony export */   Qg: () => (/* binding */ VALUE),\n/* harmony export */   a$: () => (/* binding */ TEXT),\n/* harmony export */   bc: () => (/* binding */ ATTRIBUTE),\n/* harmony export */   g4: () => (/* binding */ REF),\n/* harmony export */   ll: () => (/* binding */ EVENT)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nconst REF = 4;\n\nconst expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE,\n  REF,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZXhwcmVzc2lvbi10eXBlcy5qcz8zNjkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgV0lQLCBAbGljZW5zZSBNSVQgKi9cbmNvbnN0IEFUVFJJQlVURSA9IDA7XG5jb25zdCBFVkVOVCA9IDE7XG5jb25zdCBURVhUID0gMjtcbmNvbnN0IFZBTFVFID0gMztcbmNvbnN0IFJFRiA9IDQ7XG5cbmNvbnN0IGV4cHJlc3Npb25UeXBlcyA9IHtcbiAgQVRUUklCVVRFLFxuICBFVkVOVCxcbiAgVEVYVCxcbiAgVkFMVUUsXG4gIFJFRixcbn07XG5cbmV4cG9ydCB7IEFUVFJJQlVURSwgRVZFTlQsIFJFRiwgVEVYVCwgVkFMVUUsIGV4cHJlc3Npb25UeXBlcyBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///359\n\n}")},361:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    {\n        path: "/",\n        label: "Home",\n        componentName: "home",\n    },\n    {\n        path: "/ideal",\n        label: "Ideal",\n        componentName: "ideal",\n    },\n    {\n        path: "/team",\n        label: "Team",\n        componentName: "team",\n    },\n    {\n        path: "/projects",\n        label: "Projects",\n        componentName: "projects",\n    },\n    {\n        path: "/contact",\n        label: "Contact",\n        componentName: "contact",\n    },\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYxLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9zcmMvcGFnZXMudHM/NDFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBbXG4gICAge1xuICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgbGFiZWw6IFwiSG9tZVwiLFxuICAgICAgICBjb21wb25lbnROYW1lOiBcImhvbWVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcGF0aDogXCIvaWRlYWxcIixcbiAgICAgICAgbGFiZWw6IFwiSWRlYWxcIixcbiAgICAgICAgY29tcG9uZW50TmFtZTogXCJpZGVhbFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBwYXRoOiBcIi90ZWFtXCIsXG4gICAgICAgIGxhYmVsOiBcIlRlYW1cIixcbiAgICAgICAgY29tcG9uZW50TmFtZTogXCJ0ZWFtXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHBhdGg6IFwiL3Byb2plY3RzXCIsXG4gICAgICAgIGxhYmVsOiBcIlByb2plY3RzXCIsXG4gICAgICAgIGNvbXBvbmVudE5hbWU6IFwicHJvamVjdHNcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcGF0aDogXCIvY29udGFjdFwiLFxuICAgICAgICBsYWJlbDogXCJDb250YWN0XCIsXG4gICAgICAgIGNvbXBvbmVudE5hbWU6IFwiY29udGFjdFwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///361\n\n}')},397:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ get),\n/* harmony export */   h: () => (/* binding */ set)\n/* harmony export */ });\n/* harmony import */ var _bianco_dom_to_array_index_next_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(550);\n/* Riot WIP, @license MIT */\n\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values;\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize((0,_bianco_dom_to_array_index_next_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : { [name]: value };\n  const props = Object.keys(attrs);\n\n  (0,_bianco_dom_to_array_index_next_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute')\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk3LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvYmlhbmNvLmF0dHIvaW5kZXgubmV4dC5qcz80NjUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgV0lQLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCBkb21Ub0FycmF5IGZyb20gJy4uL2JpYW5jby5kb20tdG8tYXJyYXkvaW5kZXgubmV4dC5qcyc7XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSByZXR1cm4gdmFsdWVzLCBpbiBjYXNlIG9mIGEgc2luZ2xlIHZhbHVlIHdlIGF2b2lkIHRvIHJldHVybiBhbiBhcnJheVxuICogQHBhcmFtICAgeyBBcnJheSB9IHZhbHVlcyAtIGxpc3Qgb2YgdmFsdWVzIHdlIHdhbnQgdG8gcmV0dXJuXG4gKiBAcmV0dXJucyB7IEFycmF5fHN0cmluZ3xib29sZWFuIH0gZWl0aGVyIHRoZSB3aG9sZSBsaXN0IG9mIHZhbHVlcyBvciB0aGUgc2luZ2xlIG9uZSBmb3VuZFxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9ybWFsaXplID0gdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPT09IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXM7XG5cbi8qKlxuICogUGFyc2UgYWxsIHRoZSBub2RlcyByZWNlaXZlZCB0byBnZXQvcmVtb3ZlL2NoZWNrIHRoZWlyIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnR8Tm9kZUxpc3R8QXJyYXkgfSBlbHMgICAgLSBET00gbm9kZS9zIHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IHN0cmluZ3xBcnJheSB9ICAgICAgICAgICAgICAgbmFtZSAgIC0gbmFtZSBvciBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICAgICBtZXRob2QgLSBtZXRob2QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgdGhlIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nIH0gcmVzdWx0IG9mIHRoZSBwYXJzaW5nIGluIGEgbGlzdCBvciBhIHNpbmdsZSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VOb2RlcyhlbHMsIG5hbWUsIG1ldGhvZCkge1xuICBjb25zdCBuYW1lcyA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFtuYW1lXSA6IG5hbWU7XG4gIHJldHVybiBub3JtYWxpemUoZG9tVG9BcnJheShlbHMpLm1hcChlbCA9PiB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lcy5tYXAobiA9PiBlbFttZXRob2RdKG4pKSlcbiAgfSkpXG59XG5cbi8qKlxuICogU2V0IGFueSBhdHRyaWJ1dGUgb24gYSBzaW5nbGUgb3IgYSBsaXN0IG9mIERPTSBub2Rlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgIC0gRE9NIG5vZGUvcyB0byBwYXJzZVxuICogQHBhcmFtICAgeyBzdHJpbmd8T2JqZWN0IH0gICAgICAgICAgICAgIG5hbWUgIC0gZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGxpc3Qgb2YgcHJvcGVydGllcyBhcyBvYmplY3Qga2V5IC0gdmFsdWVcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gdGhlIG9yaWdpbmFsIGFycmF5IG9mIGVsZW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgeyBzZXQgfSBmcm9tICdiaWFuY28uYXR0cidcbiAqXG4gKiBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICpcbiAqIHNldChpbWcsICd3aWR0aCcsIDEwMClcbiAqXG4gKiAvLyBvciBhbHNvXG4gKiBzZXQoaW1nLCB7XG4gKiAgIHdpZHRoOiAzMDAsXG4gKiAgIGhlaWdodDogMzAwXG4gKiB9KVxuICpcbiAqL1xuZnVuY3Rpb24gc2V0KGVscywgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgYXR0cnMgPSB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogeyBbbmFtZV06IHZhbHVlIH07XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuXG4gIGRvbVRvQXJyYXkoZWxzKS5mb3JFYWNoKGVsID0+IHtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4gZWwuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJzW3Byb3BdKSk7XG4gIH0pO1xuICByZXR1cm4gZWxzXG59XG5cbi8qKlxuICogR2V0IGFueSBhdHRyaWJ1dGUgZnJvbSBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gZWxzICAgLSBET00gbm9kZS9zIHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IHN0cmluZ3xBcnJheSB9ICAgICAgICAgICAgICAgbmFtZSAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBnZXRcbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nIH0gbGlzdCBvZiB0aGUgYXR0cmlidXRlcyBmb3VuZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgZ2V0IH0gZnJvbSAnYmlhbmNvLmF0dHInXG4gKlxuICogY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAqXG4gKiBnZXQoaW1nLCAnd2lkdGgnKSAvLyA9PiAnMjAwJ1xuICpcbiAqIC8vIG9yIGFsc29cbiAqIGdldChpbWcsIFsnd2lkdGgnLCAnaGVpZ2h0J10pIC8vID0+IFsnMjAwJywgJzMwMCddXG4gKlxuICogLy8gb3IgYWxzb1xuICogZ2V0KFtpbWcxLCBpbWcyXSwgWyd3aWR0aCcsICdoZWlnaHQnXSkgLy8gPT4gW1snMjAwJywgJzMwMCddLCBbJzUwMCcsICcyMDAnXV1cbiAqL1xuZnVuY3Rpb24gZ2V0KGVscywgbmFtZSkge1xuICByZXR1cm4gcGFyc2VOb2RlcyhlbHMsIG5hbWUsICdnZXRBdHRyaWJ1dGUnKVxufVxuXG5leHBvcnQgeyBnZXQsIHNldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///397\n\n}")},403:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __: () => (/* binding */ __)\n/* harmony export */ });\n/* harmony import */ var _dependencies_riotjs_util_binding_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(604);\n/* harmony import */ var _dependencies_riotjs_util_expression_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(359);\n/* harmony import */ var _dependencies_riotjs_dom_bindings_dist_dom_bindings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116);\n/* harmony import */ var _core_css_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(781);\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n\n\n// expose some internal stuff that might be used from external tools\nconst __ = {\n  cssManager: _core_css_manager_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay,\n  DOMBindings: {\n    template: _dependencies_riotjs_dom_bindings_dist_dom_bindings_js__WEBPACK_IMPORTED_MODULE_3__/* .template */ .vs,\n    createBinding: _dependencies_riotjs_dom_bindings_dist_dom_bindings_js__WEBPACK_IMPORTED_MODULE_3__/* .createBinding */ .KF,\n    createExpression: _dependencies_riotjs_dom_bindings_dist_dom_bindings_js__WEBPACK_IMPORTED_MODULE_3__/* .createExpression */ .Lg,\n    bindingTypes: _dependencies_riotjs_util_binding_types_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay,\n    expressionTypes: _dependencies_riotjs_util_expression_types_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay,\n  },\n  globals: {\n    PROPS_KEY: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .PROPS_KEY */ .zF,\n    STATE_KEY: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .STATE_KEY */ .Mq,\n    IS_COMPONENT_UPDATING: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .IS_COMPONENT_UPDATING */ .wR,\n    COMPONENTS_IMPLEMENTATION_MAP: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .COMPONENTS_IMPLEMENTATION_MAP */ .j$,\n    PLUGINS_SET: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .PLUGINS_SET */ .as,\n    DOM_COMPONENT_INSTANCE_PROPERTY: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .DOM_COMPONENT_INSTANCE_PROPERTY */ .pw,\n    PARENT_KEY_SYMBOL: _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .PARENT_KEY_SYMBOL */ .e5,\n  },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vYXBpL19fLmpzPzJjNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCBiaW5kaW5nVHlwZXMgZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9iaW5kaW5nLXR5cGVzLmpzJztcbmltcG9ydCB7IFBBUkVOVF9LRVlfU1lNQk9MLCBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZLCBQTFVHSU5TX1NFVCwgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAsIElTX0NPTVBPTkVOVF9VUERBVElORywgU1RBVEVfS0VZLCBQUk9QU19LRVkgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgZXhwcmVzc2lvblR5cGVzIGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZXhwcmVzc2lvbi10eXBlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFeHByZXNzaW9uIGFzIGNyZWF0ZSQ0LCBjcmVhdGVCaW5kaW5nIGFzIGNyZWF0ZSQxLCB0ZW1wbGF0ZSBhcyBjcmVhdGUgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy9kb20tYmluZGluZ3MvZGlzdC9kb20tYmluZGluZ3MuanMnO1xuaW1wb3J0IGNzc01hbmFnZXIgZnJvbSAnLi4vY29yZS9jc3MtbWFuYWdlci5qcyc7XG5cbi8vIGV4cG9zZSBzb21lIGludGVybmFsIHN0dWZmIHRoYXQgbWlnaHQgYmUgdXNlZCBmcm9tIGV4dGVybmFsIHRvb2xzXG5jb25zdCBfXyA9IHtcbiAgY3NzTWFuYWdlcixcbiAgRE9NQmluZGluZ3M6IHtcbiAgICB0ZW1wbGF0ZTogY3JlYXRlLFxuICAgIGNyZWF0ZUJpbmRpbmc6IGNyZWF0ZSQxLFxuICAgIGNyZWF0ZUV4cHJlc3Npb246IGNyZWF0ZSQ0LFxuICAgIGJpbmRpbmdUeXBlcyxcbiAgICBleHByZXNzaW9uVHlwZXMsXG4gIH0sXG4gIGdsb2JhbHM6IHtcbiAgICBQUk9QU19LRVksXG4gICAgU1RBVEVfS0VZLFxuICAgIElTX0NPTVBPTkVOVF9VUERBVElORyxcbiAgICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCxcbiAgICBQTFVHSU5TX1NFVCxcbiAgICBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZLFxuICAgIFBBUkVOVF9LRVlfU1lNQk9MLFxuICB9LFxufTtcblxuZXhwb3J0IHsgX18gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///403\n\n}')},419:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bi: () => (/* binding */ toRegexp),\n/* harmony export */   Ix: () => (/* binding */ routerHoc),\n/* harmony export */   YW: () => (/* binding */ match),\n/* harmony export */   qh: () => (/* binding */ routeHoc),\n/* harmony export */   wE: () => (/* binding */ createRoute)\n/* harmony export */ });\n/* unused harmony exports configure, createURLStreamPipe, defaults, getCurrentRoute, initDomListeners, router, setBase, toPath, toURL */\n/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(503);\n/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(403);\n\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === "*" || char === "+" || char === "?") {\n            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === "\\\\") {\n            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === "{") {\n            tokens.push({ type: "OPEN", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === "}") {\n            tokens.push({ type: "CLOSE", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === ":") {\n            var name = "";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError("Missing parameter name at ".concat(i));\n            tokens.push({ type: "NAME", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === "(") {\n            var count = 1;\n            var pattern = "";\n            var j = i + 1;\n            if (str[j] === "?") {\n                throw new TypeError("Pattern cannot start with \\"?\\" at ".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === "\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === ")") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === "(") {\n                    count++;\n                    if (str[j + 1] !== "?") {\n                        throw new TypeError("Capturing groups are not allowed at ".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError("Unbalanced pattern at ".concat(i));\n            if (!pattern)\n                throw new TypeError("Missing pattern at ".concat(i));\n            tokens.push({ type: "PATTERN", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: "CHAR", index: i, value: str[i++] });\n    }\n    tokens.push({ type: "END", index: i, value: "" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;\n    var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = "";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));\n    };\n    var consumeText = function () {\n        var result = "";\n        var value;\n        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume("CHAR");\n        var name = tryConsume("NAME");\n        var pattern = tryConsume("PATTERN");\n        if (name || pattern) {\n            var prefix = char || "";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = "";\n            }\n            if (path) {\n                result.push(path);\n                path = "";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: "",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume("MODIFIER") || "",\n            });\n            continue;\n        }\n        var value = char || tryConsume("ESCAPED_CHAR");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = "";\n        }\n        var open = tryConsume("OPEN");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume("NAME") || "";\n            var pattern_1 = tryConsume("PATTERN") || "";\n            var suffix = consumeText();\n            mustConsume("CLOSE");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : ""),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume("MODIFIER") || "",\n            });\n            continue;\n        }\n        mustConsume("END");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === "object") {\n            return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = "";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === "string") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === "?" || token.modifier === "*";\n            var repeat = token.modifier === "*" || token.modifier === "+";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError("Expected \\"".concat(token.name, "\\" to not repeat, but got an array"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError("Expected \\"".concat(token.name, "\\" to not be empty"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError("Expected all \\"".concat(token.name, "\\" to match \\"").concat(token.pattern, "\\", but got \\"").concat(segment, "\\""));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === "string" || typeof value === "number") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError("Expected \\"".concat(token.name, "\\" to match \\"").concat(token.pattern, "\\", but got \\"").concat(segment, "\\""));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? "an array" : "a string";\n            throw new TypeError("Expected \\"".concat(token.name, "\\" to be ").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, "\\\\$1");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? "" : "i";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: "",\n            suffix: "",\n            modifier: "",\n            pattern: "",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;\n    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");\n    var delimiterRe = "[".concat(escapeString(delimiter), "]");\n    var route = start ? "^" : "";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === "string") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === "+" || token.modifier === "*") {\n                        var mod = token.modifier === "*" ? "?" : "";\n                        route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);\n                    }\n                    else {\n                        route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === "+" || token.modifier === "*") {\n                        route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");\n                    }\n                    else {\n                        route += "(".concat(token.pattern, ")").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += "".concat(delimiterRe, "?");\n        route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === "string"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");\n        }\n        if (!isEndDelimited) {\n            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: \'id\', delimiter: \'/\', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n\n/**\n * Cancel token\n * @private\n * @type { Symbol }\n */\nconst CANCEL = Symbol();\n\n/**\n * Helper that can be returned by ruit function to cancel the tasks chain\n * @returns { Symbol } internal private constant\n * @example\n *\n * ruit(\n *   100,\n *   num => Math.random() * num\n *   num => num > 50 ? ruit.cancel() : num\n *   num => num - 2\n * ).then(result => {\n *   console.log(result) // here we will get only number lower than 50\n * })\n *\n */\nruit.cancel = () => CANCEL;\n\n/**\n * The same as ruit() but with the arguments inverted from right to left\n * @param   { * } tasks - list of tasks to process sequentially\n * @returns { Promise } a promise containing the result of the whole chain\n * @example\n *\n * const curry = f => a => b => f(a, b)\n * const add = (a, b) => a + b\n *\n * const addOne = curry(add)(1)\n *\n * const squareAsync = (num) => {\n *   return new Promise(r => {\n *     setTimeout(r, 500, num * 2)\n *   })\n * }\n *\n * // a -> a + a -> a * 2\n * // basically from right to left: 1 => 1 + 1 => 2 * 2\n * ruit.compose(squareAsync, addOne, 1).then(result => console.log(result)) // 4\n */\nruit.compose = (...tasks) => ruit(...tasks.reverse());\n\n/**\n * Serialize a list of sync and async tasks from left to right\n * @param   { * } tasks - list of tasks to process sequentially\n * @returns { Promise } a promise containing the result of the whole chain\n * @example\n *\n * const curry = f => a => b => f(a, b)\n * const add = (a, b) => a + b\n *\n * const addOne = curry(add)(1)\n *\n * const squareAsync = (num) => {\n *   return new Promise(r => {\n *     setTimeout(r, 500, num * 2)\n *   })\n * }\n *\n * // a -> a + a -> a * 2\n * // basically from left to right: 1 => 1 + 1 => 2 * 2\n * ruit(1, addOne, squareAsync).then(result => console.log(result)) // 4\n */\nfunction ruit(...tasks) {\n  return new Promise((resolve, reject) => {\n    return (function run(queue, result) {\n      if (!queue.length) return resolve(result)\n\n      const [task, ...rest] = queue;\n      const value = typeof task === \'function\' ? task(result) : task;\n      const done = v => run(rest, v);\n\n      // check against nil values\n      if (value != null) {\n        if (value === CANCEL) return\n        if (value.then) return value.then(done, reject)\n      }\n\n      return Promise.resolve(done(value))\n    })(tasks)\n  })\n}\n\n// Store the erre the API methods to handle the plugins installation\nconst API_METHODS = new Set();\nconst UNSUBSCRIBE_SYMBOL = Symbol();\nconst UNSUBSCRIBE_METHOD = \'off\';\nconst CANCEL_METHOD = \'cancel\';\n\n/**\n * Factory function to create the stream generator\n * @private\n * @param {Set} modifiers - stream input modifiers\n * @returns {Generator} the stream generator\n */\nfunction createStream(modifiers) {\n  const stream = (function *stream() {\n    while (true) {\n      // get the initial stream value\n      const input = yield;\n\n      // run the input sequence\n      yield ruit(input, ...modifiers);\n    }\n  })();\n\n  // start the stream\n  stream.next();\n\n  return stream\n}\n\n/**\n * Dispatch a value to several listeners\n * @private\n * @param   {Set} callbacks - callbacks collection\n * @param   {*} value - anything\n * @returns {Set} the callbacks received\n */\nfunction dispatch(callbacks, value) {\n  callbacks.forEach(f => {\n    // unsubscribe the callback if erre.unsubscribe() will be returned\n    if (f(value) === UNSUBSCRIBE_SYMBOL) callbacks.delete(f);\n  });\n\n  return callbacks\n}\n\n/**\n * Throw a panic error\n * @param {string} message - error message\n * @returns {Error} an error object\n */\nfunction panic$1(message) {\n  throw new Error(message)\n}\n\n/**\n * Install an erre plugin adding it to the API\n * @param   {string} name - plugin name\n * @param   {Function} fn - new erre API method\n * @returns {Function} return the erre function\n */\nerre.install = function(name, fn) {\n  if (!name || typeof name !== \'string\')\n    panic$1(\'Please provide a name (as string) for your erre plugin\');\n  if (!fn || typeof fn !== \'function\')\n    panic$1(\'Please provide a function for your erre plugin\');\n\n  if (API_METHODS.has(name)) {\n    panic$1(`The ${name} is already part of the erre API, please provide a different name`);\n  } else {\n    erre[name] = fn;\n    API_METHODS.add(name);\n  }\n\n  return erre\n};\n\n// alias for ruit canel to stop a stream chain\nerre.install(CANCEL_METHOD, ruit.cancel);\n\n// unsubscribe helper\nerre.install(UNSUBSCRIBE_METHOD, () => UNSUBSCRIBE_SYMBOL);\n\n/**\n * Stream constuction function\n * @param   {...Function} fns - stream modifiers\n * @returns {Object} erre instance\n */\nfunction erre(...fns) {\n  const\n    [success, error, end, modifiers] = [new Set(), new Set(), new Set(), new Set(fns)],\n    generator = createStream(modifiers),\n    stream = Object.create(generator),\n    addToCollection = (collection) => (fn) => collection.add(fn) && stream,\n    deleteFromCollection = (collection) => (fn) => collection.delete(fn) ? stream\n      : panic$1(\'Couldn\\\'t remove handler passed by reference\');\n\n  return Object.assign(stream, {\n    on: Object.freeze({\n      value: addToCollection(success),\n      error: addToCollection(error),\n      end: addToCollection(end)\n    }),\n    off: Object.freeze({\n      value: deleteFromCollection(success),\n      error: deleteFromCollection(error),\n      end: deleteFromCollection(end)\n    }),\n    connect: addToCollection(modifiers),\n    push(input) {\n      const { value, done } = stream.next(input);\n\n      // dispatch the stream events\n      if (!done) {\n        value.then(\n          res => dispatch(success, res),\n          err => dispatch(error, err)\n        );\n      }\n\n      return stream\n    },\n    end() {\n      // kill the stream\n      generator.return();\n      // dispatch the end event\n      dispatch(end)\n      // clean up all the collections\n      ;[success, error, end, modifiers].forEach(el => el.clear());\n\n      return stream\n    },\n    fork() {\n      return erre(...modifiers)\n    },\n    next(input) {\n      // get the input and run eventually the promise\n      const result = generator.next(input);\n\n      // pause to the next iteration\n      generator.next();\n\n      return result\n    }\n  })\n}\n\nconst isString = str => typeof str === \'string\';\nconst parseURL = (...args) => new URL(...args);\n\n/**\n * Replace the base path from a path\n * @param   {string} path - router path string\n * @returns {string} path cleaned up without the base\n */\nconst replaceBase = path => path.replace(defaults.base, \'\');\n\n/**\n * Try to match the current path or skip it\n * @param   {RegExp} pathRegExp - target path transformed by pathToRegexp\n * @returns {string|Symbol} if the path match we return it otherwise we cancel the stream\n */\nconst matchOrSkip = pathRegExp => path => match(path, pathRegExp) ? path : erre.cancel();\n\n/**\n * Combine 2 streams connecting the events of dispatcherStream to the receiverStream\n * @param   {Stream} dispatcherStream - main stream dispatching events\n * @param   {Stream} receiverStream - sub stream receiving events from the dispatcher\n * @returns {Stream} receiverStream\n */\nconst joinStreams = (dispatcherStream, receiverStream) => {\n  dispatcherStream.on.value(receiverStream.push);\n\n  receiverStream.on.end(() => {\n    dispatcherStream.off.value(receiverStream.push);\n  });\n\n  return receiverStream\n};\n\n/**\n * Error handling function\n * @param   {Error} error - error to catch\n * @returns {void}\n */\n/* c8 ignore start */\nconst panic$2 = error => {\n  if (defaults.silentErrors) return\n\n  throw new Error(error)\n};\n/* c8 ignore stop */\n\n// make sure that the router will always receive strings params\nconst filterStrings = str => isString(str) ? str : erre.cancel();\n\n// create the streaming router\nconst router = erre(filterStrings).on.error(panic$2); // cast the values of this stream always to string\n\n/**\n * Merge the user options with the defaults\n * @param   {Object} options - custom user options\n * @returns {Object} options object merged with defaults\n */\nconst mergeOptions = options => ({...defaults, ...options});\n\n/* @type {object} general configuration object */\nconst defaults = {\n  base: \'https://localhost\',\n  silentErrors: false,\n  // pathToRegexp options\n  sensitive: false,\n  strict: false,\n  end: true,\n  start: true,\n  delimiter: \'/#?\',\n  encode: undefined,\n  endsWith: undefined,\n  prefixes: \'./\'\n};\n\n/**\n * Configure the router options overriding the defaults\n * @param {Object} options - custom user options to override\n * @returns {Object} new defaults\n */\nconst configure = (options) => {\n  Object.entries(options).forEach(([key, value]) => {\n    if (Object.hasOwn(defaults, key)) defaults[key] = value;\n  });\n\n  return defaults\n};\n\n\n\n/* {@link https://github.com/pillarjs/path-to-regexp#usage} */\nconst toRegexp = (path, keys, options) => pathToRegexp(path, keys, mergeOptions(options));\n\n/**\n * Convert a router entry to a real path computing the url parameters\n * @param   {string} path - router path string\n * @param   {Object} params - named matched parameters\n * @param   {Object} options - pathToRegexp options object\n * @returns {string} computed url string\n */\nconst toPath = (path, params, options) => compile(path, mergeOptions(options))(params);\n\n/**\n * Parse a string path generating an object containing\n * @param   {string} path - target path\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @param   {Object} options - object containing the base path\n * @returns {URL} url object enhanced with the `match` attribute\n */\nconst toURL = (path, pathRegExp, options = {}) => {\n  const {base} = mergeOptions(options);\n  const [, ...params] = pathRegExp.exec(path);\n  const url = parseURL(path, base);\n\n  // extend the url object adding the matched params\n  url.params = params.reduce((acc, param, index) => {\n    const key = options.keys && options.keys[index];\n    if (key) acc[key.name] = param ? decodeURIComponent(param) : param;\n    return acc\n  }, {});\n\n  return url\n};\n\n/**\n * Return true if a path will be matched\n * @param   {string} path - target path\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @returns {boolean} true if the path matches the regexp\n */\nconst match = (path, pathRegExp) => pathRegExp.test(path);\n\n/**\n * Factory function to create an sequence of functions to pass to erre.js\n * This function will be used in the erre stream\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @param   {Object} options - pathToRegexp options object\n * @returns {Array} a functions array that will be used as stream pipe for erre.js\n */\nconst createURLStreamPipe = (pathRegExp, options) => [\n  decodeURI,\n  replaceBase,\n  matchOrSkip(pathRegExp),\n  path => toURL(path, pathRegExp, options)\n];\n\n/**\n * Create a fork of the main router stream\n * @param   {string} path - route to match\n * @param   {Object} options - pathToRegexp options object\n * @returns {Stream} new route stream\n */\nfunction createRoute(path, options) {\n  const keys = [];\n  const pathRegExp = pathToRegexp(path, keys, options);\n  const URLStream = erre(...createURLStreamPipe(pathRegExp, {\n    ...options,\n    keys\n  }));\n\n  return joinStreams(router, URLStream).on.error(panic$2)\n}\n\nconst WINDOW_EVENTS = \'popstate\';\nconst CLICK_EVENT = \'click\';\nconst DOWNLOAD_LINK_ATTRIBUTE = \'download\';\nconst HREF_LINK_ATTRIBUTE = \'href\';\nconst TARGET_SELF_LINK_ATTRIBUTE = \'_self\';\nconst LINK_TAG_NAME = \'A\';\nconst HASH = \'#\';\nconst SLASH = \'/\';\nconst PATH_ATTRIBUTE = \'path\';\nconst RE_ORIGIN = /^.+?\\/\\/+[^/]+/;\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === \'number\'\n    )\n      return Array.from(els)\n    else\n      // if it\'s a single node\n      // it will be returned as "array" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === \'string\' ?\n    (document).querySelectorAll(selector) :\n    selector\n  )\n}\n\nconst getCurrentRoute = ((currentRoute) => {\n  // listen the route changes events to store the current route\n  router.on.value((r) => (currentRoute = r));\n\n  return () => {\n    return currentRoute\n  }\n})(null);\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values;\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === \'string\' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from \'bianco.attr\'\n *\n * const img = document.createElement(\'img\')\n *\n * get(img, \'width\') // => \'200\'\n *\n * // or also\n * get(img, [\'width\', \'height\']) // => [\'200\', \'300\']\n *\n * // or also\n * get([img1, img2], [\'width\', \'height\']) // => [[\'200\', \'300\'], [\'500\', \'200\']]\n */\nfunction get(els, name) {\n  return parseNodes(els, name, \'getAttribute\')\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to detect\n * @returns { boolean|Array } true or false or an array of boolean values\n * @example\n *\n * import { has } from \'bianco.attr\'\n *\n * has(img, \'width\') // false\n *\n * // or also\n * has(img, [\'width\', \'height\']) // => [false, false]\n *\n * // or also\n * has([img1, img2], [\'width\', \'height\']) // => [[false, false], [false, false]]\n */\nfunction has(els, name) {\n  return parseNodes(els, name, \'hasAttribute\')\n}\n\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the \'undefined\' and \'null\' types\n */\nfunction isNil(value) {\n  return value === null || value === undefined\n}\n\nconst getGlobal = () => getWindow() || global;\nconst getWindow = () => (typeof window === \'undefined\' ? null : window);\nconst getDocument = () =>\n  typeof document === \'undefined\' ? null : document;\nconst getHistory = () =>\n  typeof history === \'undefined\' ? null : history;\nconst getLocation = () => {\n  const win = getWindow();\n  return win ? win.location : {}\n};\n\nconst defer = (() => {\n  const globalScope = getGlobal();\n\n  return globalScope.requestAnimationFrame || globalScope.setTimeout\n})();\n\nconst cancelDefer = (() => {\n  const globalScope = getGlobal();\n\n  return globalScope.cancelAnimationFrame || globalScope.clearTimeout\n})();\n\nconst getAttribute = (attributes, name, context) => {\n  if (!attributes) return null\n\n  const normalizedAttributes = attributes.flatMap((attr) =>\n    isNil(attr.name)\n      ? // add support for spread attributes https://github.com/riot/route/issues/178\n        Object.entries(attr.evaluate(context)).map(([key, value]) => ({\n          // evaluate each value of the spread attribute and store it into the array\n          name: key,\n          // create a nested evaluate function pointing to the original value of the spread object\n          evaluate: () => value,\n        }))\n      : attr,\n  );\n\n  return normalizedAttributes.find((a) => dashToCamelCase(a.name) === name)\n};\n\nconst createDefaultSlot = (attributes = []) => {\n  const { template, bindingTypes, expressionTypes } = riot__WEBPACK_IMPORTED_MODULE_1__.__.DOMBindings;\n\n  return template(null, [\n    {\n      type: bindingTypes.SLOT,\n      name: \'default\',\n      attributes: attributes.map((attr) => ({\n        ...attr,\n        type: expressionTypes.ATTRIBUTE,\n      })),\n    },\n  ])\n};\n\n// True if the selector string is valid\nconst isValidQuerySelectorString = (selector) =>\n  /^([a-zA-Z0-9-_*#.:[\\]\\s>+~()=\'"]|\\\\.)+$/.test(selector);\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nfunction compose(...fns) {\n  return fns.reduce((f, g) => (...args) => f(g(...args)))\n}\n\nconst getInitialRouteValue = (pathToRegexp, path, options) => {\n  const route = compose(\n    ...createURLStreamPipe(pathToRegexp, options).reverse(),\n  )(path);\n\n  return route.params ? route : null\n};\n\nconst clearDOMBetweenNodes = (first, last, includeBoundaries) => {\n  const clear = (node) => {\n    if (!node || (node === last && !includeBoundaries)) return\n    const { nextSibling } = node;\n    node.remove();\n    clear(nextSibling);\n  };\n\n  clear(includeBoundaries ? first : first.nextSibling);\n};\n\nconst routeHoc$1 = ({ slots, attributes }) => {\n  const placeholders = {\n    before: document.createTextNode(\'\'),\n    after: document.createTextNode(\'\'),\n  };\n\n  return {\n    mount(el, context) {\n      // create the component state\n      const currentRoute = getCurrentRoute();\n      const path =\n        getAttribute(attributes, PATH_ATTRIBUTE, context)?.evaluate(context) ||\n        get(el, PATH_ATTRIBUTE);\n      const pathToRegexp = toRegexp(path, []);\n      const state = {\n        pathToRegexp,\n        route:\n          currentRoute && match(currentRoute, pathToRegexp)\n            ? getInitialRouteValue(pathToRegexp, currentRoute, {})\n            : null,\n      };\n      this.el = el;\n      this.slot = createDefaultSlot([\n        {\n          isBoolean: false,\n          name: \'route\',\n          evaluate: () => this.state.route,\n        },\n      ]);\n      this.context = context;\n      this.state = state;\n      // set the route listeners\n      this.boundOnBeforeRoute = this.onBeforeRoute.bind(this);\n      this.boundOnRoute = this.onRoute.bind(this);\n      router.on.value(this.boundOnBeforeRoute);\n      this.stream = createRoute(path).on.value(this.boundOnRoute);\n      // update the DOM\n      el.replaceWith(placeholders.before);\n      placeholders.before.parentNode.insertBefore(\n        placeholders.after,\n        placeholders.before.nextSibling,\n      );\n      if (state.route) this.mountSlot();\n    },\n    update(context) {\n      this.context = context;\n      if (this.state.route) this.slot.update({}, context);\n    },\n    mountSlot() {\n      const { route } = this.state;\n      // insert the route root element after the before placeholder\n      placeholders.before.parentNode.insertBefore(\n        this.el,\n        placeholders.before.nextSibling,\n      );\n      this.callLifecycleProperty(\'onBeforeMount\', route);\n      this.slot.mount(\n        this.el,\n        {\n          slots,\n        },\n        this.context,\n      );\n      this.callLifecycleProperty(\'onMounted\', route);\n    },\n    clearDOM(includeBoundaries) {\n      // remove all the DOM nodes between the placeholders\n      clearDOMBetweenNodes(\n        placeholders.before,\n        placeholders.after,\n        includeBoundaries,\n      );\n    },\n    unmount() {\n      router.off.value(this.boundOnBeforeRoute);\n      this.slot.unmount({}, this.context, true);\n      this.clearDOM(true);\n      this.stream.end();\n    },\n    onBeforeRoute(path) {\n      const { route } = this.state;\n      // this component was not mounted or the current path matches\n      // we don\'t need to unmount this component\n      if (!route || match(path, this.state.pathToRegexp)) return\n\n      this.callLifecycleProperty(\'onBeforeUnmount\', route);\n      this.slot.unmount({}, this.context, true);\n      this.clearDOM(false);\n      this.state.route = null;\n      this.callLifecycleProperty(\'onUnmounted\', route);\n    },\n    onRoute(route) {\n      const prevRoute = this.state.route;\n      this.state.route = route;\n\n      // if this route component was already mounted we need to update it\n      if (prevRoute) {\n        this.callLifecycleProperty(\'onBeforeUpdate\', route);\n        this.slot.update({}, this.context);\n        this.callLifecycleProperty(\'onUpdated\', route);\n      }\n      // this route component was never mounted, so we need to create its DOM\n      else this.mountSlot();\n\n      // emulate the default browser anchor links behaviour\n      if (route.hash && isValidQuerySelectorString(route.hash))\n        $(route.hash)?.[0].scrollIntoView();\n    },\n    callLifecycleProperty(method, ...params) {\n      const attr = getAttribute(attributes, method, this.context);\n\n      if (attr) attr.evaluate(this.context)(...params);\n    },\n  }\n};\n\nvar routeHoc = {\n  css: null,\n\n  exports: (0,riot__WEBPACK_IMPORTED_MODULE_0__/* .pure */ .L)(\n    routeHoc$1\n  ),\n\n  template: null,\n  name: \'route-hoc\'\n};\n\nconst normalizeInitialSlash = (str) =>\n  str[0] === SLASH ? str : `${SLASH}${str}`;\nconst removeTrailingSlash = (str) =>\n  str[str.length - 1] === SLASH ? str.substr(0, str.length - 1) : str;\n\nconst normalizeBase = (base) => {\n  const win = getWindow();\n  const loc = win.location;\n  const root = loc ? `${loc.protocol}//${loc.host}` : \'\';\n  const { pathname } = loc ? loc : {};\n\n  switch (true) {\n    // pure root url + pathname\n    case Boolean(base) === false:\n      return removeTrailingSlash(`${root}${pathname || \'\'}`)\n    // full path base\n    case /(www|http(s)?:)/.test(base):\n      return base\n    // hash navigation\n    case base[0] === HASH:\n      return `${root}${pathname && pathname !== SLASH ? pathname : \'\'}${base}`\n    // root url with trailing slash\n    case base === SLASH:\n      return removeTrailingSlash(root)\n    // custom pathname\n    default:\n      return removeTrailingSlash(`${root}${normalizeInitialSlash(base)}`)\n  }\n};\n\nfunction setBase(base) {\n  configure({ base: normalizeBase(base) });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @param   { string } cause - optional error cause object\n * @returns { undefined } hoppla... at this point the program should stop working\n */\nfunction panic(message, cause) {\n  throw new Error(message, { cause })\n}\n\n/**\n * Split a string into several items separed by spaces\n * @param   { string } l - events list\n * @returns { Array } all the events detected\n * @private\n */\nconst split = l => l.split(/\\s/);\n\n/**\n * Set a listener for all the events received separated by spaces\n * @param   { HTMLElement|NodeList|Array } els     - DOM node/s where the listeners will be bound\n * @param   { string }                     evList  - list of events we want to bind or unbind space separated\n * @param   { Function }                   cb      - listeners callback\n * @param   { string }                     method  - either \'addEventListener\' or \'removeEventListener\'\n * @param   { Object }                     options - event options (capture, once and passive)\n * @returns { undefined }\n * @private\n */\nfunction manageEvents(els, evList, cb, method, options) {\n  els = domToArray(els);\n\n  split(evList).forEach((e) => {\n    els.forEach(el => el[method](e, cb, options || false));\n  });\n}\n\n/**\n * Set a listener for all the events received separated by spaces\n * @param   { HTMLElement|Array } els    - DOM node/s where the listeners will be bound\n * @param   { string }            evList - list of events we want to bind space separated\n * @param   { Function }          cb     - listeners callback\n * @param   { Object }            options - event options (capture, once and passive)\n * @returns { HTMLElement|NodeList|Array } DOM node/s and first argument of the function\n */\nfunction add(els, evList, cb, options) {\n  manageEvents(els, evList, cb, \'addEventListener\', options);\n  return els\n}\n\n/**\n * Remove all the listeners for the events received separated by spaces\n * @param   { HTMLElement|Array } els     - DOM node/s where the events will be unbind\n * @param   { string }            evList  - list of events we want unbind space separated\n * @param   { Function }          cb      - listeners callback\n * @param   { Object }             options - event options (capture, once and passive)\n * @returns { HTMLElement|NodeList|Array }  DOM node/s and first argument of the function\n */\nfunction remove(els, evList, cb, options) {\n  manageEvents(els, evList, cb, \'removeEventListener\', options);\n  return els\n}\n\nconst onWindowEvent = () =>\n  router.push(normalizePath(String(getLocation().href)));\nconst onRouterPush = (path) => {\n  const url = path.includes(defaults.base) ? path : defaults.base + path;\n  const loc = getLocation();\n  const hist = getHistory();\n  const doc = getDocument();\n\n  // update the browser history only if it\'s necessary\n  if (hist && url !== loc.href) {\n    hist.pushState(null, doc.title, url);\n  }\n};\nconst getLinkElement = (node) =>\n  node && !isLinkNode(node) ? getLinkElement(node.parentNode) : node;\nconst isLinkNode = (node) => node.nodeName === LINK_TAG_NAME;\nconst isCrossOriginLink = (path) =>\n  path.indexOf(getLocation().href.match(RE_ORIGIN)[0]) === -1;\nconst isTargetSelfLink = (el) =>\n  el.target && el.target !== TARGET_SELF_LINK_ATTRIBUTE;\nconst isEventForbidden = (event) =>\n  (event.which && event.which !== 1) || // not left click\n  event.metaKey ||\n  event.ctrlKey ||\n  event.shiftKey || // or meta keys\n  event.defaultPrevented; // or default prevented\nconst isForbiddenLink = (el) =>\n  !el ||\n  !isLinkNode(el) || // not A tag\n  has(el, DOWNLOAD_LINK_ATTRIBUTE) || // has download attr\n  !has(el, HREF_LINK_ATTRIBUTE) || // has no href attr\n  isTargetSelfLink(el) ||\n  isCrossOriginLink(el.href);\nconst normalizePath = (path) => path.replace(defaults.base, \'\');\nconst isInBase = (path) => !defaults.base || path.includes(defaults.base);\n\n/**\n * Callback called anytime something will be clicked on the page\n * @param   {Event} event - click event\n * @returns {undefined} void method\n */\nconst onClick = (event) => {\n  if (isEventForbidden(event)) return\n\n  const el = getLinkElement(event.target);\n\n  if (isForbiddenLink(el) || !isInBase(el.href)) return\n\n  event.preventDefault();\n\n  router.push(normalizePath(el.href));\n};\n\n/**\n * Link the rawth router to the DOM events\n * @param { HTMLElement } container - DOM node where the links are located\n * @returns {Function} teardown function\n */\nfunction initDomListeners(container) {\n  const win = getWindow();\n  const root = container || getDocument();\n\n  if (win) {\n    add(win, WINDOW_EVENTS, onWindowEvent);\n    add(root, CLICK_EVENT, onClick);\n  }\n\n  router.on.value(onRouterPush);\n\n  return () => {\n    if (win) {\n      remove(win, WINDOW_EVENTS, onWindowEvent);\n      remove(root, CLICK_EVENT, onClick);\n    }\n\n    router.off.value(onRouterPush);\n  }\n}\n\nconst BASE_ATTRIBUTE_NAME = \'base\';\nconst INITIAL_ROUTE = \'initialRoute\';\nconst ON_STARTED_ATTRIBUTE_NAME = \'onStarted\';\n\nconst routerHoc$1 = ({ slots, attributes, props }) => {\n  if (routerHoc$1.wasInitialized)\n    panic(\'Multiple <router> components are not supported\');\n\n  return {\n    slot: null,\n    el: null,\n    teardown: null,\n    mount(el, context) {\n      const initialRouteAttr = getAttribute(attributes, INITIAL_ROUTE, context);\n      const initialRoute = initialRouteAttr\n        ? initialRouteAttr.evaluate(context)\n        : null;\n      const currentRoute = getCurrentRoute();\n      const onFirstRoute = () => {\n        this.createSlot(context);\n        router.off.value(onFirstRoute);\n      };\n      routerHoc$1.wasInitialized = true;\n\n      this.el = el;\n      this.teardown = initDomListeners(this.root);\n\n      this.setBase(context);\n\n      // mount the slots only if the current route was defined\n      if (currentRoute && !initialRoute) {\n        this.createSlot(context);\n      } else {\n        router.on.value(onFirstRoute);\n        router.push(initialRoute || window.location.href);\n      }\n    },\n    createSlot(context) {\n      if (!slots || !slots.length) return\n      const onStartedAttr = getAttribute(\n        attributes,\n        ON_STARTED_ATTRIBUTE_NAME,\n        context,\n      );\n\n      this.slot = createDefaultSlot();\n\n      this.slot.mount(\n        this.el,\n        {\n          slots,\n        },\n        context,\n      );\n\n      if (onStartedAttr) {\n        onStartedAttr.evaluate(context)(getCurrentRoute());\n      }\n    },\n    update(context) {\n      this.setBase(context);\n\n      // defer the updates to avoid internal recursive update calls\n      // see https://github.com/riot/route/issues/148\n      if (this.slot) {\n        cancelDefer(this.deferred);\n\n        this.deferred = defer(() => {\n          this.slot.update({}, context);\n        });\n      }\n    },\n    unmount(...args) {\n      this.teardown();\n      routerHoc$1.wasInitialized = false;\n\n      if (this.slot) {\n        this.slot.unmount(...args);\n      }\n    },\n    getBase(context) {\n      const baseAttr = getAttribute(attributes, BASE_ATTRIBUTE_NAME, context);\n\n      return baseAttr\n        ? baseAttr.evaluate(context)\n        : this.el.getAttribute(BASE_ATTRIBUTE_NAME) || \'/\'\n    },\n    setBase(context) {\n      setBase(props ? props.base : this.getBase(context));\n    },\n  }\n};\n\n// flag to avoid multiple router instances\nrouterHoc$1.wasInitialized = false;\n\nvar routerHoc = {\n  css: null,\n\n  exports: (0,riot__WEBPACK_IMPORTED_MODULE_0__/* .pure */ .L)(\n    routerHoc$1\n  ),\n\n  template: null,\n  name: \'router-hoc\'\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByaW90anMvcm91dGUvaW5kZXguanM/NmEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfXywgcHVyZSB9IGZyb20gJ3Jpb3QnO1xuXG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIuY29uY2F0KGkpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiLmNvbmNhdChqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIuY29uY2F0KGopKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIuY29uY2F0KGkpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiLmNvbmNhdChpKSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIuY29uY2F0KGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSwgXCJdKz9cIik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChuZXh0VHlwZSwgXCIgYXQgXCIpLmNvbmNhdChpbmRleCwgXCIsIGV4cGVjdGVkIFwiKS5jb25jYXQodHlwZSkpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIi5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpJFwiKSwgcmVGbGFncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHRva2VuLm1vZGlmaWVyID09PSBcIj9cIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCI7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIitcIjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodG9rZW4ubmFtZSwgXCJcXFwiIHRvIG5vdCBiZSBlbXB0eVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiLmNvbmNhdCh0b2tlbi5uYW1lLCBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiKS5jb25jYXQodG9rZW4ucGF0dGVybiwgXCJcXFwiLCBidXQgZ290IFxcXCJcIikuY29uY2F0KHNlZ21lbnQsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiKS5jb25jYXQoc2VnbWVudCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiLmNvbmNhdCh0b2tlbi5uYW1lLCBcIlxcXCIgdG8gYmUgXCIpLmNvbmNhdCh0eXBlT2ZNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbn1cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgdmFyIGdyb3Vwc1JlZ2V4ID0gL1xcKCg/OlxcPzwoLio/KT4pPyg/IVxcPykvZztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBleGVjUmVzdWx0ID0gZ3JvdXBzUmVnZXguZXhlYyhwYXRoLnNvdXJjZSk7XG4gICAgd2hpbGUgKGV4ZWNSZXN1bHQpIHtcbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFVzZSBwYXJlbnRoZXNpemVkIHN1YnN0cmluZyBtYXRjaCBpZiBhdmFpbGFibGUsIGluZGV4IG90aGVyd2lzZVxuICAgICAgICAgICAgbmFtZTogZXhlY1Jlc3VsdFsxXSB8fCBpbmRleCsrLFxuICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICBwYXR0ZXJuOiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgZXhlY1Jlc3VsdCA9IGdyb3Vwc1JlZ2V4LmV4ZWMocGF0aC5zb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIuY29uY2F0KHBhcnRzLmpvaW4oXCJ8XCIpLCBcIilcIiksIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kLCBfZSA9IG9wdGlvbnMuZGVsaW1pdGVyLCBkZWxpbWl0ZXIgPSBfZSA9PT0gdm9pZCAwID8gXCIvIz9cIiA6IF9lLCBfZiA9IG9wdGlvbnMuZW5kc1dpdGgsIGVuZHNXaXRoID0gX2YgPT09IHZvaWQgMCA/IFwiXCIgOiBfZjtcbiAgICB2YXIgZW5kc1dpdGhSZSA9IFwiW1wiLmNvbmNhdChlc2NhcGVTdHJpbmcoZW5kc1dpdGgpLCBcIl18JFwiKTtcbiAgICB2YXIgZGVsaW1pdGVyUmUgPSBcIltcIi5jb25jYXQoZXNjYXBlU3RyaW5nKGRlbGltaXRlciksIFwiXVwiKTtcbiAgICB2YXIgcm91dGUgPSBzdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4ucHJlZml4KSk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5zdWZmaXgpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSBcIitcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2QgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgPyBcIj9cIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiLmNvbmNhdChwcmVmaXgsIFwiKCg/OlwiKS5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpKD86XCIpLmNvbmNhdChzdWZmaXgpLmNvbmNhdChwcmVmaXgsIFwiKD86XCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIikpKilcIikuY29uY2F0KHN1ZmZpeCwgXCIpXCIpLmNvbmNhdChtb2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIi5jb25jYXQocHJlZml4LCBcIihcIikuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiKVwiKS5jb25jYXQoc3VmZml4LCBcIilcIikuY29uY2F0KHRva2VuLm1vZGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSBcIitcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKCg/OlwiLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIilcIikuY29uY2F0KHRva2VuLm1vZGlmaWVyLCBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIihcIi5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpXCIpLmNvbmNhdCh0b2tlbi5tb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChzdWZmaXgsIFwiKVwiKS5jb25jYXQodG9rZW4ubW9kaWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpXG4gICAgICAgICAgICByb3V0ZSArPSBcIlwiLmNvbmNhdChkZWxpbWl0ZXJSZSwgXCI/XCIpO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIi5jb25jYXQoZW5kc1dpdGhSZSwgXCIpXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzRW5kRGVsaW1pdGVkID0gdHlwZW9mIGVuZFRva2VuID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGRlbGltaXRlclJlLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIuY29uY2F0KGRlbGltaXRlclJlLCBcIig/PVwiKS5jb25jYXQoZW5kc1dpdGhSZSwgXCIpKT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VuZERlbGltaXRlZCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPz1cIi5jb25jYXQoZGVsaW1pdGVyUmUsIFwifFwiKS5jb25jYXQoZW5kc1dpdGhSZSwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJvdXRlLCBmbGFncyhvcHRpb25zKSk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENhbmNlbCB0b2tlblxuICogQHByaXZhdGVcbiAqIEB0eXBlIHsgU3ltYm9sIH1cbiAqL1xuY29uc3QgQ0FOQ0VMID0gU3ltYm9sKCk7XG5cbi8qKlxuICogSGVscGVyIHRoYXQgY2FuIGJlIHJldHVybmVkIGJ5IHJ1aXQgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSB0YXNrcyBjaGFpblxuICogQHJldHVybnMgeyBTeW1ib2wgfSBpbnRlcm5hbCBwcml2YXRlIGNvbnN0YW50XG4gKiBAZXhhbXBsZVxuICpcbiAqIHJ1aXQoXG4gKiAgIDEwMCxcbiAqICAgbnVtID0+IE1hdGgucmFuZG9tKCkgKiBudW1cbiAqICAgbnVtID0+IG51bSA+IDUwID8gcnVpdC5jYW5jZWwoKSA6IG51bVxuICogICBudW0gPT4gbnVtIC0gMlxuICogKS50aGVuKHJlc3VsdCA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCkgLy8gaGVyZSB3ZSB3aWxsIGdldCBvbmx5IG51bWJlciBsb3dlciB0aGFuIDUwXG4gKiB9KVxuICpcbiAqL1xucnVpdC5jYW5jZWwgPSAoKSA9PiBDQU5DRUw7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgcnVpdCgpIGJ1dCB3aXRoIHRoZSBhcmd1bWVudHMgaW52ZXJ0ZWQgZnJvbSByaWdodCB0byBsZWZ0XG4gKiBAcGFyYW0gICB7ICogfSB0YXNrcyAtIGxpc3Qgb2YgdGFza3MgdG8gcHJvY2VzcyBzZXF1ZW50aWFsbHlcbiAqIEByZXR1cm5zIHsgUHJvbWlzZSB9IGEgcHJvbWlzZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgdGhlIHdob2xlIGNoYWluXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGN1cnJ5ID0gZiA9PiBhID0+IGIgPT4gZihhLCBiKVxuICogY29uc3QgYWRkID0gKGEsIGIpID0+IGEgKyBiXG4gKlxuICogY29uc3QgYWRkT25lID0gY3VycnkoYWRkKSgxKVxuICpcbiAqIGNvbnN0IHNxdWFyZUFzeW5jID0gKG51bSkgPT4ge1xuICogICByZXR1cm4gbmV3IFByb21pc2UociA9PiB7XG4gKiAgICAgc2V0VGltZW91dChyLCA1MDAsIG51bSAqIDIpXG4gKiAgIH0pXG4gKiB9XG4gKlxuICogLy8gYSAtPiBhICsgYSAtPiBhICogMlxuICogLy8gYmFzaWNhbGx5IGZyb20gcmlnaHQgdG8gbGVmdDogMSA9PiAxICsgMSA9PiAyICogMlxuICogcnVpdC5jb21wb3NlKHNxdWFyZUFzeW5jLCBhZGRPbmUsIDEpLnRoZW4ocmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdCkpIC8vIDRcbiAqL1xucnVpdC5jb21wb3NlID0gKC4uLnRhc2tzKSA9PiBydWl0KC4uLnRhc2tzLnJldmVyc2UoKSk7XG5cbi8qKlxuICogU2VyaWFsaXplIGEgbGlzdCBvZiBzeW5jIGFuZCBhc3luYyB0YXNrcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAqIEBwYXJhbSAgIHsgKiB9IHRhc2tzIC0gbGlzdCBvZiB0YXNrcyB0byBwcm9jZXNzIHNlcXVlbnRpYWxseVxuICogQHJldHVybnMgeyBQcm9taXNlIH0gYSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgd2hvbGUgY2hhaW5cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgY3VycnkgPSBmID0+IGEgPT4gYiA9PiBmKGEsIGIpXG4gKiBjb25zdCBhZGQgPSAoYSwgYikgPT4gYSArIGJcbiAqXG4gKiBjb25zdCBhZGRPbmUgPSBjdXJyeShhZGQpKDEpXG4gKlxuICogY29uc3Qgc3F1YXJlQXN5bmMgPSAobnVtKSA9PiB7XG4gKiAgIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHtcbiAqICAgICBzZXRUaW1lb3V0KHIsIDUwMCwgbnVtICogMilcbiAqICAgfSlcbiAqIH1cbiAqXG4gKiAvLyBhIC0+IGEgKyBhIC0+IGEgKiAyXG4gKiAvLyBiYXNpY2FsbHkgZnJvbSBsZWZ0IHRvIHJpZ2h0OiAxID0+IDEgKyAxID0+IDIgKiAyXG4gKiBydWl0KDEsIGFkZE9uZSwgc3F1YXJlQXN5bmMpLnRoZW4ocmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdCkpIC8vIDRcbiAqL1xuZnVuY3Rpb24gcnVpdCguLi50YXNrcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJldHVybiAoZnVuY3Rpb24gcnVuKHF1ZXVlLCByZXN1bHQpIHtcbiAgICAgIGlmICghcXVldWUubGVuZ3RoKSByZXR1cm4gcmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgIGNvbnN0IFt0YXNrLCAuLi5yZXN0XSA9IHF1ZXVlO1xuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHRhc2socmVzdWx0KSA6IHRhc2s7XG4gICAgICBjb25zdCBkb25lID0gdiA9PiBydW4ocmVzdCwgdik7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluc3QgbmlsIHZhbHVlc1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBDQU5DRUwpIHJldHVyblxuICAgICAgICBpZiAodmFsdWUudGhlbikgcmV0dXJuIHZhbHVlLnRoZW4oZG9uZSwgcmVqZWN0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRvbmUodmFsdWUpKVxuICAgIH0pKHRhc2tzKVxuICB9KVxufVxuXG4vLyBTdG9yZSB0aGUgZXJyZSB0aGUgQVBJIG1ldGhvZHMgdG8gaGFuZGxlIHRoZSBwbHVnaW5zIGluc3RhbGxhdGlvblxuY29uc3QgQVBJX01FVEhPRFMgPSBuZXcgU2V0KCk7XG5jb25zdCBVTlNVQlNDUklCRV9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IFVOU1VCU0NSSUJFX01FVEhPRCA9ICdvZmYnO1xuY29uc3QgQ0FOQ0VMX01FVEhPRCA9ICdjYW5jZWwnO1xuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzdHJlYW0gZ2VuZXJhdG9yXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTZXR9IG1vZGlmaWVycyAtIHN0cmVhbSBpbnB1dCBtb2RpZmllcnNcbiAqIEByZXR1cm5zIHtHZW5lcmF0b3J9IHRoZSBzdHJlYW0gZ2VuZXJhdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbShtb2RpZmllcnMpIHtcbiAgY29uc3Qgc3RyZWFtID0gKGZ1bmN0aW9uICpzdHJlYW0oKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIGdldCB0aGUgaW5pdGlhbCBzdHJlYW0gdmFsdWVcbiAgICAgIGNvbnN0IGlucHV0ID0geWllbGQ7XG5cbiAgICAgIC8vIHJ1biB0aGUgaW5wdXQgc2VxdWVuY2VcbiAgICAgIHlpZWxkIHJ1aXQoaW5wdXQsIC4uLm1vZGlmaWVycyk7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8vIHN0YXJ0IHRoZSBzdHJlYW1cbiAgc3RyZWFtLm5leHQoKTtcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSB2YWx1ZSB0byBzZXZlcmFsIGxpc3RlbmVyc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtTZXR9IGNhbGxiYWNrcyAtIGNhbGxiYWNrcyBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSBhbnl0aGluZ1xuICogQHJldHVybnMge1NldH0gdGhlIGNhbGxiYWNrcyByZWNlaXZlZFxuICovXG5mdW5jdGlvbiBkaXNwYXRjaChjYWxsYmFja3MsIHZhbHVlKSB7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGYgPT4ge1xuICAgIC8vIHVuc3Vic2NyaWJlIHRoZSBjYWxsYmFjayBpZiBlcnJlLnVuc3Vic2NyaWJlKCkgd2lsbCBiZSByZXR1cm5lZFxuICAgIGlmIChmKHZhbHVlKSA9PT0gVU5TVUJTQ1JJQkVfU1lNQk9MKSBjYWxsYmFja3MuZGVsZXRlKGYpO1xuICB9KTtcblxuICByZXR1cm4gY2FsbGJhY2tzXG59XG5cbi8qKlxuICogVGhyb3cgYSBwYW5pYyBlcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RXJyb3J9IGFuIGVycm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYW5pYyQxKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogSW5zdGFsbCBhbiBlcnJlIHBsdWdpbiBhZGRpbmcgaXQgdG8gdGhlIEFQSVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZSAtIHBsdWdpbiBuYW1lXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IGZuIC0gbmV3IGVycmUgQVBJIG1ldGhvZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSByZXR1cm4gdGhlIGVycmUgZnVuY3Rpb25cbiAqL1xuZXJyZS5pbnN0YWxsID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgaWYgKCFuYW1lIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJylcbiAgICBwYW5pYyQxKCdQbGVhc2UgcHJvdmlkZSBhIG5hbWUgKGFzIHN0cmluZykgZm9yIHlvdXIgZXJyZSBwbHVnaW4nKTtcbiAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgcGFuaWMkMSgnUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiBmb3IgeW91ciBlcnJlIHBsdWdpbicpO1xuXG4gIGlmIChBUElfTUVUSE9EUy5oYXMobmFtZSkpIHtcbiAgICBwYW5pYyQxKGBUaGUgJHtuYW1lfSBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGVycmUgQVBJLCBwbGVhc2UgcHJvdmlkZSBhIGRpZmZlcmVudCBuYW1lYCk7XG4gIH0gZWxzZSB7XG4gICAgZXJyZVtuYW1lXSA9IGZuO1xuICAgIEFQSV9NRVRIT0RTLmFkZChuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBlcnJlXG59O1xuXG4vLyBhbGlhcyBmb3IgcnVpdCBjYW5lbCB0byBzdG9wIGEgc3RyZWFtIGNoYWluXG5lcnJlLmluc3RhbGwoQ0FOQ0VMX01FVEhPRCwgcnVpdC5jYW5jZWwpO1xuXG4vLyB1bnN1YnNjcmliZSBoZWxwZXJcbmVycmUuaW5zdGFsbChVTlNVQlNDUklCRV9NRVRIT0QsICgpID0+IFVOU1VCU0NSSUJFX1NZTUJPTCk7XG5cbi8qKlxuICogU3RyZWFtIGNvbnN0dWN0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7Li4uRnVuY3Rpb259IGZucyAtIHN0cmVhbSBtb2RpZmllcnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGVycmUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXJyZSguLi5mbnMpIHtcbiAgY29uc3RcbiAgICBbc3VjY2VzcywgZXJyb3IsIGVuZCwgbW9kaWZpZXJzXSA9IFtuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KGZucyldLFxuICAgIGdlbmVyYXRvciA9IGNyZWF0ZVN0cmVhbShtb2RpZmllcnMpLFxuICAgIHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoZ2VuZXJhdG9yKSxcbiAgICBhZGRUb0NvbGxlY3Rpb24gPSAoY29sbGVjdGlvbikgPT4gKGZuKSA9PiBjb2xsZWN0aW9uLmFkZChmbikgJiYgc3RyZWFtLFxuICAgIGRlbGV0ZUZyb21Db2xsZWN0aW9uID0gKGNvbGxlY3Rpb24pID0+IChmbikgPT4gY29sbGVjdGlvbi5kZWxldGUoZm4pID8gc3RyZWFtXG4gICAgICA6IHBhbmljJDEoJ0NvdWxkblxcJ3QgcmVtb3ZlIGhhbmRsZXIgcGFzc2VkIGJ5IHJlZmVyZW5jZScpO1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHN0cmVhbSwge1xuICAgIG9uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgIHZhbHVlOiBhZGRUb0NvbGxlY3Rpb24oc3VjY2VzcyksXG4gICAgICBlcnJvcjogYWRkVG9Db2xsZWN0aW9uKGVycm9yKSxcbiAgICAgIGVuZDogYWRkVG9Db2xsZWN0aW9uKGVuZClcbiAgICB9KSxcbiAgICBvZmY6IE9iamVjdC5mcmVlemUoe1xuICAgICAgdmFsdWU6IGRlbGV0ZUZyb21Db2xsZWN0aW9uKHN1Y2Nlc3MpLFxuICAgICAgZXJyb3I6IGRlbGV0ZUZyb21Db2xsZWN0aW9uKGVycm9yKSxcbiAgICAgIGVuZDogZGVsZXRlRnJvbUNvbGxlY3Rpb24oZW5kKVxuICAgIH0pLFxuICAgIGNvbm5lY3Q6IGFkZFRvQ29sbGVjdGlvbihtb2RpZmllcnMpLFxuICAgIHB1c2goaW5wdXQpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IHN0cmVhbS5uZXh0KGlucHV0KTtcblxuICAgICAgLy8gZGlzcGF0Y2ggdGhlIHN0cmVhbSBldmVudHNcbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICB2YWx1ZS50aGVuKFxuICAgICAgICAgIHJlcyA9PiBkaXNwYXRjaChzdWNjZXNzLCByZXMpLFxuICAgICAgICAgIGVyciA9PiBkaXNwYXRjaChlcnJvciwgZXJyKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyZWFtXG4gICAgfSxcbiAgICBlbmQoKSB7XG4gICAgICAvLyBraWxsIHRoZSBzdHJlYW1cbiAgICAgIGdlbmVyYXRvci5yZXR1cm4oKTtcbiAgICAgIC8vIGRpc3BhdGNoIHRoZSBlbmQgZXZlbnRcbiAgICAgIGRpc3BhdGNoKGVuZClcbiAgICAgIC8vIGNsZWFuIHVwIGFsbCB0aGUgY29sbGVjdGlvbnNcbiAgICAgIDtbc3VjY2VzcywgZXJyb3IsIGVuZCwgbW9kaWZpZXJzXS5mb3JFYWNoKGVsID0+IGVsLmNsZWFyKCkpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtXG4gICAgfSxcbiAgICBmb3JrKCkge1xuICAgICAgcmV0dXJuIGVycmUoLi4ubW9kaWZpZXJzKVxuICAgIH0sXG4gICAgbmV4dChpbnB1dCkge1xuICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBhbmQgcnVuIGV2ZW50dWFsbHkgdGhlIHByb21pc2VcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KGlucHV0KTtcblxuICAgICAgLy8gcGF1c2UgdG8gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICBnZW5lcmF0b3IubmV4dCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBpc1N0cmluZyA9IHN0ciA9PiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJztcbmNvbnN0IHBhcnNlVVJMID0gKC4uLmFyZ3MpID0+IG5ldyBVUkwoLi4uYXJncyk7XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgYmFzZSBwYXRoIGZyb20gYSBwYXRoXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoIC0gcm91dGVyIHBhdGggc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwYXRoIGNsZWFuZWQgdXAgd2l0aG91dCB0aGUgYmFzZVxuICovXG5jb25zdCByZXBsYWNlQmFzZSA9IHBhdGggPT4gcGF0aC5yZXBsYWNlKGRlZmF1bHRzLmJhc2UsICcnKTtcblxuLyoqXG4gKiBUcnkgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgcGF0aCBvciBza2lwIGl0XG4gKiBAcGFyYW0gICB7UmVnRXhwfSBwYXRoUmVnRXhwIC0gdGFyZ2V0IHBhdGggdHJhbnNmb3JtZWQgYnkgcGF0aFRvUmVnZXhwXG4gKiBAcmV0dXJucyB7c3RyaW5nfFN5bWJvbH0gaWYgdGhlIHBhdGggbWF0Y2ggd2UgcmV0dXJuIGl0IG90aGVyd2lzZSB3ZSBjYW5jZWwgdGhlIHN0cmVhbVxuICovXG5jb25zdCBtYXRjaE9yU2tpcCA9IHBhdGhSZWdFeHAgPT4gcGF0aCA9PiBtYXRjaChwYXRoLCBwYXRoUmVnRXhwKSA/IHBhdGggOiBlcnJlLmNhbmNlbCgpO1xuXG4vKipcbiAqIENvbWJpbmUgMiBzdHJlYW1zIGNvbm5lY3RpbmcgdGhlIGV2ZW50cyBvZiBkaXNwYXRjaGVyU3RyZWFtIHRvIHRoZSByZWNlaXZlclN0cmVhbVxuICogQHBhcmFtICAge1N0cmVhbX0gZGlzcGF0Y2hlclN0cmVhbSAtIG1haW4gc3RyZWFtIGRpc3BhdGNoaW5nIGV2ZW50c1xuICogQHBhcmFtICAge1N0cmVhbX0gcmVjZWl2ZXJTdHJlYW0gLSBzdWIgc3RyZWFtIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgZGlzcGF0Y2hlclxuICogQHJldHVybnMge1N0cmVhbX0gcmVjZWl2ZXJTdHJlYW1cbiAqL1xuY29uc3Qgam9pblN0cmVhbXMgPSAoZGlzcGF0Y2hlclN0cmVhbSwgcmVjZWl2ZXJTdHJlYW0pID0+IHtcbiAgZGlzcGF0Y2hlclN0cmVhbS5vbi52YWx1ZShyZWNlaXZlclN0cmVhbS5wdXNoKTtcblxuICByZWNlaXZlclN0cmVhbS5vbi5lbmQoKCkgPT4ge1xuICAgIGRpc3BhdGNoZXJTdHJlYW0ub2ZmLnZhbHVlKHJlY2VpdmVyU3RyZWFtLnB1c2gpO1xuICB9KTtcblxuICByZXR1cm4gcmVjZWl2ZXJTdHJlYW1cbn07XG5cbi8qKlxuICogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtFcnJvcn0gZXJyb3IgLSBlcnJvciB0byBjYXRjaFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgcGFuaWMkMiA9IGVycm9yID0+IHtcbiAgaWYgKGRlZmF1bHRzLnNpbGVudEVycm9ycykgcmV0dXJuXG5cbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yKVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8vIG1ha2Ugc3VyZSB0aGF0IHRoZSByb3V0ZXIgd2lsbCBhbHdheXMgcmVjZWl2ZSBzdHJpbmdzIHBhcmFtc1xuY29uc3QgZmlsdGVyU3RyaW5ncyA9IHN0ciA9PiBpc1N0cmluZyhzdHIpID8gc3RyIDogZXJyZS5jYW5jZWwoKTtcblxuLy8gY3JlYXRlIHRoZSBzdHJlYW1pbmcgcm91dGVyXG5jb25zdCByb3V0ZXIgPSBlcnJlKGZpbHRlclN0cmluZ3MpLm9uLmVycm9yKHBhbmljJDIpOyAvLyBjYXN0IHRoZSB2YWx1ZXMgb2YgdGhpcyBzdHJlYW0gYWx3YXlzIHRvIHN0cmluZ1xuXG4vKipcbiAqIE1lcmdlIHRoZSB1c2VyIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdHNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMgLSBjdXN0b20gdXNlciBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBtZXJnZWQgd2l0aCBkZWZhdWx0c1xuICovXG5jb25zdCBtZXJnZU9wdGlvbnMgPSBvcHRpb25zID0+ICh7Li4uZGVmYXVsdHMsIC4uLm9wdGlvbnN9KTtcblxuLyogQHR5cGUge29iamVjdH0gZ2VuZXJhbCBjb25maWd1cmF0aW9uIG9iamVjdCAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGJhc2U6ICdodHRwczovL2xvY2FsaG9zdCcsXG4gIHNpbGVudEVycm9yczogZmFsc2UsXG4gIC8vIHBhdGhUb1JlZ2V4cCBvcHRpb25zXG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIHN0cmljdDogZmFsc2UsXG4gIGVuZDogdHJ1ZSxcbiAgc3RhcnQ6IHRydWUsXG4gIGRlbGltaXRlcjogJy8jPycsXG4gIGVuY29kZTogdW5kZWZpbmVkLFxuICBlbmRzV2l0aDogdW5kZWZpbmVkLFxuICBwcmVmaXhlczogJy4vJ1xufTtcblxuLyoqXG4gKiBDb25maWd1cmUgdGhlIHJvdXRlciBvcHRpb25zIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGN1c3RvbSB1c2VyIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5ldyBkZWZhdWx0c1xuICovXG5jb25zdCBjb25maWd1cmUgPSAob3B0aW9ucykgPT4ge1xuICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihkZWZhdWx0cywga2V5KSkgZGVmYXVsdHNba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gZGVmYXVsdHNcbn07XG5cblxuXG4vKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwI3VzYWdlfSAqL1xuY29uc3QgdG9SZWdleHAgPSAocGF0aCwga2V5cywgb3B0aW9ucykgPT4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbi8qKlxuICogQ29udmVydCBhIHJvdXRlciBlbnRyeSB0byBhIHJlYWwgcGF0aCBjb21wdXRpbmcgdGhlIHVybCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoIC0gcm91dGVyIHBhdGggc3RyaW5nXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBwYXJhbXMgLSBuYW1lZCBtYXRjaGVkIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMgLSBwYXRoVG9SZWdleHAgb3B0aW9ucyBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXB1dGVkIHVybCBzdHJpbmdcbiAqL1xuY29uc3QgdG9QYXRoID0gKHBhdGgsIHBhcmFtcywgb3B0aW9ucykgPT4gY29tcGlsZShwYXRoLCBtZXJnZU9wdGlvbnMob3B0aW9ucykpKHBhcmFtcyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgcGF0aCBnZW5lcmF0aW5nIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoIC0gdGFyZ2V0IHBhdGhcbiAqIEBwYXJhbSAgIHtSZWdFeHB9IHBhdGhSZWdFeHAgLSBwYXRoIHRyYW5zZm9ybWVkIHRvIHJlZ2V4cCB2aWEgcGF0aFRvUmVnZXhwXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGJhc2UgcGF0aFxuICogQHJldHVybnMge1VSTH0gdXJsIG9iamVjdCBlbmhhbmNlZCB3aXRoIHRoZSBgbWF0Y2hgIGF0dHJpYnV0ZVxuICovXG5jb25zdCB0b1VSTCA9IChwYXRoLCBwYXRoUmVnRXhwLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge2Jhc2V9ID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBbLCAuLi5wYXJhbXNdID0gcGF0aFJlZ0V4cC5leGVjKHBhdGgpO1xuICBjb25zdCB1cmwgPSBwYXJzZVVSTChwYXRoLCBiYXNlKTtcblxuICAvLyBleHRlbmQgdGhlIHVybCBvYmplY3QgYWRkaW5nIHRoZSBtYXRjaGVkIHBhcmFtc1xuICB1cmwucGFyYW1zID0gcGFyYW1zLnJlZHVjZSgoYWNjLCBwYXJhbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleXMgJiYgb3B0aW9ucy5rZXlzW2luZGV4XTtcbiAgICBpZiAoa2V5KSBhY2Nba2V5Lm5hbWVdID0gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogcGFyYW07XG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHVybFxufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhIHBhdGggd2lsbCBiZSBtYXRjaGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBwYXRoIC0gdGFyZ2V0IHBhdGhcbiAqIEBwYXJhbSAgIHtSZWdFeHB9IHBhdGhSZWdFeHAgLSBwYXRoIHRyYW5zZm9ybWVkIHRvIHJlZ2V4cCB2aWEgcGF0aFRvUmVnZXhwXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcGF0aCBtYXRjaGVzIHRoZSByZWdleHBcbiAqL1xuY29uc3QgbWF0Y2ggPSAocGF0aCwgcGF0aFJlZ0V4cCkgPT4gcGF0aFJlZ0V4cC50ZXN0KHBhdGgpO1xuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIHNlcXVlbmNlIG9mIGZ1bmN0aW9ucyB0byBwYXNzIHRvIGVycmUuanNcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGluIHRoZSBlcnJlIHN0cmVhbVxuICogQHBhcmFtICAge1JlZ0V4cH0gcGF0aFJlZ0V4cCAtIHBhdGggdHJhbnNmb3JtZWQgdG8gcmVnZXhwIHZpYSBwYXRoVG9SZWdleHBcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMgLSBwYXRoVG9SZWdleHAgb3B0aW9ucyBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX0gYSBmdW5jdGlvbnMgYXJyYXkgdGhhdCB3aWxsIGJlIHVzZWQgYXMgc3RyZWFtIHBpcGUgZm9yIGVycmUuanNcbiAqL1xuY29uc3QgY3JlYXRlVVJMU3RyZWFtUGlwZSA9IChwYXRoUmVnRXhwLCBvcHRpb25zKSA9PiBbXG4gIGRlY29kZVVSSSxcbiAgcmVwbGFjZUJhc2UsXG4gIG1hdGNoT3JTa2lwKHBhdGhSZWdFeHApLFxuICBwYXRoID0+IHRvVVJMKHBhdGgsIHBhdGhSZWdFeHAsIG9wdGlvbnMpXG5dO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZvcmsgb2YgdGhlIG1haW4gcm91dGVyIHN0cmVhbVxuICogQHBhcmFtICAge3N0cmluZ30gcGF0aCAtIHJvdXRlIHRvIG1hdGNoXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBvcHRpb25zIC0gcGF0aFRvUmVnZXhwIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyZWFtfSBuZXcgcm91dGUgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBwYXRoUmVnRXhwID0gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICBjb25zdCBVUkxTdHJlYW0gPSBlcnJlKC4uLmNyZWF0ZVVSTFN0cmVhbVBpcGUocGF0aFJlZ0V4cCwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAga2V5c1xuICB9KSk7XG5cbiAgcmV0dXJuIGpvaW5TdHJlYW1zKHJvdXRlciwgVVJMU3RyZWFtKS5vbi5lcnJvcihwYW5pYyQyKVxufVxuXG5jb25zdCBXSU5ET1dfRVZFTlRTID0gJ3BvcHN0YXRlJztcbmNvbnN0IENMSUNLX0VWRU5UID0gJ2NsaWNrJztcbmNvbnN0IERPV05MT0FEX0xJTktfQVRUUklCVVRFID0gJ2Rvd25sb2FkJztcbmNvbnN0IEhSRUZfTElOS19BVFRSSUJVVEUgPSAnaHJlZic7XG5jb25zdCBUQVJHRVRfU0VMRl9MSU5LX0FUVFJJQlVURSA9ICdfc2VsZic7XG5jb25zdCBMSU5LX1RBR19OQU1FID0gJ0EnO1xuY29uc3QgSEFTSCA9ICcjJztcbmNvbnN0IFNMQVNIID0gJy8nO1xuY29uc3QgUEFUSF9BVFRSSUJVVEUgPSAncGF0aCc7XG5jb25zdCBSRV9PUklHSU4gPSAvXi4rP1xcL1xcLytbXi9dKy87XG5cbi8qKlxuICogQ29udmVydHMgYW55IERPTSBub2RlL3MgdG8gYSBsb29wYWJsZSBhcnJheVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdCB9IGVscyAtIHNpbmdsZSBodG1sIGVsZW1lbnQgb3IgYSBub2RlIGxpc3RcbiAqIEByZXR1cm5zIHsgQXJyYXkgfSBhbHdheXMgYSBsb29wYWJsZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZG9tVG9BcnJheShlbHMpIHtcbiAgLy8gY2FuIHRoaXMgb2JqZWN0IGJlIGFscmVhZHkgbG9vcGVkP1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxzKSkge1xuICAgIC8vIGlzIGl0IGEgbm9kZSBsaXN0P1xuICAgIGlmIChcbiAgICAgIC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC9cbiAgICAgICAgLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVscykpXG4gICAgICAgICYmIHR5cGVvZiBlbHMubGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGVscylcbiAgICBlbHNlXG4gICAgICAvLyBpZiBpdCdzIGEgc2luZ2xlIG5vZGVcbiAgICAgIC8vIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgXCJhcnJheVwiIHdpdGggb25lIHNpbmdsZSBlbnRyeVxuICAgICAgcmV0dXJuIFtlbHNdXG4gIH1cbiAgLy8gdGhpcyBvYmplY3QgY291bGQgYmUgbG9vcGVkIG91dCBvZiB0aGUgYm94XG4gIHJldHVybiBlbHNcbn1cblxuLyoqXG4gKiBTaW1wbGUgaGVscGVyIHRvIGZpbmQgRE9NIG5vZGVzIHJldHVybmluZyB0aGVtIGFzIGFycmF5IGxpa2UgbG9vcGFibGUgb2JqZWN0XG4gKiBAcGFyYW0gICB7IHN0cmluZ3xET01Ob2RlTGlzdCB9IHNlbGVjdG9yIC0gZWl0aGVyIHRoZSBxdWVyeSBvciB0aGUgRE9NIG5vZGVzIHRvIGFycmFpZnlcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgICAgICAgc2NvcGUgICAgICAtIGNvbnRleHQgZGVmaW5pbmcgd2hlcmUgdGhlIHF1ZXJ5IHdpbGwgc2VhcmNoIGZvciB0aGUgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gRE9NIG5vZGVzIGZvdW5kIGFzIGFycmF5XG4gKi9cbmZ1bmN0aW9uICQoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHJldHVybiBkb21Ub0FycmF5KHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycgP1xuICAgIChkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgOlxuICAgIHNlbGVjdG9yXG4gIClcbn1cblxuY29uc3QgZ2V0Q3VycmVudFJvdXRlID0gKChjdXJyZW50Um91dGUpID0+IHtcbiAgLy8gbGlzdGVuIHRoZSByb3V0ZSBjaGFuZ2VzIGV2ZW50cyB0byBzdG9yZSB0aGUgY3VycmVudCByb3V0ZVxuICByb3V0ZXIub24udmFsdWUoKHIpID0+IChjdXJyZW50Um91dGUgPSByKSk7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gY3VycmVudFJvdXRlXG4gIH1cbn0pKG51bGwpO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgcmV0dXJuIHZhbHVlcywgaW4gY2FzZSBvZiBhIHNpbmdsZSB2YWx1ZSB3ZSBhdm9pZCB0byByZXR1cm4gYW4gYXJyYXlcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSB2YWx1ZXMgLSBsaXN0IG9mIHZhbHVlcyB3ZSB3YW50IHRvIHJldHVyblxuICogQHJldHVybnMgeyBBcnJheXxzdHJpbmd8Ym9vbGVhbiB9IGVpdGhlciB0aGUgd2hvbGUgbGlzdCBvZiB2YWx1ZXMgb3IgdGhlIHNpbmdsZSBvbmUgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZSA9IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID09PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzO1xuXG4vKipcbiAqIFBhcnNlIGFsbCB0aGUgbm9kZXMgcmVjZWl2ZWQgdG8gZ2V0L3JlbW92ZS9jaGVjayB0aGVpciBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gZWxzICAgIC0gRE9NIG5vZGUvcyB0byBwYXJzZVxuICogQHBhcmFtICAgeyBzdHJpbmd8QXJyYXkgfSAgICAgICAgICAgICAgIG5hbWUgICAtIG5hbWUgb3IgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9ICAgICAgICAgICAgICAgICAgICAgbWV0aG9kIC0gbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBhcnNlIHRoZSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7IEFycmF5fHN0cmluZyB9IHJlc3VsdCBvZiB0aGUgcGFyc2luZyBpbiBhIGxpc3Qgb3IgYSBzaW5nbGUgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTm9kZXMoZWxzLCBuYW1lLCBtZXRob2QpIHtcbiAgY29uc3QgbmFtZXMgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBbbmFtZV0gOiBuYW1lO1xuICByZXR1cm4gbm9ybWFsaXplKGRvbVRvQXJyYXkoZWxzKS5tYXAoZWwgPT4ge1xuICAgIHJldHVybiBub3JtYWxpemUobmFtZXMubWFwKG4gPT4gZWxbbWV0aG9kXShuKSkpXG4gIH0pKVxufVxuXG4vKipcbiAqIEdldCBhbnkgYXR0cmlidXRlIGZyb20gYSBzaW5nbGUgb3IgYSBsaXN0IG9mIERPTSBub2Rlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgIC0gRE9NIG5vZGUvcyB0byBwYXJzZVxuICogQHBhcmFtICAgeyBzdHJpbmd8QXJyYXkgfSAgICAgICAgICAgICAgIG5hbWUgIC0gbmFtZSBvciBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gZ2V0XG4gKiBAcmV0dXJucyB7IEFycmF5fHN0cmluZyB9IGxpc3Qgb2YgdGhlIGF0dHJpYnV0ZXMgZm91bmRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCB7IGdldCB9IGZyb20gJ2JpYW5jby5hdHRyJ1xuICpcbiAqIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gKlxuICogZ2V0KGltZywgJ3dpZHRoJykgLy8gPT4gJzIwMCdcbiAqXG4gKiAvLyBvciBhbHNvXG4gKiBnZXQoaW1nLCBbJ3dpZHRoJywgJ2hlaWdodCddKSAvLyA9PiBbJzIwMCcsICczMDAnXVxuICpcbiAqIC8vIG9yIGFsc29cbiAqIGdldChbaW1nMSwgaW1nMl0sIFsnd2lkdGgnLCAnaGVpZ2h0J10pIC8vID0+IFtbJzIwMCcsICczMDAnXSwgWyc1MDAnLCAnMjAwJ11dXG4gKi9cbmZ1bmN0aW9uIGdldChlbHMsIG5hbWUpIHtcbiAgcmV0dXJuIHBhcnNlTm9kZXMoZWxzLCBuYW1lLCAnZ2V0QXR0cmlidXRlJylcbn1cblxuLyoqXG4gKiBTZXQgYW55IGF0dHJpYnV0ZSBvbiBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gZWxzICAgLSBET00gbm9kZS9zIHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IHN0cmluZ3xBcnJheSB9ICAgICAgICAgICAgICAgbmFtZSAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBkZXRlY3RcbiAqIEByZXR1cm5zIHsgYm9vbGVhbnxBcnJheSB9IHRydWUgb3IgZmFsc2Ugb3IgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgaGFzIH0gZnJvbSAnYmlhbmNvLmF0dHInXG4gKlxuICogaGFzKGltZywgJ3dpZHRoJykgLy8gZmFsc2VcbiAqXG4gKiAvLyBvciBhbHNvXG4gKiBoYXMoaW1nLCBbJ3dpZHRoJywgJ2hlaWdodCddKSAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICpcbiAqIC8vIG9yIGFsc29cbiAqIGhhcyhbaW1nMSwgaW1nMl0sIFsnd2lkdGgnLCAnaGVpZ2h0J10pIC8vID0+IFtbZmFsc2UsIGZhbHNlXSwgW2ZhbHNlLCBmYWxzZV1dXG4gKi9cbmZ1bmN0aW9uIGhhcyhlbHMsIG5hbWUpIHtcbiAgcmV0dXJuIHBhcnNlTm9kZXMoZWxzLCBuYW1lLCAnaGFzQXR0cmlidXRlJylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGZyb20gY2FtZWwgY2FzZSB0byBkYXNoLWNhc2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IHN0cmluZyAtIHByb2JhYmx5IGEgY29tcG9uZW50IHRhZyBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb21wb25lbnQgbmFtZSBub3JtYWxpemVkXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgZGFzaGVzIHRvIGNhbWVsIGNhc2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IHN0cmluZyAtIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gbXktc3RyaW5nIC0+IG15U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGRhc2hUb0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gKiBAcGFyYW0gICB7Kn0gIHZhbHVlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9ubHkgZm9yIHRoZSAndW5kZWZpbmVkJyBhbmQgJ251bGwnIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG59XG5cbmNvbnN0IGdldEdsb2JhbCA9ICgpID0+IGdldFdpbmRvdygpIHx8IGdsb2JhbDtcbmNvbnN0IGdldFdpbmRvdyA9ICgpID0+ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cpO1xuY29uc3QgZ2V0RG9jdW1lbnQgPSAoKSA9PlxuICB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRvY3VtZW50O1xuY29uc3QgZ2V0SGlzdG9yeSA9ICgpID0+XG4gIHR5cGVvZiBoaXN0b3J5ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBoaXN0b3J5O1xuY29uc3QgZ2V0TG9jYXRpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdygpO1xuICByZXR1cm4gd2luID8gd2luLmxvY2F0aW9uIDoge31cbn07XG5cbmNvbnN0IGRlZmVyID0gKCgpID0+IHtcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSBnZXRHbG9iYWwoKTtcblxuICByZXR1cm4gZ2xvYmFsU2NvcGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdsb2JhbFNjb3BlLnNldFRpbWVvdXRcbn0pKCk7XG5cbmNvbnN0IGNhbmNlbERlZmVyID0gKCgpID0+IHtcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSBnZXRHbG9iYWwoKTtcblxuICByZXR1cm4gZ2xvYmFsU2NvcGUuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsU2NvcGUuY2xlYXJUaW1lb3V0XG59KSgpO1xuXG5jb25zdCBnZXRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlcywgbmFtZSwgY29udGV4dCkgPT4ge1xuICBpZiAoIWF0dHJpYnV0ZXMpIHJldHVybiBudWxsXG5cbiAgY29uc3Qgbm9ybWFsaXplZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmZsYXRNYXAoKGF0dHIpID0+XG4gICAgaXNOaWwoYXR0ci5uYW1lKVxuICAgICAgPyAvLyBhZGQgc3VwcG9ydCBmb3Igc3ByZWFkIGF0dHJpYnV0ZXMgaHR0cHM6Ly9naXRodWIuY29tL3Jpb3Qvcm91dGUvaXNzdWVzLzE3OFxuICAgICAgICBPYmplY3QuZW50cmllcyhhdHRyLmV2YWx1YXRlKGNvbnRleHQpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAvLyBldmFsdWF0ZSBlYWNoIHZhbHVlIG9mIHRoZSBzcHJlYWQgYXR0cmlidXRlIGFuZCBzdG9yZSBpdCBpbnRvIHRoZSBhcnJheVxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAvLyBjcmVhdGUgYSBuZXN0ZWQgZXZhbHVhdGUgZnVuY3Rpb24gcG9pbnRpbmcgdG8gdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzcHJlYWQgb2JqZWN0XG4gICAgICAgICAgZXZhbHVhdGU6ICgpID0+IHZhbHVlLFxuICAgICAgICB9KSlcbiAgICAgIDogYXR0cixcbiAgKTtcblxuICByZXR1cm4gbm9ybWFsaXplZEF0dHJpYnV0ZXMuZmluZCgoYSkgPT4gZGFzaFRvQ2FtZWxDYXNlKGEubmFtZSkgPT09IG5hbWUpXG59O1xuXG5jb25zdCBjcmVhdGVEZWZhdWx0U2xvdCA9IChhdHRyaWJ1dGVzID0gW10pID0+IHtcbiAgY29uc3QgeyB0ZW1wbGF0ZSwgYmluZGluZ1R5cGVzLCBleHByZXNzaW9uVHlwZXMgfSA9IF9fLkRPTUJpbmRpbmdzO1xuXG4gIHJldHVybiB0ZW1wbGF0ZShudWxsLCBbXG4gICAge1xuICAgICAgdHlwZTogYmluZGluZ1R5cGVzLlNMT1QsXG4gICAgICBuYW1lOiAnZGVmYXVsdCcsXG4gICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gKHtcbiAgICAgICAgLi4uYXR0cixcbiAgICAgICAgdHlwZTogZXhwcmVzc2lvblR5cGVzLkFUVFJJQlVURSxcbiAgICAgIH0pKSxcbiAgICB9LFxuICBdKVxufTtcblxuLy8gVHJ1ZSBpZiB0aGUgc2VsZWN0b3Igc3RyaW5nIGlzIHZhbGlkXG5jb25zdCBpc1ZhbGlkUXVlcnlTZWxlY3RvclN0cmluZyA9IChzZWxlY3RvcikgPT5cbiAgL14oW2EtekEtWjAtOS1fKiMuOltcXF1cXHM+K34oKT0nXCJdfFxcXFwuKSskLy50ZXN0KHNlbGVjdG9yKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGNvbXBvc2UgYnV0IHBlcmZvcm1zIGZyb20gbGVmdC10by1yaWdodCBmdW5jdGlvbiBjb21wb3NpdGlvbi48YnIvPlxuICoge0BsaW5rIGh0dHBzOi8vMzBzZWNvbmRzb2Zjb2RlLm9yZy9mdW5jdGlvbiNjb21wb3NlcmlnaHQgc2VlIGFsc299XG4gKiBAcGFyYW0gICB7Li4uW2Z1bmN0aW9uXX0gZm5zKSAtIGxpc3Qgb2YgdW5hcnkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHsqfSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uXG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiBVc2UgQXJyYXkucHJvdG90eXBlLnJlZHVjZSgpIHRvIHBlcmZvcm0gcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi48YnIvPlxuICogVGhlIGxhc3QgKHJpZ2h0bW9zdCkgZnVuY3Rpb24gY2FuIGFjY2VwdCBvbmUgb3IgbW9yZSBhcmd1bWVudHM7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuPGJyLz5cbiAqIHtAbGluayBodHRwczovLzMwc2Vjb25kc29mY29kZS5vcmcvZnVuY3Rpb24jY29tcG9zZSBvcmlnaW5hbCBzb3VyY2UgY29kZX1cbiAqIEBwYXJhbSAgIHsuLi5bZnVuY3Rpb25dfSBmbnMpIC0gbGlzdCBvZiB1bmFyeSBmdW5jdGlvblxuICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb25cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSguLi5mbnMpIHtcbiAgcmV0dXJuIGZucy5yZWR1Y2UoKGYsIGcpID0+ICguLi5hcmdzKSA9PiBmKGcoLi4uYXJncykpKVxufVxuXG5jb25zdCBnZXRJbml0aWFsUm91dGVWYWx1ZSA9IChwYXRoVG9SZWdleHAsIHBhdGgsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgcm91dGUgPSBjb21wb3NlKFxuICAgIC4uLmNyZWF0ZVVSTFN0cmVhbVBpcGUocGF0aFRvUmVnZXhwLCBvcHRpb25zKS5yZXZlcnNlKCksXG4gICkocGF0aCk7XG5cbiAgcmV0dXJuIHJvdXRlLnBhcmFtcyA/IHJvdXRlIDogbnVsbFxufTtcblxuY29uc3QgY2xlYXJET01CZXR3ZWVuTm9kZXMgPSAoZmlyc3QsIGxhc3QsIGluY2x1ZGVCb3VuZGFyaWVzKSA9PiB7XG4gIGNvbnN0IGNsZWFyID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUgfHwgKG5vZGUgPT09IGxhc3QgJiYgIWluY2x1ZGVCb3VuZGFyaWVzKSkgcmV0dXJuXG4gICAgY29uc3QgeyBuZXh0U2libGluZyB9ID0gbm9kZTtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIGNsZWFyKG5leHRTaWJsaW5nKTtcbiAgfTtcblxuICBjbGVhcihpbmNsdWRlQm91bmRhcmllcyA/IGZpcnN0IDogZmlyc3QubmV4dFNpYmxpbmcpO1xufTtcblxuY29uc3Qgcm91dGVIb2MkMSA9ICh7IHNsb3RzLCBhdHRyaWJ1dGVzIH0pID0+IHtcbiAgY29uc3QgcGxhY2Vob2xkZXJzID0ge1xuICAgIGJlZm9yZTogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLFxuICAgIGFmdGVyOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyksXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtb3VudChlbCwgY29udGV4dCkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBjb21wb25lbnQgc3RhdGVcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3V0ZSA9IGdldEN1cnJlbnRSb3V0ZSgpO1xuICAgICAgY29uc3QgcGF0aCA9XG4gICAgICAgIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBQQVRIX0FUVFJJQlVURSwgY29udGV4dCk/LmV2YWx1YXRlKGNvbnRleHQpIHx8XG4gICAgICAgIGdldChlbCwgUEFUSF9BVFRSSUJVVEUpO1xuICAgICAgY29uc3QgcGF0aFRvUmVnZXhwID0gdG9SZWdleHAocGF0aCwgW10pO1xuICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIHBhdGhUb1JlZ2V4cCxcbiAgICAgICAgcm91dGU6XG4gICAgICAgICAgY3VycmVudFJvdXRlICYmIG1hdGNoKGN1cnJlbnRSb3V0ZSwgcGF0aFRvUmVnZXhwKVxuICAgICAgICAgICAgPyBnZXRJbml0aWFsUm91dGVWYWx1ZShwYXRoVG9SZWdleHAsIGN1cnJlbnRSb3V0ZSwge30pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgdGhpcy5zbG90ID0gY3JlYXRlRGVmYXVsdFNsb3QoW1xuICAgICAgICB7XG4gICAgICAgICAgaXNCb29sZWFuOiBmYWxzZSxcbiAgICAgICAgICBuYW1lOiAncm91dGUnLFxuICAgICAgICAgIGV2YWx1YXRlOiAoKSA9PiB0aGlzLnN0YXRlLnJvdXRlLFxuICAgICAgICB9LFxuICAgICAgXSk7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgLy8gc2V0IHRoZSByb3V0ZSBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuYm91bmRPbkJlZm9yZVJvdXRlID0gdGhpcy5vbkJlZm9yZVJvdXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvdW5kT25Sb3V0ZSA9IHRoaXMub25Sb3V0ZS5iaW5kKHRoaXMpO1xuICAgICAgcm91dGVyLm9uLnZhbHVlKHRoaXMuYm91bmRPbkJlZm9yZVJvdXRlKTtcbiAgICAgIHRoaXMuc3RyZWFtID0gY3JlYXRlUm91dGUocGF0aCkub24udmFsdWUodGhpcy5ib3VuZE9uUm91dGUpO1xuICAgICAgLy8gdXBkYXRlIHRoZSBET01cbiAgICAgIGVsLnJlcGxhY2VXaXRoKHBsYWNlaG9sZGVycy5iZWZvcmUpO1xuICAgICAgcGxhY2Vob2xkZXJzLmJlZm9yZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgcGxhY2Vob2xkZXJzLmFmdGVyLFxuICAgICAgICBwbGFjZWhvbGRlcnMuYmVmb3JlLm5leHRTaWJsaW5nLFxuICAgICAgKTtcbiAgICAgIGlmIChzdGF0ZS5yb3V0ZSkgdGhpcy5tb3VudFNsb3QoKTtcbiAgICB9LFxuICAgIHVwZGF0ZShjb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgaWYgKHRoaXMuc3RhdGUucm91dGUpIHRoaXMuc2xvdC51cGRhdGUoe30sIGNvbnRleHQpO1xuICAgIH0sXG4gICAgbW91bnRTbG90KCkge1xuICAgICAgY29uc3QgeyByb3V0ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIC8vIGluc2VydCB0aGUgcm91dGUgcm9vdCBlbGVtZW50IGFmdGVyIHRoZSBiZWZvcmUgcGxhY2Vob2xkZXJcbiAgICAgIHBsYWNlaG9sZGVycy5iZWZvcmUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgICAgIHRoaXMuZWwsXG4gICAgICAgIHBsYWNlaG9sZGVycy5iZWZvcmUubmV4dFNpYmxpbmcsXG4gICAgICApO1xuICAgICAgdGhpcy5jYWxsTGlmZWN5Y2xlUHJvcGVydHkoJ29uQmVmb3JlTW91bnQnLCByb3V0ZSk7XG4gICAgICB0aGlzLnNsb3QubW91bnQoXG4gICAgICAgIHRoaXMuZWwsXG4gICAgICAgIHtcbiAgICAgICAgICBzbG90cyxcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5jb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FsbExpZmVjeWNsZVByb3BlcnR5KCdvbk1vdW50ZWQnLCByb3V0ZSk7XG4gICAgfSxcbiAgICBjbGVhckRPTShpbmNsdWRlQm91bmRhcmllcykge1xuICAgICAgLy8gcmVtb3ZlIGFsbCB0aGUgRE9NIG5vZGVzIGJldHdlZW4gdGhlIHBsYWNlaG9sZGVyc1xuICAgICAgY2xlYXJET01CZXR3ZWVuTm9kZXMoXG4gICAgICAgIHBsYWNlaG9sZGVycy5iZWZvcmUsXG4gICAgICAgIHBsYWNlaG9sZGVycy5hZnRlcixcbiAgICAgICAgaW5jbHVkZUJvdW5kYXJpZXMsXG4gICAgICApO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHJvdXRlci5vZmYudmFsdWUodGhpcy5ib3VuZE9uQmVmb3JlUm91dGUpO1xuICAgICAgdGhpcy5zbG90LnVubW91bnQoe30sIHRoaXMuY29udGV4dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNsZWFyRE9NKHRydWUpO1xuICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgfSxcbiAgICBvbkJlZm9yZVJvdXRlKHBhdGgpIHtcbiAgICAgIGNvbnN0IHsgcm91dGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAvLyB0aGlzIGNvbXBvbmVudCB3YXMgbm90IG1vdW50ZWQgb3IgdGhlIGN1cnJlbnQgcGF0aCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVubW91bnQgdGhpcyBjb21wb25lbnRcbiAgICAgIGlmICghcm91dGUgfHwgbWF0Y2gocGF0aCwgdGhpcy5zdGF0ZS5wYXRoVG9SZWdleHApKSByZXR1cm5cblxuICAgICAgdGhpcy5jYWxsTGlmZWN5Y2xlUHJvcGVydHkoJ29uQmVmb3JlVW5tb3VudCcsIHJvdXRlKTtcbiAgICAgIHRoaXMuc2xvdC51bm1vdW50KHt9LCB0aGlzLmNvbnRleHQsIHRydWUpO1xuICAgICAgdGhpcy5jbGVhckRPTShmYWxzZSk7XG4gICAgICB0aGlzLnN0YXRlLnJvdXRlID0gbnVsbDtcbiAgICAgIHRoaXMuY2FsbExpZmVjeWNsZVByb3BlcnR5KCdvblVubW91bnRlZCcsIHJvdXRlKTtcbiAgICB9LFxuICAgIG9uUm91dGUocm91dGUpIHtcbiAgICAgIGNvbnN0IHByZXZSb3V0ZSA9IHRoaXMuc3RhdGUucm91dGU7XG4gICAgICB0aGlzLnN0YXRlLnJvdXRlID0gcm91dGU7XG5cbiAgICAgIC8vIGlmIHRoaXMgcm91dGUgY29tcG9uZW50IHdhcyBhbHJlYWR5IG1vdW50ZWQgd2UgbmVlZCB0byB1cGRhdGUgaXRcbiAgICAgIGlmIChwcmV2Um91dGUpIHtcbiAgICAgICAgdGhpcy5jYWxsTGlmZWN5Y2xlUHJvcGVydHkoJ29uQmVmb3JlVXBkYXRlJywgcm91dGUpO1xuICAgICAgICB0aGlzLnNsb3QudXBkYXRlKHt9LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB0aGlzLmNhbGxMaWZlY3ljbGVQcm9wZXJ0eSgnb25VcGRhdGVkJywgcm91dGUpO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyByb3V0ZSBjb21wb25lbnQgd2FzIG5ldmVyIG1vdW50ZWQsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGl0cyBET01cbiAgICAgIGVsc2UgdGhpcy5tb3VudFNsb3QoKTtcblxuICAgICAgLy8gZW11bGF0ZSB0aGUgZGVmYXVsdCBicm93c2VyIGFuY2hvciBsaW5rcyBiZWhhdmlvdXJcbiAgICAgIGlmIChyb3V0ZS5oYXNoICYmIGlzVmFsaWRRdWVyeVNlbGVjdG9yU3RyaW5nKHJvdXRlLmhhc2gpKVxuICAgICAgICAkKHJvdXRlLmhhc2gpPy5bMF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9LFxuICAgIGNhbGxMaWZlY3ljbGVQcm9wZXJ0eShtZXRob2QsIC4uLnBhcmFtcykge1xuICAgICAgY29uc3QgYXR0ciA9IGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBtZXRob2QsIHRoaXMuY29udGV4dCk7XG5cbiAgICAgIGlmIChhdHRyKSBhdHRyLmV2YWx1YXRlKHRoaXMuY29udGV4dCkoLi4ucGFyYW1zKTtcbiAgICB9LFxuICB9XG59O1xuXG52YXIgcm91dGVIb2MgPSB7XG4gIGNzczogbnVsbCxcblxuICBleHBvcnRzOiBwdXJlKFxuICAgIHJvdXRlSG9jJDFcbiAgKSxcblxuICB0ZW1wbGF0ZTogbnVsbCxcbiAgbmFtZTogJ3JvdXRlLWhvYydcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZUluaXRpYWxTbGFzaCA9IChzdHIpID0+XG4gIHN0clswXSA9PT0gU0xBU0ggPyBzdHIgOiBgJHtTTEFTSH0ke3N0cn1gO1xuY29uc3QgcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IChzdHIpID0+XG4gIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09IFNMQVNIID8gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSkgOiBzdHI7XG5cbmNvbnN0IG5vcm1hbGl6ZUJhc2UgPSAoYmFzZSkgPT4ge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgbG9jID0gd2luLmxvY2F0aW9uO1xuICBjb25zdCByb290ID0gbG9jID8gYCR7bG9jLnByb3RvY29sfS8vJHtsb2MuaG9zdH1gIDogJyc7XG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IGxvYyA/IGxvYyA6IHt9O1xuXG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIC8vIHB1cmUgcm9vdCB1cmwgKyBwYXRobmFtZVxuICAgIGNhc2UgQm9vbGVhbihiYXNlKSA9PT0gZmFsc2U6XG4gICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaChgJHtyb290fSR7cGF0aG5hbWUgfHwgJyd9YClcbiAgICAvLyBmdWxsIHBhdGggYmFzZVxuICAgIGNhc2UgLyh3d3d8aHR0cChzKT86KS8udGVzdChiYXNlKTpcbiAgICAgIHJldHVybiBiYXNlXG4gICAgLy8gaGFzaCBuYXZpZ2F0aW9uXG4gICAgY2FzZSBiYXNlWzBdID09PSBIQVNIOlxuICAgICAgcmV0dXJuIGAke3Jvb3R9JHtwYXRobmFtZSAmJiBwYXRobmFtZSAhPT0gU0xBU0ggPyBwYXRobmFtZSA6ICcnfSR7YmFzZX1gXG4gICAgLy8gcm9vdCB1cmwgd2l0aCB0cmFpbGluZyBzbGFzaFxuICAgIGNhc2UgYmFzZSA9PT0gU0xBU0g6XG4gICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaChyb290KVxuICAgIC8vIGN1c3RvbSBwYXRobmFtZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaChgJHtyb290fSR7bm9ybWFsaXplSW5pdGlhbFNsYXNoKGJhc2UpfWApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldEJhc2UoYmFzZSkge1xuICBjb25maWd1cmUoeyBiYXNlOiBub3JtYWxpemVCYXNlKGJhc2UpIH0pO1xufVxuXG4vKipcbiAqIFRocm93IGFuIGVycm9yIHdpdGggYSBkZXNjcmlwdGl2ZSBtZXNzYWdlXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IG1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IGNhdXNlIC0gb3B0aW9uYWwgZXJyb3IgY2F1c2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7IHVuZGVmaW5lZCB9IGhvcHBsYS4uLiBhdCB0aGlzIHBvaW50IHRoZSBwcm9ncmFtIHNob3VsZCBzdG9wIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gcGFuaWMobWVzc2FnZSwgY2F1c2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2UgfSlcbn1cblxuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBpbnRvIHNldmVyYWwgaXRlbXMgc2VwYXJlZCBieSBzcGFjZXNcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gbCAtIGV2ZW50cyBsaXN0XG4gKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSBldmVudHMgZGV0ZWN0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNwbGl0ID0gbCA9PiBsLnNwbGl0KC9cXHMvKTtcblxuLyoqXG4gKiBTZXQgYSBsaXN0ZW5lciBmb3IgYWxsIHRoZSBldmVudHMgcmVjZWl2ZWQgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgICAgLSBET00gbm9kZS9zIHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZSBib3VuZFxuICogQHBhcmFtICAgeyBzdHJpbmcgfSAgICAgICAgICAgICAgICAgICAgIGV2TGlzdCAgLSBsaXN0IG9mIGV2ZW50cyB3ZSB3YW50IHRvIGJpbmQgb3IgdW5iaW5kIHNwYWNlIHNlcGFyYXRlZFxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9ICAgICAgICAgICAgICAgICAgIGNiICAgICAgLSBsaXN0ZW5lcnMgY2FsbGJhY2tcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICAgICBtZXRob2QgIC0gZWl0aGVyICdhZGRFdmVudExpc3RlbmVyJyBvciAncmVtb3ZlRXZlbnRMaXN0ZW5lcidcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gICAgICAgICAgICAgICAgICAgICBvcHRpb25zIC0gZXZlbnQgb3B0aW9ucyAoY2FwdHVyZSwgb25jZSBhbmQgcGFzc2l2ZSlcbiAqIEByZXR1cm5zIHsgdW5kZWZpbmVkIH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hbmFnZUV2ZW50cyhlbHMsIGV2TGlzdCwgY2IsIG1ldGhvZCwgb3B0aW9ucykge1xuICBlbHMgPSBkb21Ub0FycmF5KGVscyk7XG5cbiAgc3BsaXQoZXZMaXN0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgZWxzLmZvckVhY2goZWwgPT4gZWxbbWV0aG9kXShlLCBjYiwgb3B0aW9ucyB8fCBmYWxzZSkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBsaXN0ZW5lciBmb3IgYWxsIHRoZSBldmVudHMgcmVjZWl2ZWQgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxBcnJheSB9IGVscyAgICAtIERPTSBub2RlL3Mgd2hlcmUgdGhlIGxpc3RlbmVycyB3aWxsIGJlIGJvdW5kXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9ICAgICAgICAgICAgZXZMaXN0IC0gbGlzdCBvZiBldmVudHMgd2Ugd2FudCB0byBiaW5kIHNwYWNlIHNlcGFyYXRlZFxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9ICAgICAgICAgIGNiICAgICAtIGxpc3RlbmVycyBjYWxsYmFja1xuICogQHBhcmFtICAgeyBPYmplY3QgfSAgICAgICAgICAgIG9wdGlvbnMgLSBldmVudCBvcHRpb25zIChjYXB0dXJlLCBvbmNlIGFuZCBwYXNzaXZlKVxuICogQHJldHVybnMgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IERPTSBub2RlL3MgYW5kIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBhZGQoZWxzLCBldkxpc3QsIGNiLCBvcHRpb25zKSB7XG4gIG1hbmFnZUV2ZW50cyhlbHMsIGV2TGlzdCwgY2IsICdhZGRFdmVudExpc3RlbmVyJywgb3B0aW9ucyk7XG4gIHJldHVybiBlbHNcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudHMgcmVjZWl2ZWQgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxBcnJheSB9IGVscyAgICAgLSBET00gbm9kZS9zIHdoZXJlIHRoZSBldmVudHMgd2lsbCBiZSB1bmJpbmRcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICBldkxpc3QgIC0gbGlzdCBvZiBldmVudHMgd2Ugd2FudCB1bmJpbmQgc3BhY2Ugc2VwYXJhdGVkXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gICAgICAgICAgY2IgICAgICAtIGxpc3RlbmVycyBjYWxsYmFja1xuICogQHBhcmFtICAgeyBPYmplY3QgfSAgICAgICAgICAgICBvcHRpb25zIC0gZXZlbnQgb3B0aW9ucyAoY2FwdHVyZSwgb25jZSBhbmQgcGFzc2l2ZSlcbiAqIEByZXR1cm5zIHsgSFRNTEVsZW1lbnR8Tm9kZUxpc3R8QXJyYXkgfSAgRE9NIG5vZGUvcyBhbmQgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShlbHMsIGV2TGlzdCwgY2IsIG9wdGlvbnMpIHtcbiAgbWFuYWdlRXZlbnRzKGVscywgZXZMaXN0LCBjYiwgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCBvcHRpb25zKTtcbiAgcmV0dXJuIGVsc1xufVxuXG5jb25zdCBvbldpbmRvd0V2ZW50ID0gKCkgPT5cbiAgcm91dGVyLnB1c2gobm9ybWFsaXplUGF0aChTdHJpbmcoZ2V0TG9jYXRpb24oKS5ocmVmKSkpO1xuY29uc3Qgb25Sb3V0ZXJQdXNoID0gKHBhdGgpID0+IHtcbiAgY29uc3QgdXJsID0gcGF0aC5pbmNsdWRlcyhkZWZhdWx0cy5iYXNlKSA/IHBhdGggOiBkZWZhdWx0cy5iYXNlICsgcGF0aDtcbiAgY29uc3QgbG9jID0gZ2V0TG9jYXRpb24oKTtcbiAgY29uc3QgaGlzdCA9IGdldEhpc3RvcnkoKTtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKTtcblxuICAvLyB1cGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSBvbmx5IGlmIGl0J3MgbmVjZXNzYXJ5XG4gIGlmIChoaXN0ICYmIHVybCAhPT0gbG9jLmhyZWYpIHtcbiAgICBoaXN0LnB1c2hTdGF0ZShudWxsLCBkb2MudGl0bGUsIHVybCk7XG4gIH1cbn07XG5jb25zdCBnZXRMaW5rRWxlbWVudCA9IChub2RlKSA9PlxuICBub2RlICYmICFpc0xpbmtOb2RlKG5vZGUpID8gZ2V0TGlua0VsZW1lbnQobm9kZS5wYXJlbnROb2RlKSA6IG5vZGU7XG5jb25zdCBpc0xpbmtOb2RlID0gKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IExJTktfVEFHX05BTUU7XG5jb25zdCBpc0Nyb3NzT3JpZ2luTGluayA9IChwYXRoKSA9PlxuICBwYXRoLmluZGV4T2YoZ2V0TG9jYXRpb24oKS5ocmVmLm1hdGNoKFJFX09SSUdJTilbMF0pID09PSAtMTtcbmNvbnN0IGlzVGFyZ2V0U2VsZkxpbmsgPSAoZWwpID0+XG4gIGVsLnRhcmdldCAmJiBlbC50YXJnZXQgIT09IFRBUkdFVF9TRUxGX0xJTktfQVRUUklCVVRFO1xuY29uc3QgaXNFdmVudEZvcmJpZGRlbiA9IChldmVudCkgPT5cbiAgKGV2ZW50LndoaWNoICYmIGV2ZW50LndoaWNoICE9PSAxKSB8fCAvLyBub3QgbGVmdCBjbGlja1xuICBldmVudC5tZXRhS2V5IHx8XG4gIGV2ZW50LmN0cmxLZXkgfHxcbiAgZXZlbnQuc2hpZnRLZXkgfHwgLy8gb3IgbWV0YSBrZXlzXG4gIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7IC8vIG9yIGRlZmF1bHQgcHJldmVudGVkXG5jb25zdCBpc0ZvcmJpZGRlbkxpbmsgPSAoZWwpID0+XG4gICFlbCB8fFxuICAhaXNMaW5rTm9kZShlbCkgfHwgLy8gbm90IEEgdGFnXG4gIGhhcyhlbCwgRE9XTkxPQURfTElOS19BVFRSSUJVVEUpIHx8IC8vIGhhcyBkb3dubG9hZCBhdHRyXG4gICFoYXMoZWwsIEhSRUZfTElOS19BVFRSSUJVVEUpIHx8IC8vIGhhcyBubyBocmVmIGF0dHJcbiAgaXNUYXJnZXRTZWxmTGluayhlbCkgfHxcbiAgaXNDcm9zc09yaWdpbkxpbmsoZWwuaHJlZik7XG5jb25zdCBub3JtYWxpemVQYXRoID0gKHBhdGgpID0+IHBhdGgucmVwbGFjZShkZWZhdWx0cy5iYXNlLCAnJyk7XG5jb25zdCBpc0luQmFzZSA9IChwYXRoKSA9PiAhZGVmYXVsdHMuYmFzZSB8fCBwYXRoLmluY2x1ZGVzKGRlZmF1bHRzLmJhc2UpO1xuXG4vKipcbiAqIENhbGxiYWNrIGNhbGxlZCBhbnl0aW1lIHNvbWV0aGluZyB3aWxsIGJlIGNsaWNrZWQgb24gdGhlIHBhZ2VcbiAqIEBwYXJhbSAgIHtFdmVudH0gZXZlbnQgLSBjbGljayBldmVudFxuICogQHJldHVybnMge3VuZGVmaW5lZH0gdm9pZCBtZXRob2RcbiAqL1xuY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICBpZiAoaXNFdmVudEZvcmJpZGRlbihldmVudCkpIHJldHVyblxuXG4gIGNvbnN0IGVsID0gZ2V0TGlua0VsZW1lbnQoZXZlbnQudGFyZ2V0KTtcblxuICBpZiAoaXNGb3JiaWRkZW5MaW5rKGVsKSB8fCAhaXNJbkJhc2UoZWwuaHJlZikpIHJldHVyblxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgcm91dGVyLnB1c2gobm9ybWFsaXplUGF0aChlbC5ocmVmKSk7XG59O1xuXG4vKipcbiAqIExpbmsgdGhlIHJhd3RoIHJvdXRlciB0byB0aGUgRE9NIGV2ZW50c1xuICogQHBhcmFtIHsgSFRNTEVsZW1lbnQgfSBjb250YWluZXIgLSBET00gbm9kZSB3aGVyZSB0aGUgbGlua3MgYXJlIGxvY2F0ZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGVhcmRvd24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaW5pdERvbUxpc3RlbmVycyhjb250YWluZXIpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IHJvb3QgPSBjb250YWluZXIgfHwgZ2V0RG9jdW1lbnQoKTtcblxuICBpZiAod2luKSB7XG4gICAgYWRkKHdpbiwgV0lORE9XX0VWRU5UUywgb25XaW5kb3dFdmVudCk7XG4gICAgYWRkKHJvb3QsIENMSUNLX0VWRU5ULCBvbkNsaWNrKTtcbiAgfVxuXG4gIHJvdXRlci5vbi52YWx1ZShvblJvdXRlclB1c2gpO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHdpbikge1xuICAgICAgcmVtb3ZlKHdpbiwgV0lORE9XX0VWRU5UUywgb25XaW5kb3dFdmVudCk7XG4gICAgICByZW1vdmUocm9vdCwgQ0xJQ0tfRVZFTlQsIG9uQ2xpY2spO1xuICAgIH1cblxuICAgIHJvdXRlci5vZmYudmFsdWUob25Sb3V0ZXJQdXNoKTtcbiAgfVxufVxuXG5jb25zdCBCQVNFX0FUVFJJQlVURV9OQU1FID0gJ2Jhc2UnO1xuY29uc3QgSU5JVElBTF9ST1VURSA9ICdpbml0aWFsUm91dGUnO1xuY29uc3QgT05fU1RBUlRFRF9BVFRSSUJVVEVfTkFNRSA9ICdvblN0YXJ0ZWQnO1xuXG5jb25zdCByb3V0ZXJIb2MkMSA9ICh7IHNsb3RzLCBhdHRyaWJ1dGVzLCBwcm9wcyB9KSA9PiB7XG4gIGlmIChyb3V0ZXJIb2MkMS53YXNJbml0aWFsaXplZClcbiAgICBwYW5pYygnTXVsdGlwbGUgPHJvdXRlcj4gY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuXG4gIHJldHVybiB7XG4gICAgc2xvdDogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICB0ZWFyZG93bjogbnVsbCxcbiAgICBtb3VudChlbCwgY29udGV4dCkge1xuICAgICAgY29uc3QgaW5pdGlhbFJvdXRlQXR0ciA9IGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBJTklUSUFMX1JPVVRFLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IGluaXRpYWxSb3V0ZSA9IGluaXRpYWxSb3V0ZUF0dHJcbiAgICAgICAgPyBpbml0aWFsUm91dGVBdHRyLmV2YWx1YXRlKGNvbnRleHQpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3V0ZSA9IGdldEN1cnJlbnRSb3V0ZSgpO1xuICAgICAgY29uc3Qgb25GaXJzdFJvdXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNyZWF0ZVNsb3QoY29udGV4dCk7XG4gICAgICAgIHJvdXRlci5vZmYudmFsdWUob25GaXJzdFJvdXRlKTtcbiAgICAgIH07XG4gICAgICByb3V0ZXJIb2MkMS53YXNJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHRoaXMudGVhcmRvd24gPSBpbml0RG9tTGlzdGVuZXJzKHRoaXMucm9vdCk7XG5cbiAgICAgIHRoaXMuc2V0QmFzZShjb250ZXh0KTtcblxuICAgICAgLy8gbW91bnQgdGhlIHNsb3RzIG9ubHkgaWYgdGhlIGN1cnJlbnQgcm91dGUgd2FzIGRlZmluZWRcbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgIWluaXRpYWxSb3V0ZSkge1xuICAgICAgICB0aGlzLmNyZWF0ZVNsb3QoY29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIub24udmFsdWUob25GaXJzdFJvdXRlKTtcbiAgICAgICAgcm91dGVyLnB1c2goaW5pdGlhbFJvdXRlIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVNsb3QoY29udGV4dCkge1xuICAgICAgaWYgKCFzbG90cyB8fCAhc2xvdHMubGVuZ3RoKSByZXR1cm5cbiAgICAgIGNvbnN0IG9uU3RhcnRlZEF0dHIgPSBnZXRBdHRyaWJ1dGUoXG4gICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgIE9OX1NUQVJURURfQVRUUklCVVRFX05BTUUsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuXG4gICAgICB0aGlzLnNsb3QgPSBjcmVhdGVEZWZhdWx0U2xvdCgpO1xuXG4gICAgICB0aGlzLnNsb3QubW91bnQoXG4gICAgICAgIHRoaXMuZWwsXG4gICAgICAgIHtcbiAgICAgICAgICBzbG90cyxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChvblN0YXJ0ZWRBdHRyKSB7XG4gICAgICAgIG9uU3RhcnRlZEF0dHIuZXZhbHVhdGUoY29udGV4dCkoZ2V0Q3VycmVudFJvdXRlKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlKGNvbnRleHQpIHtcbiAgICAgIHRoaXMuc2V0QmFzZShjb250ZXh0KTtcblxuICAgICAgLy8gZGVmZXIgdGhlIHVwZGF0ZXMgdG8gYXZvaWQgaW50ZXJuYWwgcmVjdXJzaXZlIHVwZGF0ZSBjYWxsc1xuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3JvdXRlL2lzc3Vlcy8xNDhcbiAgICAgIGlmICh0aGlzLnNsb3QpIHtcbiAgICAgICAgY2FuY2VsRGVmZXIodGhpcy5kZWZlcnJlZCk7XG5cbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVyKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNsb3QudXBkYXRlKHt9LCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bm1vdW50KC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMudGVhcmRvd24oKTtcbiAgICAgIHJvdXRlckhvYyQxLndhc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnNsb3QpIHtcbiAgICAgICAgdGhpcy5zbG90LnVubW91bnQoLi4uYXJncyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRCYXNlKGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGJhc2VBdHRyID0gZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZXMsIEJBU0VfQVRUUklCVVRFX05BTUUsIGNvbnRleHQpO1xuXG4gICAgICByZXR1cm4gYmFzZUF0dHJcbiAgICAgICAgPyBiYXNlQXR0ci5ldmFsdWF0ZShjb250ZXh0KVxuICAgICAgICA6IHRoaXMuZWwuZ2V0QXR0cmlidXRlKEJBU0VfQVRUUklCVVRFX05BTUUpIHx8ICcvJ1xuICAgIH0sXG4gICAgc2V0QmFzZShjb250ZXh0KSB7XG4gICAgICBzZXRCYXNlKHByb3BzID8gcHJvcHMuYmFzZSA6IHRoaXMuZ2V0QmFzZShjb250ZXh0KSk7XG4gICAgfSxcbiAgfVxufTtcblxuLy8gZmxhZyB0byBhdm9pZCBtdWx0aXBsZSByb3V0ZXIgaW5zdGFuY2VzXG5yb3V0ZXJIb2MkMS53YXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG52YXIgcm91dGVySG9jID0ge1xuICBjc3M6IG51bGwsXG5cbiAgZXhwb3J0czogcHVyZShcbiAgICByb3V0ZXJIb2MkMVxuICApLFxuXG4gIHRlbXBsYXRlOiBudWxsLFxuICBuYW1lOiAncm91dGVyLWhvYydcbn07XG5cbmV4cG9ydCB7IHJvdXRlSG9jIGFzIFJvdXRlLCByb3V0ZXJIb2MgYXMgUm91dGVyLCBjb25maWd1cmUsIGNyZWF0ZVVSTFN0cmVhbVBpcGUsIGRlZmF1bHRzLCBnZXRDdXJyZW50Um91dGUsIGluaXREb21MaXN0ZW5lcnMsIG1hdGNoLCBjcmVhdGVSb3V0ZSBhcyByb3V0ZSwgcm91dGVyLCBzZXRCYXNlLCB0b1BhdGgsIHRvUmVnZXhwLCB0b1VSTCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///419\n\n}')},455:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('{\n// EXTERNAL MODULE: ./node_modules/@riotjs/hot-reload/index.js\nvar hot_reload = __webpack_require__(9);\n// EXTERNAL MODULE: ./node_modules/riot/esm/api/component.js + 1 modules\nvar component = __webpack_require__(904);\n// EXTERNAL MODULE: ./src/app.riot\nvar app = __webpack_require__(128);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/constants.js\nvar constants = __webpack_require__(604);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/misc.js\nvar misc = __webpack_require__(569);\n// EXTERNAL MODULE: ./node_modules/riot/esm/core/create-component-from-wrapper.js + 18 modules\nvar create_component_from_wrapper = __webpack_require__(643);\n;// ./node_modules/riot/esm/api/register.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {object} implementation - tag implementation\n * @param   {string} implementation.css - component css as string\n * @param   {TemplateChunk} implementation.template - component template chunk rendering function\n * @param   {object} implementation.exports - component default export\n * @returns {Map} map containing all the components implementations\n */\nfunction register(name, { css, template, exports }) {\n  if (constants/* COMPONENTS_IMPLEMENTATION_MAP */.j$.has(name))\n    (0,misc/* panic */.WQ)(`The component "${name}" was already registered`);\n\n  constants/* COMPONENTS_IMPLEMENTATION_MAP */.j$.set(\n    name,\n    (0,create_component_from_wrapper/* createComponentFromWrapper */.T)({ name, css, template, exports }),\n  );\n\n  return constants/* COMPONENTS_IMPLEMENTATION_MAP */.j$\n}\n\n\n\n;// ./src/register-global-components.ts\n\nconst basename = (path, extension = "") => path.split("/").reverse()[0].replace(extension, "");\nconst globalComponentsContext = __webpack_require__(131);\n/* harmony default export */ const register_global_components = (() => {\n    globalComponentsContext.keys().map((path) => {\n        const name = basename(path, ".riot");\n        const component = globalComponentsContext(path);\n        register(name, component.default || component);\n        return {\n            name,\n            component,\n        };\n    });\n});\n\n;// ./src/index.ts\n\n\n\n\n// register\nregister_global_components();\n// mount the root tag\nconst el = document.getElementById("root");\nel && (0,component/* component */.s)(app/* default */.A)(el);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vYXBpL3JlZ2lzdGVyLmpzPzQyY2EiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL3NyYy9yZWdpc3Rlci1nbG9iYWwtY29tcG9uZW50cy50cz83MmVjIiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9zcmMvaW5kZXgudHM/ZjZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBwYW5pYyB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvbWlzYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnRGcm9tV3JhcHBlciB9IGZyb20gJy4uL2NvcmUvY3JlYXRlLWNvbXBvbmVudC1mcm9tLXdyYXBwZXIuanMnO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY3VzdG9tIHRhZyBieSBuYW1lXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lIC0gY29tcG9uZW50IG5hbWVcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGltcGxlbWVudGF0aW9uIC0gdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBpbXBsZW1lbnRhdGlvbi5jc3MgLSBjb21wb25lbnQgY3NzIGFzIHN0cmluZ1xuICogQHBhcmFtICAge1RlbXBsYXRlQ2h1bmt9IGltcGxlbWVudGF0aW9uLnRlbXBsYXRlIC0gY29tcG9uZW50IHRlbXBsYXRlIGNodW5rIHJlbmRlcmluZyBmdW5jdGlvblxuICogQHBhcmFtICAge29iamVjdH0gaW1wbGVtZW50YXRpb24uZXhwb3J0cyAtIGNvbXBvbmVudCBkZWZhdWx0IGV4cG9ydFxuICogQHJldHVybnMge01hcH0gbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBjb21wb25lbnRzIGltcGxlbWVudGF0aW9uc1xuICovXG5mdW5jdGlvbiByZWdpc3RlcihuYW1lLCB7IGNzcywgdGVtcGxhdGUsIGV4cG9ydHMgfSkge1xuICBpZiAoQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuaGFzKG5hbWUpKVxuICAgIHBhbmljKGBUaGUgY29tcG9uZW50IFwiJHtuYW1lfVwiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcblxuICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUC5zZXQoXG4gICAgbmFtZSxcbiAgICBjcmVhdGVDb21wb25lbnRGcm9tV3JhcHBlcih7IG5hbWUsIGNzcywgdGVtcGxhdGUsIGV4cG9ydHMgfSksXG4gICk7XG5cbiAgcmV0dXJuIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQXG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyIH07XG4iLCJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gXCJyaW90XCI7XG5jb25zdCBiYXNlbmFtZSA9IChwYXRoLCBleHRlbnNpb24gPSBcIlwiKSA9PiBwYXRoLnNwbGl0KFwiL1wiKS5yZXZlcnNlKClbMF0ucmVwbGFjZShleHRlbnNpb24sIFwiXCIpO1xuY29uc3QgZ2xvYmFsQ29tcG9uZW50c0NvbnRleHQgPSBpbXBvcnQubWV0YS53ZWJwYWNrQ29udGV4dChcIi4vY29tcG9uZW50cy9nbG9iYWwvXCIsIHtcbiAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgcmVnRXhwOiAvW2EtekEtWjAtOS1dK1xcLnJpb3QvXG59KTtcbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgICBnbG9iYWxDb21wb25lbnRzQ29udGV4dC5rZXlzKCkubWFwKChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBiYXNlbmFtZShwYXRoLCBcIi5yaW90XCIpO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBnbG9iYWxDb21wb25lbnRzQ29udGV4dChwYXRoKTtcbiAgICAgICAgcmVnaXN0ZXIobmFtZSwgY29tcG9uZW50LmRlZmF1bHQgfHwgY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuIiwiaW1wb3J0IFwiQHJpb3Rqcy9ob3QtcmVsb2FkXCI7XG5pbXBvcnQgeyBjb21wb25lbnQgfSBmcm9tIFwicmlvdFwiO1xuaW1wb3J0IEFwcCBmcm9tIFwiLi9hcHAucmlvdFwiO1xuaW1wb3J0IHJlZ2lzdGVyR2xvYmFsQ29tcG9uZW50cyBmcm9tIFwiLi9yZWdpc3Rlci1nbG9iYWwtY29tcG9uZW50c1wiO1xuLy8gcmVnaXN0ZXJcbnJlZ2lzdGVyR2xvYmFsQ29tcG9uZW50cygpO1xuLy8gbW91bnQgdGhlIHJvb3QgdGFnXG5jb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKTtcbmVsICYmIGNvbXBvbmVudChBcHApKGVsKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///455\n\n}')},503:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ pure)\n/* harmony export */ });\n/* harmony import */ var _dependencies_riotjs_util_checks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(732);\n/* harmony import */ var _dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(604);\n/* harmony import */ var _dependencies_riotjs_util_misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(569);\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\nfunction pure(func) {\n  if (!(0,_dependencies_riotjs_util_checks_js__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(func))\n    (0,_dependencies_riotjs_util_misc_js__WEBPACK_IMPORTED_MODULE_2__/* .panic */ .WQ)('riot.pure accepts only arguments of type \"function\"');\n  func[_dependencies_riotjs_util_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .IS_PURE_SYMBOL */ .Db] = true;\n  return func\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vYXBpL3B1cmUuanM/OWVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY2hlY2tzLmpzJztcbmltcG9ydCB7IElTX1BVUkVfU1lNQk9MIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcGFuaWMgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL21pc2MuanMnO1xuXG4vKipcbiAqIExpZnQgYSByaW90IGNvbXBvbmVudCBJbnRlcmZhY2UgaW50byBhIHB1cmUgcmlvdCBvYmplY3RcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gZnVuYyAtIFJpb3RQdXJlQ29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIGxpZnRlZCBvcmlnaW5hbCBmdW5jdGlvbiByZWNlaXZlZCBhcyBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBwdXJlKGZ1bmMpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKVxuICAgIHBhbmljKCdyaW90LnB1cmUgYWNjZXB0cyBvbmx5IGFyZ3VtZW50cyBvZiB0eXBlIFwiZnVuY3Rpb25cIicpO1xuICBmdW5jW0lTX1BVUkVfU1lNQk9MXSA9IHRydWU7XG4gIHJldHVybiBmdW5jXG59XG5cbmV4cG9ydCB7IHB1cmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///503\n\n}")},550:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ domToArray)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2RlcGVuZGVuY2llcy9iaWFuY28uZG9tLXRvLWFycmF5L2luZGV4Lm5leHQuanM/ZGI3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG4vKipcbiAqIENvbnZlcnRzIGFueSBET00gbm9kZS9zIHRvIGEgbG9vcGFibGUgYXJyYXlcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnR8Tm9kZUxpc3QgfSBlbHMgLSBzaW5nbGUgaHRtbCBlbGVtZW50IG9yIGEgbm9kZSBsaXN0XG4gKiBAcmV0dXJucyB7IEFycmF5IH0gYWx3YXlzIGEgbG9vcGFibGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGRvbVRvQXJyYXkoZWxzKSB7XG4gIC8vIGNhbiB0aGlzIG9iamVjdCBiZSBhbHJlYWR5IGxvb3BlZD9cbiAgaWYgKCFBcnJheS5pc0FycmF5KGVscykpIHtcbiAgICAvLyBpcyBpdCBhIG5vZGUgbGlzdD9cbiAgICBpZiAoXG4gICAgICAvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvXG4gICAgICAgIC50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbHMpKVxuICAgICAgICAmJiB0eXBlb2YgZWxzLmxlbmd0aCA9PT0gJ251bWJlcidcbiAgICApXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlbHMpXG4gICAgZWxzZVxuICAgICAgLy8gaWYgaXQncyBhIHNpbmdsZSBub2RlXG4gICAgICAvLyBpdCB3aWxsIGJlIHJldHVybmVkIGFzIFwiYXJyYXlcIiB3aXRoIG9uZSBzaW5nbGUgZW50cnlcbiAgICAgIHJldHVybiBbZWxzXVxuICB9XG4gIC8vIHRoaXMgb2JqZWN0IGNvdWxkIGJlIGxvb3BlZCBvdXQgb2YgdGhlIGJveFxuICByZXR1cm4gZWxzXG59XG5cbmV4cG9ydCB7IGRvbVRvQXJyYXkgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///550\n\n}")},569:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bj: () => (/* binding */ memoize),\n/* harmony export */   WQ: () => (/* binding */ panic),\n/* harmony export */   bJ: () => (/* binding */ generatePropsFromAttributes)\n/* harmony export */ });\n/* harmony import */ var _expression_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(359);\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867);\n/* Riot WIP, @license MIT */\n\n\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @param   { string } cause - optional error cause object\n * @returns { undefined } hoppla... at this point the program should stop working\n */\nfunction panic(message, cause) {\n  throw new Error(message, { cause })\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nfunction memoize(fn) {\n  const cache = new Map();\n  const cached = (val) => {\n    return cache.has(val)\n      ? cache.get(val)\n      : cache.set(val, fn.call(this, val)) && cache.get(val)\n  };\n  cached.cache = cache;\n  return cached\n}\n\n/**\n * Generate key-value pairs from a list of attributes\n * @param   {Array} attributes - list of attributes generated by the riot compiler, each containing type, name, and evaluate function\n * @param   {Object} scope - the scope in which the attribute values will be evaluated\n * @returns {Object} An object containing key-value pairs representing the computed attribute values\n */\nfunction generatePropsFromAttributes(attributes, scope) {\n  return attributes.reduce((acc, { type, name, evaluate }) => {\n    const value = evaluate(scope);\n\n    switch (true) {\n      // spread attribute\n      case !name && type === _expression_types_js__WEBPACK_IMPORTED_MODULE_0__/* .ATTRIBUTE */ .bc:\n        return {\n          ...acc,\n          ...value,\n        }\n      // ref attribute\n      case type === _expression_types_js__WEBPACK_IMPORTED_MODULE_0__/* .REF */ .g4:\n        acc.ref = value;\n        break\n      // value attribute\n      case type === _expression_types_js__WEBPACK_IMPORTED_MODULE_0__/* .VALUE */ .Qg:\n        acc.value = value;\n        break\n      // normal attributes\n      default:\n        acc[(0,_strings_js__WEBPACK_IMPORTED_MODULE_1__/* .dashToCamelCase */ .I)(name)] = value;\n    }\n\n    return acc\n  }, {})\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL21pc2MuanM/N2I1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBWQUxVRSwgUkVGLCBBVFRSSUJVVEUgfSBmcm9tICcuL2V4cHJlc3Npb24tdHlwZXMuanMnO1xuaW1wb3J0IHsgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi9zdHJpbmdzLmpzJztcblxuLyoqXG4gKiBUaHJvdyBhbiBlcnJvciB3aXRoIGEgZGVzY3JpcHRpdmUgbWVzc2FnZVxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBtZXNzYWdlIC0gZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBjYXVzZSAtIG9wdGlvbmFsIGVycm9yIGNhdXNlIG9iamVjdFxuICogQHJldHVybnMgeyB1bmRlZmluZWQgfSBob3BwbGEuLi4gYXQgdGhpcyBwb2ludCB0aGUgcHJvZ3JhbSBzaG91bGQgc3RvcCB3b3JraW5nXG4gKi9cbmZ1bmN0aW9uIHBhbmljKG1lc3NhZ2UsIGNhdXNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLCB7IGNhdXNlIH0pXG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1lbW9pemVkIChjYWNoZWQpIGZ1bmN0aW9uLlxuICogLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL3d3dy4zMHNlY29uZHNvZmNvZGUub3JnL2pzL3MvbWVtb2l6ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBmdW5jdGlvbiB0byBtZW1vaXplXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IG1lbW9pemUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgY2FjaGVkID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBjYWNoZS5oYXModmFsKVxuICAgICAgPyBjYWNoZS5nZXQodmFsKVxuICAgICAgOiBjYWNoZS5zZXQodmFsLCBmbi5jYWxsKHRoaXMsIHZhbCkpICYmIGNhY2hlLmdldCh2YWwpXG4gIH07XG4gIGNhY2hlZC5jYWNoZSA9IGNhY2hlO1xuICByZXR1cm4gY2FjaGVkXG59XG5cbi8qKlxuICogR2VuZXJhdGUga2V5LXZhbHVlIHBhaXJzIGZyb20gYSBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAgIHtBcnJheX0gYXR0cmlidXRlcyAtIGxpc3Qgb2YgYXR0cmlidXRlcyBnZW5lcmF0ZWQgYnkgdGhlIHJpb3QgY29tcGlsZXIsIGVhY2ggY29udGFpbmluZyB0eXBlLCBuYW1lLCBhbmQgZXZhbHVhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtPYmplY3R9IHNjb3BlIC0gdGhlIHNjb3BlIGluIHdoaWNoIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHdpbGwgYmUgZXZhbHVhdGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBrZXktdmFsdWUgcGFpcnMgcmVwcmVzZW50aW5nIHRoZSBjb21wdXRlZCBhdHRyaWJ1dGUgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvcHNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBzY29wZSkge1xuICByZXR1cm4gYXR0cmlidXRlcy5yZWR1Y2UoKGFjYywgeyB0eXBlLCBuYW1lLCBldmFsdWF0ZSB9KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShzY29wZSk7XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIC8vIHNwcmVhZCBhdHRyaWJ1dGVcbiAgICAgIGNhc2UgIW5hbWUgJiYgdHlwZSA9PT0gQVRUUklCVVRFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgfVxuICAgICAgLy8gcmVmIGF0dHJpYnV0ZVxuICAgICAgY2FzZSB0eXBlID09PSBSRUY6XG4gICAgICAgIGFjYy5yZWYgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIHZhbHVlIGF0dHJpYnV0ZVxuICAgICAgY2FzZSB0eXBlID09PSBWQUxVRTpcbiAgICAgICAgYWNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBub3JtYWwgYXR0cmlidXRlc1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWNjW2Rhc2hUb0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9KVxufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVByb3BzRnJvbUF0dHJpYnV0ZXMsIG1lbW9pemUsIHBhbmljIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///569\n\n}")},604:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Db: () => (/* binding */ IS_PURE_SYMBOL),\n/* harmony export */   Dc: () => (/* binding */ IS_DIRECTIVE),\n/* harmony export */   Gm: () => (/* binding */ ON_BEFORE_MOUNT_KEY),\n/* harmony export */   IX: () => (/* binding */ ROOT_ATTRIBUTES_KEY_SYMBOL),\n/* harmony export */   Ic: () => (/* binding */ SHOULD_UPDATE_KEY),\n/* harmony export */   Jb: () => (/* binding */ ON_MOUNTED_KEY),\n/* harmony export */   KE: () => (/* binding */ UPDATE_METHOD_KEY),\n/* harmony export */   K_: () => (/* binding */ EVENT_ATTRIBUTE_RE),\n/* harmony export */   Mq: () => (/* binding */ STATE_KEY),\n/* harmony export */   QK: () => (/* binding */ ON_BEFORE_UPDATE_KEY),\n/* harmony export */   U5: () => (/* binding */ ON_UPDATED_KEY),\n/* harmony export */   YE: () => (/* binding */ MOUNT_METHOD_KEY),\n/* harmony export */   YS: () => (/* binding */ ON_UNMOUNTED_KEY),\n/* harmony export */   as: () => (/* binding */ PLUGINS_SET),\n/* harmony export */   co: () => (/* binding */ SLOTS_KEY),\n/* harmony export */   e5: () => (/* binding */ PARENT_KEY_SYMBOL),\n/* harmony export */   j$: () => (/* binding */ COMPONENTS_IMPLEMENTATION_MAP),\n/* harmony export */   jj: () => (/* binding */ VALUE_ATTRIBUTE),\n/* harmony export */   pw: () => (/* binding */ DOM_COMPONENT_INSTANCE_PROPERTY),\n/* harmony export */   qC: () => (/* binding */ TEMPLATE_KEY_SYMBOL),\n/* harmony export */   tC: () => (/* binding */ ON_BEFORE_UNMOUNT_KEY),\n/* harmony export */   tg: () => (/* binding */ REF_ATTRIBUTE),\n/* harmony export */   ts: () => (/* binding */ ROOT_KEY),\n/* harmony export */   wR: () => (/* binding */ IS_COMPONENT_UPDATING),\n/* harmony export */   zF: () => (/* binding */ PROPS_KEY),\n/* harmony export */   zr: () => (/* binding */ UNMOUNT_METHOD_KEY)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\n// Riot.js constants that can be used across more modules\n\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  VALUE_ATTRIBUTE = 'value',\n  REF_ATTRIBUTE = 'ref',\n  EVENT_ATTRIBUTE_RE = /^on/,\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template'),\n  ROOT_ATTRIBUTES_KEY_SYMBOL = Symbol('root-attributes');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanM/ODA3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG4vLyBSaW90LmpzIGNvbnN0YW50cyB0aGF0IGNhbiBiZSB1c2VkIGFjcm9zcyBtb3JlIG1vZHVsZXNcblxuY29uc3QgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAgPSBuZXcgTWFwKCksXG4gIERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFkgPSBTeW1ib2woJ3Jpb3QtY29tcG9uZW50JyksXG4gIFBMVUdJTlNfU0VUID0gbmV3IFNldCgpLFxuICBJU19ESVJFQ1RJVkUgPSAnaXMnLFxuICBWQUxVRV9BVFRSSUJVVEUgPSAndmFsdWUnLFxuICBSRUZfQVRUUklCVVRFID0gJ3JlZicsXG4gIEVWRU5UX0FUVFJJQlVURV9SRSA9IC9eb24vLFxuICBNT1VOVF9NRVRIT0RfS0VZID0gJ21vdW50JyxcbiAgVVBEQVRFX01FVEhPRF9LRVkgPSAndXBkYXRlJyxcbiAgVU5NT1VOVF9NRVRIT0RfS0VZID0gJ3VubW91bnQnLFxuICBTSE9VTERfVVBEQVRFX0tFWSA9ICdzaG91bGRVcGRhdGUnLFxuICBPTl9CRUZPUkVfTU9VTlRfS0VZID0gJ29uQmVmb3JlTW91bnQnLFxuICBPTl9NT1VOVEVEX0tFWSA9ICdvbk1vdW50ZWQnLFxuICBPTl9CRUZPUkVfVVBEQVRFX0tFWSA9ICdvbkJlZm9yZVVwZGF0ZScsXG4gIE9OX1VQREFURURfS0VZID0gJ29uVXBkYXRlZCcsXG4gIE9OX0JFRk9SRV9VTk1PVU5UX0tFWSA9ICdvbkJlZm9yZVVubW91bnQnLFxuICBPTl9VTk1PVU5URURfS0VZID0gJ29uVW5tb3VudGVkJyxcbiAgUFJPUFNfS0VZID0gJ3Byb3BzJyxcbiAgU1RBVEVfS0VZID0gJ3N0YXRlJyxcbiAgU0xPVFNfS0VZID0gJ3Nsb3RzJyxcbiAgUk9PVF9LRVkgPSAncm9vdCcsXG4gIElTX1BVUkVfU1lNQk9MID0gU3ltYm9sKCdwdXJlJyksXG4gIElTX0NPTVBPTkVOVF9VUERBVElORyA9IFN5bWJvbCgnaXNfdXBkYXRpbmcnKSxcbiAgUEFSRU5UX0tFWV9TWU1CT0wgPSBTeW1ib2woJ3BhcmVudCcpLFxuICBURU1QTEFURV9LRVlfU1lNQk9MID0gU3ltYm9sKCd0ZW1wbGF0ZScpLFxuICBST09UX0FUVFJJQlVURVNfS0VZX1NZTUJPTCA9IFN5bWJvbCgncm9vdC1hdHRyaWJ1dGVzJyk7XG5cbmV4cG9ydCB7IENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQLCBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZLCBFVkVOVF9BVFRSSUJVVEVfUkUsIElTX0NPTVBPTkVOVF9VUERBVElORywgSVNfRElSRUNUSVZFLCBJU19QVVJFX1NZTUJPTCwgTU9VTlRfTUVUSE9EX0tFWSwgT05fQkVGT1JFX01PVU5UX0tFWSwgT05fQkVGT1JFX1VOTU9VTlRfS0VZLCBPTl9CRUZPUkVfVVBEQVRFX0tFWSwgT05fTU9VTlRFRF9LRVksIE9OX1VOTU9VTlRFRF9LRVksIE9OX1VQREFURURfS0VZLCBQQVJFTlRfS0VZX1NZTUJPTCwgUExVR0lOU19TRVQsIFBST1BTX0tFWSwgUkVGX0FUVFJJQlVURSwgUk9PVF9BVFRSSUJVVEVTX0tFWV9TWU1CT0wsIFJPT1RfS0VZLCBTSE9VTERfVVBEQVRFX0tFWSwgU0xPVFNfS0VZLCBTVEFURV9LRVksIFRFTVBMQVRFX0tFWV9TWU1CT0wsIFVOTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIFZBTFVFX0FUVFJJQlVURSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///604\n\n}")},643:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  T: () => (/* binding */ createComponentFromWrapper)\n});\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/constants.js\nvar constants = __webpack_require__(604);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/strings.js\nvar strings = __webpack_require__(867);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/checks.js\nvar checks = __webpack_require__(732);\n;// ./node_modules/riot/esm/dependencies/@riotjs/util/functions.js\n/* Riot WIP, @license MIT */\n\n\n// does simply nothing\nfunction noop() {\n  return this\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nfunction autobindMethods(source, methods) {\n  methods.forEach((method) => {\n    source[method] = source[method].bind(source);\n  });\n\n  return source\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nfunction callOrAssign(source) {\n  return (0,checks/* isFunction */.Tn)(source)\n    ? source.prototype && source.prototype.constructor\n      ? new source()\n      : source()\n    : source\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/misc.js\nvar misc = __webpack_require__(569);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/dom.js\nvar dom = __webpack_require__(21);\n;// ./node_modules/riot/esm/core/mocked-template-interface.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n// Components without template use a mocked template interface with some basic functionalities to\n// guarantee consistent rendering behaviour see https://github.com/riot/riot/issues/2984\nconst MOCKED_TEMPLATE_INTERFACE = {\n  [constants/* MOUNT_METHOD_KEY */.YE](el) {\n    this.el = el;\n  },\n  [constants/* UPDATE_METHOD_KEY */.KE]: noop,\n  [constants/* UNMOUNT_METHOD_KEY */.zr](_, __, mustRemoveRoot = false) {\n    if (mustRemoveRoot) (0,dom/* removeChild */.zz)(this.el);\n    else if (!mustRemoveRoot) (0,dom/* cleanNode */.uN)(this.el);\n  },\n  clone() {\n    return { ...this }\n  },\n  createDOM: noop,\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/dom-bindings/dist/dom-bindings.js\nvar dom_bindings = __webpack_require__(116);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/expression-types.js\nvar expression_types = __webpack_require__(359);\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/binding-types.js\nvar binding_types = __webpack_require__(80);\n;// ./node_modules/riot/esm/core/component-template-factory.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {Function} getChildComponent - getter function to return the children components\n * @returns {TemplateChunk} template chunk object\n */\nfunction componentTemplateFactory(\n  template,\n  componentWrapper,\n  getChildComponent,\n) {\n  return template(\n    dom_bindings/* template */.vs,\n    expression_types/* default */.Ay,\n    binding_types/* default */.Ay,\n    getChildComponent,\n  )\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/@riotjs/util/objects.js\nvar objects = __webpack_require__(765);\n;// ./node_modules/riot/esm/core/pure-component-api.js\n/* Riot v10.0.0, @license MIT */\n\n\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [constants/* MOUNT_METHOD_KEY */.YE]: noop,\n  [constants/* UPDATE_METHOD_KEY */.KE]: noop,\n  [constants/* UNMOUNT_METHOD_KEY */.zr]: noop,\n});\n\n\n\n;// ./node_modules/riot/esm/core/bind-dom-node-to-component-instance.js\n/* Riot v10.0.0, @license MIT */\n\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {object} component - Riot.js component object\n * @returns {object} the component object received as second argument\n */\nconst bindDOMNodeToComponentInstance = (node, component) =>\n  (node[constants/* DOM_COMPONENT_INSTANCE_PROPERTY */.pw] = component);\n\n\n\n;// ./node_modules/riot/esm/core/create-core-api-methods.js\n/* Riot v10.0.0, @license MIT */\n\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {object} an object having the { mount, update, unmount } functions\n */\nfunction createCoreAPIMethods(mapFunction) {\n  return [constants/* MOUNT_METHOD_KEY */.YE, constants/* UPDATE_METHOD_KEY */.KE, constants/* UNMOUNT_METHOD_KEY */.zr].reduce(\n    (acc, method) => {\n      acc[method] = mapFunction(method);\n\n      return acc\n    },\n    {},\n  )\n}\n\n\n\n;// ./node_modules/riot/esm/core/create-pure-component.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n\n\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {object} options - pure component options\n * @param   {string} options.css - pure component can't have css\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {object} pure component object\n */\nfunction createPureComponent(\n  pureFactoryFunction,\n  { slots, attributes, props, css, template },\n) {\n  if (template) (0,misc/* panic */.WQ)('Pure components can not have html');\n  if (css) (0,misc/* panic */.WQ)('Pure components do not have css');\n\n  const component = (0,objects/* defineDefaults */.qI)(\n    pureFactoryFunction({ slots, attributes, props }),\n    PURE_COMPONENT_API,\n  );\n\n  return createCoreAPIMethods((method) => (...args) => {\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === constants/* MOUNT_METHOD_KEY */.YE) {\n      const [element] = args;\n      // mark this node as pure element\n      (0,objects/* defineProperty */.n8)(element, constants/* IS_PURE_SYMBOL */.Db, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n\n    component[method](...args);\n\n    return component\n  })\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/bianco.query/index.next.js\nvar index_next = __webpack_require__(818);\n;// ./node_modules/riot/esm/core/component-dom-selectors.js\n/* Riot v10.0.0, @license MIT */\n\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return (0,index_next/* default */.A)(selector, this.root)[0]\n  },\n  $$(selector) {\n    return (0,index_next/* default */.A)(selector, this.root)\n  },\n});\n\n\n\n;// ./node_modules/riot/esm/core/component-lifecycle-methods.js\n/* Riot v10.0.0, @license MIT */\n\n\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [constants/* SHOULD_UPDATE_KEY */.Ic]: noop,\n  [constants/* ON_BEFORE_MOUNT_KEY */.Gm]: noop,\n  [constants/* ON_MOUNTED_KEY */.Jb]: noop,\n  [constants/* ON_BEFORE_UPDATE_KEY */.QK]: noop,\n  [constants/* ON_UPDATED_KEY */.U5]: noop,\n  [constants/* ON_BEFORE_UNMOUNT_KEY */.tC]: noop,\n  [constants/* ON_UNMOUNTED_KEY */.YS]: noop,\n});\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/core/css-manager.js\nvar css_manager = __webpack_require__(781);\n;// ./node_modules/riot/esm/dependencies/curri/index.js\n/* Riot WIP, @license MIT */\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn, ...acc) {\n  return (...args) => {\n    args = [...acc, ...args];\n\n    return args.length < fn.length ?\n      curry(fn, ...args) :\n      fn(...args)\n  }\n}\n\n\n\n;// ./node_modules/riot/esm/utils/get-root-computed-attribute-names.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n/**\n * Get the computed attribute names from the template instance\n * Since these attributes will not change we memoize the result of this computation\n * @param {TemplateChunk} template - template instance\n * @returns {[]} list of attribute names that will be computed by the template expressions\n */\nconst getRootComputedAttributeNames = (0,misc/* memoize */.Bj)((template) => {\n  const firstBinding = template?.bindingsData?.[0];\n\n  // if the first binding has the selector attribute it means that it doesn't belong to the root node\n  if (firstBinding?.selector) return []\n\n  return (\n    firstBinding?.expressions?.reduce(\n      (acc, { name, type }) =>\n        type === expression_types/* default.ATTRIBUTE */.Ay.ATTRIBUTE ? acc.concat([name]) : acc,\n      [],\n    ) ?? []\n  )\n});\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/dependencies/bianco.attr/index.next.js\nvar bianco_attr_index_next = __webpack_require__(397);\n;// ./node_modules/riot/esm/utils/dom.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\nfunction getName(element) {\n  return (0,bianco_attr_index_next/* get */.J)(element, constants/* IS_DIRECTIVE */.Dc) || element.tagName.toLowerCase()\n}\n\n\n\n;// ./node_modules/riot/esm/core/add-css-hook.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    (0,bianco_attr_index_next/* set */.h)(element, constants/* IS_DIRECTIVE */.Dc, name);\n  }\n}\n\n\n\n;// ./node_modules/riot/esm/core/compute-component-state.js\n/* Riot v10.0.0, @license MIT */\n\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {object} oldState - previous state object\n * @param   {object} newState - new state given to the `update` call\n * @returns {object} new object state\n */\nfunction computeComponentState(oldState, newState) {\n  return {\n    ...oldState,\n    ...callOrAssign(newState),\n  }\n}\n\n\n\n;// ./node_modules/riot/esm/core/compute-initial-props.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {object}  initialProps - initial props\n * @returns {object} component props key value pairs\n */\nfunction computeInitialProps(element, initialProps = {}) {\n  return {\n    ...(0,dom/* DOMattributesToObject */.wN)(element),\n    ...callOrAssign(initialProps),\n  }\n}\n\n\n\n;// ./node_modules/riot/esm/core/run-plugins.js\n/* Riot v10.0.0, @license MIT */\n\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {object} component - component instance\n * @returns {object} the component enhanced by the plugins\n */\nfunction runPlugins(component) {\n  return [...constants/* PLUGINS_SET */.as].reduce((c, fn) => fn(c) || c, component)\n}\n\n\n\n;// ./node_modules/riot/esm/core/manage-component-lifecycle.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {object} component - a component implementation previously defined\n * @param   {object} options - component options\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @param   {object} options.props - component initial props\n * @returns {Riot.Component} a riot component instance\n */\nfunction manageComponentLifecycle(\n  component,\n  { slots, attributes = [], props },\n) {\n  return autobindMethods(\n    runPlugins(\n      (0,objects/* defineProperties */.ny)(\n        (0,checks/* isObject */.Gv)(component) ? Object.create(component) : component,\n        {\n          mount(element, state = {}, parentScope) {\n            // any element mounted passing through this function can't be a pure component\n            (0,objects/* defineProperty */.n8)(element, constants/* IS_PURE_SYMBOL */.Db, false);\n            this[constants/* PARENT_KEY_SYMBOL */.e5] = parentScope;\n\n            (0,objects/* defineProperty */.n8)(\n              this,\n              constants/* PROPS_KEY */.zF,\n              Object.freeze({\n                ...computeInitialProps(element, props),\n                ...(0,misc/* generatePropsFromAttributes */.bJ)(attributes, parentScope),\n              }),\n            );\n\n            this[constants/* STATE_KEY */.Mq] = computeComponentState(this[constants/* STATE_KEY */.Mq], state);\n            this[constants/* TEMPLATE_KEY_SYMBOL */.qC] = this.template.createDOM(element).clone();\n            // get the attribute names that don't belong to the props object\n            // this will avoid recursive props rendering https://github.com/riot/riot/issues/2994\n            this[constants/* ROOT_ATTRIBUTES_KEY_SYMBOL */.IX] = getRootComputedAttributeNames(\n              this[constants/* TEMPLATE_KEY_SYMBOL */.qC],\n            );\n\n            // link this object to the DOM node\n            bindDOMNodeToComponentInstance(element, this);\n            // add eventually the 'is' attribute\n            component.name && addCssHook(element, component.name);\n\n            // define the root element\n            (0,objects/* defineProperty */.n8)(this, constants/* ROOT_KEY */.ts, element);\n            // define the slots array\n            (0,objects/* defineProperty */.n8)(this, constants/* SLOTS_KEY */.co, slots);\n\n            // before mount lifecycle event\n            this[constants/* ON_BEFORE_MOUNT_KEY */.Gm](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n            // mount the template\n            this[constants/* TEMPLATE_KEY_SYMBOL */.qC].mount(element, this, parentScope);\n            this[constants/* ON_MOUNTED_KEY */.Jb](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n\n            return this\n          },\n          update(state = {}, parentScope) {\n            if (parentScope) {\n              this[constants/* PARENT_KEY_SYMBOL */.e5] = parentScope;\n            }\n\n            // filter out the computed attributes from the root node\n            const staticRootAttributes = Array.from(\n              this[constants/* ROOT_KEY */.ts].attributes,\n            ).filter(\n              ({ name }) => !this[constants/* ROOT_ATTRIBUTES_KEY_SYMBOL */.IX].includes(name),\n            );\n\n            // evaluate the value of the static dom attributes\n            const domNodeAttributes = (0,dom/* DOMattributesToObject */.wN)({\n              attributes: staticRootAttributes,\n            });\n\n            // Avoid adding the riot \"is\" directives to the component props\n            // eslint-disable-next-line no-unused-vars\n            const { [constants/* IS_DIRECTIVE */.Dc]: _, ...newProps } = {\n              ...domNodeAttributes,\n              ...(0,misc/* generatePropsFromAttributes */.bJ)(\n                attributes,\n                this[constants/* PARENT_KEY_SYMBOL */.e5],\n              ),\n            };\n            if (this[constants/* SHOULD_UPDATE_KEY */.Ic](newProps, this[constants/* PROPS_KEY */.zF]) === false)\n              return\n\n            ;(0,objects/* defineProperty */.n8)(\n              this,\n              constants/* PROPS_KEY */.zF,\n              Object.freeze({\n                // only root components will merge their initial props with the new ones\n                // children components will just get them overridden see also https://github.com/riot/riot/issues/2978\n                ...(parentScope ? null : this[constants/* PROPS_KEY */.zF]),\n                ...newProps,\n              }),\n            );\n\n            this[constants/* STATE_KEY */.Mq] = computeComponentState(this[constants/* STATE_KEY */.Mq], state);\n            this[constants/* ON_BEFORE_UPDATE_KEY */.QK](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n\n            // avoiding recursive updates\n            // see also https://github.com/riot/riot/issues/2895\n            if (!this[constants/* IS_COMPONENT_UPDATING */.wR]) {\n              this[constants/* IS_COMPONENT_UPDATING */.wR] = true;\n              this[constants/* TEMPLATE_KEY_SYMBOL */.qC].update(this, this[constants/* PARENT_KEY_SYMBOL */.e5]);\n            }\n\n            this[constants/* ON_UPDATED_KEY */.U5](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n            this[constants/* IS_COMPONENT_UPDATING */.wR] = false;\n\n            return this\n          },\n          unmount(preserveRoot) {\n            this[constants/* ON_BEFORE_UNMOUNT_KEY */.tC](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n\n            // make sure that computed root attributes get removed if the root is preserved\n            // https://github.com/riot/riot/issues/3051\n            if (preserveRoot)\n              this[constants/* ROOT_ATTRIBUTES_KEY_SYMBOL */.IX].forEach((attribute) =>\n                this[constants/* ROOT_KEY */.ts].removeAttribute(attribute),\n              );\n            // if the preserveRoot is null the template html will be left untouched\n            // in that case the DOM cleanup will happen differently from a parent node\n            this[constants/* TEMPLATE_KEY_SYMBOL */.qC].unmount(\n              this,\n              this[constants/* PARENT_KEY_SYMBOL */.e5],\n              preserveRoot === null ? null : !preserveRoot,\n            );\n            this[constants/* ON_UNMOUNTED_KEY */.YS](this[constants/* PROPS_KEY */.zF], this[constants/* STATE_KEY */.Mq]);\n\n            return this\n          },\n        },\n      ),\n    ),\n    Object.keys(component).filter((prop) => (0,checks/* isFunction */.Tn)(component[prop])),\n  )\n}\n\n\n\n;// ./node_modules/riot/esm/core/instantiate-component.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n\n\n\n\n/**\n * Component definition function\n * @param  {object} component - the component initial properties\n * @param  {string}  component.css - component css string\n * @param  {TemplateChunk} component.template - component template rendering\n * @param  {object} component.componentAPI - component export default value\n * @param  {string} component.name - component name\n * @returns {object} a new component implementation object\n */\nfunction instantiateComponent({ css, template, componentAPI, name }) {\n  // add the component css into the DOM\n  if (css && name) css_manager/* default */.Ay.add(name, css);\n\n  return curry(manageComponentLifecycle)(\n    (0,objects/* defineProperties */.ny)(\n      // set the component defaults without overriding the original component API\n      (0,objects/* defineDefaults */.qI)(componentAPI, {\n        ...COMPONENT_LIFECYCLE_METHODS,\n        [constants/* PROPS_KEY */.zF]: {},\n        [constants/* STATE_KEY */.Mq]: {},\n      }),\n      {\n        // defined during the component creation\n        [constants/* SLOTS_KEY */.co]: null,\n        [constants/* ROOT_KEY */.ts]: null,\n        // these properties should not be overriden\n        ...COMPONENT_DOM_SELECTORS,\n        name,\n        css,\n        template,\n      },\n    ),\n  )\n}\n\n\n\n;// ./node_modules/riot/esm/core/create-component-from-wrapper.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n\n\n\n\n\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {object} components - components imported in runtime\n * @returns {object} all the components transformed into Riot.Component factory functions\n */\nfunction createChildrenComponentsObject(components = {}) {\n  return Object.entries(callOrAssign(components)).reduce(\n    (acc, [key, value]) => {\n      acc[(0,strings/* camelToDashCase */.e)(key)] = createComponentFromWrapper(value);\n      return acc\n    },\n    {},\n  )\n}\n\n/**\n * Create the getter function to render the child components\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Function} function returning the component factory function\n */\nconst createChildComponentGetter = (componentWrapper) => {\n  const childrenComponents = createChildrenComponentsObject(\n    componentWrapper.exports ? componentWrapper.exports.components : {},\n  );\n\n  return (name) => {\n    // improve support for recursive components\n    if (name === componentWrapper.name)\n      return memoizedCreateComponentFromWrapper(componentWrapper)\n    // return the registered components\n    return childrenComponents[name] || constants/* COMPONENTS_IMPLEMENTATION_MAP */.j$.get(name)\n  }\n};\n\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {object} component like interface\n */\nconst memoizedCreateComponentFromWrapper = (0,misc/* memoize */.Bj)(createComponentFromWrapper);\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {object} component like interface\n */\nfunction createComponentFromWrapper(componentWrapper) {\n  const { css, template, exports, name } = componentWrapper;\n  const templateFn = template\n    ? componentTemplateFactory(\n        template,\n        componentWrapper,\n        createChildComponentGetter(componentWrapper),\n      )\n    : MOCKED_TEMPLATE_INTERFACE;\n\n  return ({ slots, attributes, props }) => {\n    // pure components rendering will be managed by the end user\n    if (exports && exports[constants/* IS_PURE_SYMBOL */.Db])\n      return createPureComponent(exports, {\n        slots,\n        attributes,\n        props,\n        css,\n        template,\n      })\n\n    const componentAPI = callOrAssign(exports) || {};\n\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name,\n    })({ slots, attributes, props });\n\n    // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope)\n      },\n      update(parentScope, state) {\n        return component.update(state, parentScope)\n      },\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot)\n      },\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZnVuY3Rpb25zLmpzPzNmZTAiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL21vY2tlZC10ZW1wbGF0ZS1pbnRlcmZhY2UuanM/YjUwYiIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2NvcmUvY29tcG9uZW50LXRlbXBsYXRlLWZhY3RvcnkuanM/YjI5NyIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2NvcmUvcHVyZS1jb21wb25lbnQtYXBpLmpzPzZjMWYiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL2JpbmQtZG9tLW5vZGUtdG8tY29tcG9uZW50LWluc3RhbmNlLmpzP2JmZmIiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL2NyZWF0ZS1jb3JlLWFwaS1tZXRob2RzLmpzP2MxNGIiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL2NyZWF0ZS1wdXJlLWNvbXBvbmVudC5qcz9lMjQ1Iiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9jb21wb25lbnQtZG9tLXNlbGVjdG9ycy5qcz81MWFhIiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9jb21wb25lbnQtbGlmZWN5Y2xlLW1ldGhvZHMuanM/ZWQ1ZSIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2RlcGVuZGVuY2llcy9jdXJyaS9pbmRleC5qcz9hOTRjIiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vdXRpbHMvZ2V0LXJvb3QtY29tcHV0ZWQtYXR0cmlidXRlLW5hbWVzLmpzPzMxNmYiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS91dGlscy9kb20uanM/MjFlNiIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2NvcmUvYWRkLWNzcy1ob29rLmpzP2IzMWQiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL2NvbXB1dGUtY29tcG9uZW50LXN0YXRlLmpzP2I3ZDYiLCJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9jb3JlL2NvbXB1dGUtaW5pdGlhbC1wcm9wcy5qcz80NTQ3Iiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9ydW4tcGx1Z2lucy5qcz9mNDZiIiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9tYW5hZ2UtY29tcG9uZW50LWxpZmVjeWNsZS5qcz9jYzcwIiwid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9pbnN0YW50aWF0ZS1jb21wb25lbnQuanM/MWJmMSIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2NvcmUvY3JlYXRlLWNvbXBvbmVudC1mcm9tLXdyYXBwZXIuanM/ODdlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9jaGVja3MuanMnO1xuXG4vLyBkb2VzIHNpbXBseSBub3RoaW5nXG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEF1dG9iaW5kIHRoZSBtZXRob2RzIG9mIGEgc291cmNlIG9iamVjdCB0byBpdHNlbGZcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHNvdXJjZSAtIHByb2JhYmx5IGEgcmlvdCB0YWcgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHtBcnJheTxzdHJpbmc+fSBtZXRob2RzIC0gbGlzdCBvZiB0aGUgbWV0aG9kcyB0byBhdXRvYmluZFxuICogQHJldHVybnMge09iamVjdH0gdGhlIG9yaWdpbmFsIG9iamVjdCByZWNlaXZlZFxuICovXG5mdW5jdGlvbiBhdXRvYmluZE1ldGhvZHMoc291cmNlLCBtZXRob2RzKSB7XG4gIG1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgc291cmNlW21ldGhvZF0gPSBzb3VyY2VbbWV0aG9kXS5iaW5kKHNvdXJjZSk7XG4gIH0pO1xuXG4gIHJldHVybiBzb3VyY2Vcbn1cblxuLyoqXG4gKiBDYWxsIHRoZSBmaXJzdCBhcmd1bWVudCByZWNlaXZlZCBvbmx5IGlmIGl0J3MgYSBmdW5jdGlvbiBvdGhlcndpc2UgcmV0dXJuIGl0IGFzIGl0IGlzXG4gKiBAcGFyYW0gICB7Kn0gc291cmNlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHsqfSBhbnl0aGluZ1xuICovXG5mdW5jdGlvbiBjYWxsT3JBc3NpZ24oc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSlcbiAgICA/IHNvdXJjZS5wcm90b3R5cGUgJiYgc291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxuICAgICAgPyBuZXcgc291cmNlKClcbiAgICAgIDogc291cmNlKClcbiAgICA6IHNvdXJjZVxufVxuXG5leHBvcnQgeyBhdXRvYmluZE1ldGhvZHMsIGNhbGxPckFzc2lnbiwgbm9vcCB9O1xuIiwiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IFVOTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIE1PVU5UX01FVEhPRF9LRVkgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyByZW1vdmVDaGlsZCwgY2xlYW5Ob2RlIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9kb20uanMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZnVuY3Rpb25zLmpzJztcblxuLy8gQ29tcG9uZW50cyB3aXRob3V0IHRlbXBsYXRlIHVzZSBhIG1vY2tlZCB0ZW1wbGF0ZSBpbnRlcmZhY2Ugd2l0aCBzb21lIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyB0b1xuLy8gZ3VhcmFudGVlIGNvbnNpc3RlbnQgcmVuZGVyaW5nIGJlaGF2aW91ciBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Jpb3QvcmlvdC9pc3N1ZXMvMjk4NFxuY29uc3QgTU9DS0VEX1RFTVBMQVRFX0lOVEVSRkFDRSA9IHtcbiAgW01PVU5UX01FVEhPRF9LRVldKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICB9LFxuICBbVVBEQVRFX01FVEhPRF9LRVldOiBub29wLFxuICBbVU5NT1VOVF9NRVRIT0RfS0VZXShfLCBfXywgbXVzdFJlbW92ZVJvb3QgPSBmYWxzZSkge1xuICAgIGlmIChtdXN0UmVtb3ZlUm9vdCkgcmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgZWxzZSBpZiAoIW11c3RSZW1vdmVSb290KSBjbGVhbk5vZGUodGhpcy5lbCk7XG4gIH0sXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMgfVxuICB9LFxuICBjcmVhdGVET006IG5vb3AsXG59O1xuXG5leHBvcnQgeyBNT0NLRURfVEVNUExBVEVfSU5URVJGQUNFIH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgdGVtcGxhdGUgYXMgY3JlYXRlIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvZG9tLWJpbmRpbmdzL2Rpc3QvZG9tLWJpbmRpbmdzLmpzJztcbmltcG9ydCBleHByZXNzaW9uVHlwZXMgZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9leHByZXNzaW9uLXR5cGVzLmpzJztcbmltcG9ydCBiaW5kaW5nVHlwZXMgZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9iaW5kaW5nLXR5cGVzLmpzJztcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50IHRlbXBsYXRlcyBvbmx5IG9uY2VcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gdGVtcGxhdGUgLSBjb21wb25lbnQgdGVtcGxhdGUgY3JlYXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtSaW90Q29tcG9uZW50V3JhcHBlcn0gY29tcG9uZW50V3JhcHBlciAtIHJpb3QgY29tcGlsZXIgZ2VuZXJhdGVkIG9iamVjdFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBnZXRDaGlsZENvbXBvbmVudCAtIGdldHRlciBmdW5jdGlvbiB0byByZXR1cm4gdGhlIGNoaWxkcmVuIGNvbXBvbmVudHNcbiAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSB0ZW1wbGF0ZSBjaHVuayBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5KFxuICB0ZW1wbGF0ZSxcbiAgY29tcG9uZW50V3JhcHBlcixcbiAgZ2V0Q2hpbGRDb21wb25lbnQsXG4pIHtcbiAgcmV0dXJuIHRlbXBsYXRlKFxuICAgIGNyZWF0ZSxcbiAgICBleHByZXNzaW9uVHlwZXMsXG4gICAgYmluZGluZ1R5cGVzLFxuICAgIGdldENoaWxkQ29tcG9uZW50LFxuICApXG59XG5cbmV4cG9ydCB7IGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSB9O1xuIiwiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IFVOTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIE1PVU5UX01FVEhPRF9LRVkgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9mdW5jdGlvbnMuanMnO1xuXG5jb25zdCBQVVJFX0NPTVBPTkVOVF9BUEkgPSBPYmplY3QuZnJlZXplKHtcbiAgW01PVU5UX01FVEhPRF9LRVldOiBub29wLFxuICBbVVBEQVRFX01FVEhPRF9LRVldOiBub29wLFxuICBbVU5NT1VOVF9NRVRIT0RfS0VZXTogbm9vcCxcbn0pO1xuXG5leHBvcnQgeyBQVVJFX0NPTVBPTkVOVF9BUEkgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEJpbmQgYSBET00gbm9kZSB0byBpdHMgY29tcG9uZW50IG9iamVjdFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gaHRtbCBub2RlIG1vdW50ZWRcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGNvbXBvbmVudCAtIFJpb3QuanMgY29tcG9uZW50IG9iamVjdFxuICogQHJldHVybnMge29iamVjdH0gdGhlIGNvbXBvbmVudCBvYmplY3QgcmVjZWl2ZWQgYXMgc2Vjb25kIGFyZ3VtZW50XG4gKi9cbmNvbnN0IGJpbmRET01Ob2RlVG9Db21wb25lbnRJbnN0YW5jZSA9IChub2RlLCBjb21wb25lbnQpID0+XG4gIChub2RlW0RPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFldID0gY29tcG9uZW50KTtcblxuZXhwb3J0IHsgYmluZERPTU5vZGVUb0NvbXBvbmVudEluc3RhbmNlIH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIFVOTU9VTlRfTUVUSE9EX0tFWSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBXcmFwIHRoZSBSaW90LmpzIGNvcmUgQVBJIG1ldGhvZHMgdXNpbmcgYSBtYXBwaW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IG1hcEZ1bmN0aW9uIC0gbGlmdGluZyBmdW5jdGlvblxuICogQHJldHVybnMge29iamVjdH0gYW4gb2JqZWN0IGhhdmluZyB0aGUgeyBtb3VudCwgdXBkYXRlLCB1bm1vdW50IH0gZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvcmVBUElNZXRob2RzKG1hcEZ1bmN0aW9uKSB7XG4gIHJldHVybiBbTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIFVOTU9VTlRfTUVUSE9EX0tFWV0ucmVkdWNlKFxuICAgIChhY2MsIG1ldGhvZCkgPT4ge1xuICAgICAgYWNjW21ldGhvZF0gPSBtYXBGdW5jdGlvbihtZXRob2QpO1xuXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSxcbiAgICB7fSxcbiAgKVxufVxuXG5leHBvcnQgeyBjcmVhdGVDb3JlQVBJTWV0aG9kcyB9O1xuIiwiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IE1PVU5UX01FVEhPRF9LRVksIElTX1BVUkVfU1lNQk9MIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcGFuaWMgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL21pc2MuanMnO1xuaW1wb3J0IHsgZGVmaW5lRGVmYXVsdHMsIGRlZmluZVByb3BlcnR5IH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9vYmplY3RzLmpzJztcbmltcG9ydCB7IFBVUkVfQ09NUE9ORU5UX0FQSSB9IGZyb20gJy4vcHVyZS1jb21wb25lbnQtYXBpLmpzJztcbmltcG9ydCB7IGJpbmRET01Ob2RlVG9Db21wb25lbnRJbnN0YW5jZSB9IGZyb20gJy4vYmluZC1kb20tbm9kZS10by1jb21wb25lbnQtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ29yZUFQSU1ldGhvZHMgfSBmcm9tICcuL2NyZWF0ZS1jb3JlLWFwaS1tZXRob2RzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYSBwdXJlIGNvbXBvbmVudFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBwdXJlRmFjdG9yeUZ1bmN0aW9uIC0gcHVyZSBjb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge29iamVjdH0gb3B0aW9ucyAtIHB1cmUgY29tcG9uZW50IG9wdGlvbnNcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMuY3NzIC0gcHVyZSBjb21wb25lbnQgY2FuJ3QgaGF2ZSBjc3NcbiAqIEBwYXJhbSAgIHtBcnJheX0gb3B0aW9ucy5zbG90cyAtIGNvbXBvbmVudCBzbG90c1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLmF0dHJpYnV0ZXMgLSBjb21wb25lbnQgYXR0cmlidXRlc1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnRlbXBsYXRlIC0gdGVtcGxhdGUgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge2FueX0gb3B0aW9ucy5wcm9wcyAtIGluaXRpYWwgY29tcG9uZW50IHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IHB1cmUgY29tcG9uZW50IG9iamVjdFxuICovXG5mdW5jdGlvbiBjcmVhdGVQdXJlQ29tcG9uZW50KFxuICBwdXJlRmFjdG9yeUZ1bmN0aW9uLFxuICB7IHNsb3RzLCBhdHRyaWJ1dGVzLCBwcm9wcywgY3NzLCB0ZW1wbGF0ZSB9LFxuKSB7XG4gIGlmICh0ZW1wbGF0ZSkgcGFuaWMoJ1B1cmUgY29tcG9uZW50cyBjYW4gbm90IGhhdmUgaHRtbCcpO1xuICBpZiAoY3NzKSBwYW5pYygnUHVyZSBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGNzcycpO1xuXG4gIGNvbnN0IGNvbXBvbmVudCA9IGRlZmluZURlZmF1bHRzKFxuICAgIHB1cmVGYWN0b3J5RnVuY3Rpb24oeyBzbG90cywgYXR0cmlidXRlcywgcHJvcHMgfSksXG4gICAgUFVSRV9DT01QT05FTlRfQVBJLFxuICApO1xuXG4gIHJldHVybiBjcmVhdGVDb3JlQVBJTWV0aG9kcygobWV0aG9kKSA9PiAoLi4uYXJncykgPT4ge1xuICAgIC8vIGludGVyY2VwdCB0aGUgbW91bnQgY2FsbHMgdG8gYmluZCB0aGUgRE9NIG5vZGUgdG8gdGhlIHB1cmUgb2JqZWN0IGNyZWF0ZWRcbiAgICAvLyBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcmlvdC9yaW90L2lzc3Vlcy8yODA2XG4gICAgaWYgKG1ldGhvZCA9PT0gTU9VTlRfTUVUSE9EX0tFWSkge1xuICAgICAgY29uc3QgW2VsZW1lbnRdID0gYXJncztcbiAgICAgIC8vIG1hcmsgdGhpcyBub2RlIGFzIHB1cmUgZWxlbWVudFxuICAgICAgZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgSVNfUFVSRV9TWU1CT0wsIHRydWUpO1xuICAgICAgYmluZERPTU5vZGVUb0NvbXBvbmVudEluc3RhbmNlKGVsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50W21ldGhvZF0oLi4uYXJncyk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50XG4gIH0pXG59XG5cbmV4cG9ydCB7IGNyZWF0ZVB1cmVDb21wb25lbnQgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgJCBmcm9tICcuLi9kZXBlbmRlbmNpZXMvYmlhbmNvLnF1ZXJ5L2luZGV4Lm5leHQuanMnO1xuXG5jb25zdCBDT01QT05FTlRfRE9NX1NFTEVDVE9SUyA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBjb21wb25lbnQgaGVscGVyc1xuICAkKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIHRoaXMucm9vdClbMF1cbiAgfSxcbiAgJCQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gJChzZWxlY3RvciwgdGhpcy5yb290KVxuICB9LFxufSk7XG5cbmV4cG9ydCB7IENPTVBPTkVOVF9ET01fU0VMRUNUT1JTIH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgT05fVU5NT1VOVEVEX0tFWSwgT05fQkVGT1JFX1VOTU9VTlRfS0VZLCBPTl9VUERBVEVEX0tFWSwgT05fQkVGT1JFX1VQREFURV9LRVksIE9OX01PVU5URURfS0VZLCBPTl9CRUZPUkVfTU9VTlRfS0VZLCBTSE9VTERfVVBEQVRFX0tFWSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2Z1bmN0aW9ucy5qcyc7XG5cbmNvbnN0IENPTVBPTkVOVF9MSUZFQ1lDTEVfTUVUSE9EUyA9IE9iamVjdC5mcmVlemUoe1xuICBbU0hPVUxEX1VQREFURV9LRVldOiBub29wLFxuICBbT05fQkVGT1JFX01PVU5UX0tFWV06IG5vb3AsXG4gIFtPTl9NT1VOVEVEX0tFWV06IG5vb3AsXG4gIFtPTl9CRUZPUkVfVVBEQVRFX0tFWV06IG5vb3AsXG4gIFtPTl9VUERBVEVEX0tFWV06IG5vb3AsXG4gIFtPTl9CRUZPUkVfVU5NT1VOVF9LRVldOiBub29wLFxuICBbT05fVU5NT1VOVEVEX0tFWV06IG5vb3AsXG59KTtcblxuZXhwb3J0IHsgQ09NUE9ORU5UX0xJRkVDWUNMRV9NRVRIT0RTIH07XG4iLCIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGN1cnJ5IGFueSBqYXZhc2NyaXB0IG1ldGhvZFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm4gLSB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdlIHdhbnQgdG8gY3VycnlcbiAqIEBwYXJhbSAgIHsuLi5bYXJnc119IGFjYyAtIGluaXRpYWwgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258Kn0gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB1bnRpbCB0aGUgdGFyZ2V0IGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCByZWNlaXZlIGFsbCBvZiBpdHMgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuLCAuLi5hY2MpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IFsuLi5hY2MsIC4uLmFyZ3NdO1xuXG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgZm4ubGVuZ3RoID9cbiAgICAgIGN1cnJ5KGZuLCAuLi5hcmdzKSA6XG4gICAgICBmbiguLi5hcmdzKVxuICB9XG59XG5cbmV4cG9ydCB7IGN1cnJ5IGFzIGRlZmF1bHQgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL2RvbS1iaW5kaW5ncy9kaXN0L2RvbS1iaW5kaW5ncy5qcyc7XG5pbXBvcnQgZXhwcmVzc2lvblR5cGVzIGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZXhwcmVzc2lvbi10eXBlcy5qcyc7XG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9taXNjLmpzJztcblxuLyoqXG4gKiBHZXQgdGhlIGNvbXB1dGVkIGF0dHJpYnV0ZSBuYW1lcyBmcm9tIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZVxuICogU2luY2UgdGhlc2UgYXR0cmlidXRlcyB3aWxsIG5vdCBjaGFuZ2Ugd2UgbWVtb2l6ZSB0aGUgcmVzdWx0IG9mIHRoaXMgY29tcHV0YXRpb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVDaHVua30gdGVtcGxhdGUgLSB0ZW1wbGF0ZSBpbnN0YW5jZVxuICogQHJldHVybnMge1tdfSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYnkgdGhlIHRlbXBsYXRlIGV4cHJlc3Npb25zXG4gKi9cbmNvbnN0IGdldFJvb3RDb21wdXRlZEF0dHJpYnV0ZU5hbWVzID0gbWVtb2l6ZSgodGVtcGxhdGUpID0+IHtcbiAgY29uc3QgZmlyc3RCaW5kaW5nID0gdGVtcGxhdGU/LmJpbmRpbmdzRGF0YT8uWzBdO1xuXG4gIC8vIGlmIHRoZSBmaXJzdCBiaW5kaW5nIGhhcyB0aGUgc2VsZWN0b3IgYXR0cmlidXRlIGl0IG1lYW5zIHRoYXQgaXQgZG9lc24ndCBiZWxvbmcgdG8gdGhlIHJvb3Qgbm9kZVxuICBpZiAoZmlyc3RCaW5kaW5nPy5zZWxlY3RvcikgcmV0dXJuIFtdXG5cbiAgcmV0dXJuIChcbiAgICBmaXJzdEJpbmRpbmc/LmV4cHJlc3Npb25zPy5yZWR1Y2UoXG4gICAgICAoYWNjLCB7IG5hbWUsIHR5cGUgfSkgPT5cbiAgICAgICAgdHlwZSA9PT0gZXhwcmVzc2lvblR5cGVzLkFUVFJJQlVURSA/IGFjYy5jb25jYXQoW25hbWVdKSA6IGFjYyxcbiAgICAgIFtdLFxuICAgICkgPz8gW11cbiAgKVxufSk7XG5cbmV4cG9ydCB7IGdldFJvb3RDb21wdXRlZEF0dHJpYnV0ZU5hbWVzIH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgSVNfRElSRUNUSVZFIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2JpYW5jby5hdHRyL2luZGV4Lm5leHQuanMnO1xuXG4vKipcbiAqIEdldCB0aGUgdGFnIG5hbWUgb2YgYW55IERPTSBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBET00gbm9kZSB3ZSB3YW50IHRvIGluc3BlY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG5hbWUgdG8gaWRlbnRpZnkgdGhpcyBkb20gbm9kZSBpbiByaW90XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0KGVsZW1lbnQsIElTX0RJUkVDVElWRSkgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZXhwb3J0IHsgZ2V0TmFtZSB9O1xuIiwiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IElTX0RJUkVDVElWRSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldE5hbWUgfSBmcm9tICcuLi91dGlscy9kb20uanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2JpYW5jby5hdHRyL2luZGV4Lm5leHQuanMnO1xuXG4vKipcbiAqIEFkZCBldmVudHVhbGx5IHRoZSBcImlzXCIgYXR0cmlidXRlIHRvIGxpbmsgdGhpcyBET00gbm9kZSB0byBpdHMgY3NzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gdGFyZ2V0IHJvb3Qgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBjb21wb25lbnQgbW91bnRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaXQncyBhIHZvaWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBhZGRDc3NIb29rKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKGdldE5hbWUoZWxlbWVudCkgIT09IG5hbWUpIHtcbiAgICBzZXQoZWxlbWVudCwgSVNfRElSRUNUSVZFLCBuYW1lKTtcbiAgfVxufVxuXG5leHBvcnQgeyBhZGRDc3NIb29rIH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgY2FsbE9yQXNzaWduIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNvbXBvbmVudCBjdXJyZW50IHN0YXRlIG1lcmdpbmcgaXQgd2l0aCBpdHMgcHJldmlvdXMgc3RhdGVcbiAqIEBwYXJhbSAgIHtvYmplY3R9IG9sZFN0YXRlIC0gcHJldmlvdXMgc3RhdGUgb2JqZWN0XG4gKiBAcGFyYW0gICB7b2JqZWN0fSBuZXdTdGF0ZSAtIG5ldyBzdGF0ZSBnaXZlbiB0byB0aGUgYHVwZGF0ZWAgY2FsbFxuICogQHJldHVybnMge29iamVjdH0gbmV3IG9iamVjdCBzdGF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQ29tcG9uZW50U3RhdGUob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgLi4ub2xkU3RhdGUsXG4gICAgLi4uY2FsbE9yQXNzaWduKG5ld1N0YXRlKSxcbiAgfVxufVxuXG5leHBvcnQgeyBjb21wdXRlQ29tcG9uZW50U3RhdGUgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBET01hdHRyaWJ1dGVzVG9PYmplY3QgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2RvbS5qcyc7XG5pbXBvcnQgeyBjYWxsT3JBc3NpZ24gfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2Z1bmN0aW9ucy5qcyc7XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGVpdGhlciBmcm9tIGl0cyByZWFsIGF0dHJpYnV0ZXMgb3IgZnJvbSBpdHMgaW5pdGlhbCB1c2VyIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGNvbXBvbmVudCByb290XG4gKiBAcGFyYW0gICB7b2JqZWN0fSAgaW5pdGlhbFByb3BzIC0gaW5pdGlhbCBwcm9wc1xuICogQHJldHVybnMge29iamVjdH0gY29tcG9uZW50IHByb3BzIGtleSB2YWx1ZSBwYWlyc1xuICovXG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFByb3BzKGVsZW1lbnQsIGluaXRpYWxQcm9wcyA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uRE9NYXR0cmlidXRlc1RvT2JqZWN0KGVsZW1lbnQpLFxuICAgIC4uLmNhbGxPckFzc2lnbihpbml0aWFsUHJvcHMpLFxuICB9XG59XG5cbmV4cG9ydCB7IGNvbXB1dGVJbml0aWFsUHJvcHMgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBQTFVHSU5TX1NFVCB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBSdW4gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0aHJvdWdoIGFsbCB0aGUgcGx1Z2lucyBzZXQgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGNvbXBvbmVudCAtIGNvbXBvbmVudCBpbnN0YW5jZVxuICogQHJldHVybnMge29iamVjdH0gdGhlIGNvbXBvbmVudCBlbmhhbmNlZCBieSB0aGUgcGx1Z2luc1xuICovXG5mdW5jdGlvbiBydW5QbHVnaW5zKGNvbXBvbmVudCkge1xuICByZXR1cm4gWy4uLlBMVUdJTlNfU0VUXS5yZWR1Y2UoKGMsIGZuKSA9PiBmbihjKSB8fCBjLCBjb21wb25lbnQpXG59XG5cbmV4cG9ydCB7IHJ1blBsdWdpbnMgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY2hlY2tzLmpzJztcbmltcG9ydCB7IE9OX0JFRk9SRV9VTk1PVU5UX0tFWSwgUFJPUFNfS0VZLCBTVEFURV9LRVksIFJPT1RfQVRUUklCVVRFU19LRVlfU1lNQk9MLCBST09UX0tFWSwgVEVNUExBVEVfS0VZX1NZTUJPTCwgUEFSRU5UX0tFWV9TWU1CT0wsIE9OX1VOTU9VTlRFRF9LRVksIFNIT1VMRF9VUERBVEVfS0VZLCBPTl9CRUZPUkVfVVBEQVRFX0tFWSwgSVNfQ09NUE9ORU5UX1VQREFUSU5HLCBPTl9VUERBVEVEX0tFWSwgSVNfUFVSRV9TWU1CT0wsIFNMT1RTX0tFWSwgT05fQkVGT1JFX01PVU5UX0tFWSwgT05fTU9VTlRFRF9LRVksIElTX0RJUkVDVElWRSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERPTWF0dHJpYnV0ZXNUb09iamVjdCB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZG9tLmpzJztcbmltcG9ydCB7IGF1dG9iaW5kTWV0aG9kcyB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlUHJvcHNGcm9tQXR0cmlidXRlcyB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvbWlzYy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBkZWZpbmVQcm9wZXJ0eSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvb2JqZWN0cy5qcyc7XG5pbXBvcnQgeyBnZXRSb290Q29tcHV0ZWRBdHRyaWJ1dGVOYW1lcyB9IGZyb20gJy4uL3V0aWxzL2dldC1yb290LWNvbXB1dGVkLWF0dHJpYnV0ZS1uYW1lcy5qcyc7XG5pbXBvcnQgeyBhZGRDc3NIb29rIH0gZnJvbSAnLi9hZGQtY3NzLWhvb2suanMnO1xuaW1wb3J0IHsgYmluZERPTU5vZGVUb0NvbXBvbmVudEluc3RhbmNlIH0gZnJvbSAnLi9iaW5kLWRvbS1ub2RlLXRvLWNvbXBvbmVudC1pbnN0YW5jZS5qcyc7XG5pbXBvcnQgeyBjb21wdXRlQ29tcG9uZW50U3RhdGUgfSBmcm9tICcuL2NvbXB1dGUtY29tcG9uZW50LXN0YXRlLmpzJztcbmltcG9ydCB7IGNvbXB1dGVJbml0aWFsUHJvcHMgfSBmcm9tICcuL2NvbXB1dGUtaW5pdGlhbC1wcm9wcy5qcyc7XG5pbXBvcnQgeyBydW5QbHVnaW5zIH0gZnJvbSAnLi9ydW4tcGx1Z2lucy5qcyc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNyZWF0aW9uIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCB3aWxsIGVuaGFuY2UgdGhlIHVzZXIgcHJvdmlkZWQgQVBJXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBjb21wb25lbnQgLSBhIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiBwcmV2aW91c2x5IGRlZmluZWRcbiAqIEBwYXJhbSAgIHtvYmplY3R9IG9wdGlvbnMgLSBjb21wb25lbnQgb3B0aW9uc1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnNsb3RzIC0gY29tcG9uZW50IHNsb3RzIGdlbmVyYXRlZCB2aWEgcmlvdCBjb21waWxlclxuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLmF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgZXhwcmVzc2lvbnMgZ2VuZXJhdGVkIHZpYSByaW90IGNvbXBpbGVyXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBvcHRpb25zLnByb3BzIC0gY29tcG9uZW50IGluaXRpYWwgcHJvcHNcbiAqIEByZXR1cm5zIHtSaW90LkNvbXBvbmVudH0gYSByaW90IGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBtYW5hZ2VDb21wb25lbnRMaWZlY3ljbGUoXG4gIGNvbXBvbmVudCxcbiAgeyBzbG90cywgYXR0cmlidXRlcyA9IFtdLCBwcm9wcyB9LFxuKSB7XG4gIHJldHVybiBhdXRvYmluZE1ldGhvZHMoXG4gICAgcnVuUGx1Z2lucyhcbiAgICAgIGRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgIGlzT2JqZWN0KGNvbXBvbmVudCkgPyBPYmplY3QuY3JlYXRlKGNvbXBvbmVudCkgOiBjb21wb25lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb3VudChlbGVtZW50LCBzdGF0ZSA9IHt9LCBwYXJlbnRTY29wZSkge1xuICAgICAgICAgICAgLy8gYW55IGVsZW1lbnQgbW91bnRlZCBwYXNzaW5nIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBjYW4ndCBiZSBhIHB1cmUgY29tcG9uZW50XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBJU19QVVJFX1NZTUJPTCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpc1tQQVJFTlRfS0VZX1NZTUJPTF0gPSBwYXJlbnRTY29wZTtcblxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIFBST1BTX0tFWSxcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgLi4uY29tcHV0ZUluaXRpYWxQcm9wcyhlbGVtZW50LCBwcm9wcyksXG4gICAgICAgICAgICAgICAgLi4uZ2VuZXJhdGVQcm9wc0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIHBhcmVudFNjb3BlKSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzW1NUQVRFX0tFWV0gPSBjb21wdXRlQ29tcG9uZW50U3RhdGUodGhpc1tTVEFURV9LRVldLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzW1RFTVBMQVRFX0tFWV9TWU1CT0xdID0gdGhpcy50ZW1wbGF0ZS5jcmVhdGVET00oZWxlbWVudCkuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIG5hbWVzIHRoYXQgZG9uJ3QgYmVsb25nIHRvIHRoZSBwcm9wcyBvYmplY3RcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhdm9pZCByZWN1cnNpdmUgcHJvcHMgcmVuZGVyaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI5OTRcbiAgICAgICAgICAgIHRoaXNbUk9PVF9BVFRSSUJVVEVTX0tFWV9TWU1CT0xdID0gZ2V0Um9vdENvbXB1dGVkQXR0cmlidXRlTmFtZXMoXG4gICAgICAgICAgICAgIHRoaXNbVEVNUExBVEVfS0VZX1NZTUJPTF0sXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBsaW5rIHRoaXMgb2JqZWN0IHRvIHRoZSBET00gbm9kZVxuICAgICAgICAgICAgYmluZERPTU5vZGVUb0NvbXBvbmVudEluc3RhbmNlKGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgICAgLy8gYWRkIGV2ZW50dWFsbHkgdGhlICdpcycgYXR0cmlidXRlXG4gICAgICAgICAgICBjb21wb25lbnQubmFtZSAmJiBhZGRDc3NIb29rKGVsZW1lbnQsIGNvbXBvbmVudC5uYW1lKTtcblxuICAgICAgICAgICAgLy8gZGVmaW5lIHRoZSByb290IGVsZW1lbnRcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIFJPT1RfS0VZLCBlbGVtZW50KTtcbiAgICAgICAgICAgIC8vIGRlZmluZSB0aGUgc2xvdHMgYXJyYXlcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIFNMT1RTX0tFWSwgc2xvdHMpO1xuXG4gICAgICAgICAgICAvLyBiZWZvcmUgbW91bnQgbGlmZWN5Y2xlIGV2ZW50XG4gICAgICAgICAgICB0aGlzW09OX0JFRk9SRV9NT1VOVF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgICAgICAgIC8vIG1vdW50IHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgdGhpc1tURU1QTEFURV9LRVlfU1lNQk9MXS5tb3VudChlbGVtZW50LCB0aGlzLCBwYXJlbnRTY29wZSk7XG4gICAgICAgICAgICB0aGlzW09OX01PVU5URURfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cGRhdGUoc3RhdGUgPSB7fSwgcGFyZW50U2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTY29wZSkge1xuICAgICAgICAgICAgICB0aGlzW1BBUkVOVF9LRVlfU1lNQk9MXSA9IHBhcmVudFNjb3BlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoZSBjb21wdXRlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIHJvb3Qgbm9kZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGljUm9vdEF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgICB0aGlzW1JPT1RfS0VZXS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgKS5maWx0ZXIoXG4gICAgICAgICAgICAgICh7IG5hbWUgfSkgPT4gIXRoaXNbUk9PVF9BVFRSSUJVVEVTX0tFWV9TWU1CT0xdLmluY2x1ZGVzKG5hbWUpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gZXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSBzdGF0aWMgZG9tIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNvbnN0IGRvbU5vZGVBdHRyaWJ1dGVzID0gRE9NYXR0cmlidXRlc1RvT2JqZWN0KHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc3RhdGljUm9vdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXZvaWQgYWRkaW5nIHRoZSByaW90IFwiaXNcIiBkaXJlY3RpdmVzIHRvIHRoZSBjb21wb25lbnQgcHJvcHNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgeyBbSVNfRElSRUNUSVZFXTogXywgLi4ubmV3UHJvcHMgfSA9IHtcbiAgICAgICAgICAgICAgLi4uZG9tTm9kZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIC4uLmdlbmVyYXRlUHJvcHNGcm9tQXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHRoaXNbUEFSRU5UX0tFWV9TWU1CT0xdLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzW1NIT1VMRF9VUERBVEVfS0VZXShuZXdQcm9wcywgdGhpc1tQUk9QU19LRVldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgUFJPUFNfS0VZLFxuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJvb3QgY29tcG9uZW50cyB3aWxsIG1lcmdlIHRoZWlyIGluaXRpYWwgcHJvcHMgd2l0aCB0aGUgbmV3IG9uZXNcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBjb21wb25lbnRzIHdpbGwganVzdCBnZXQgdGhlbSBvdmVycmlkZGVuIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI5NzhcbiAgICAgICAgICAgICAgICAuLi4ocGFyZW50U2NvcGUgPyBudWxsIDogdGhpc1tQUk9QU19LRVldKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdQcm9wcyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzW1NUQVRFX0tFWV0gPSBjb21wdXRlQ29tcG9uZW50U3RhdGUodGhpc1tTVEFURV9LRVldLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzW09OX0JFRk9SRV9VUERBVEVfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7XG5cbiAgICAgICAgICAgIC8vIGF2b2lkaW5nIHJlY3Vyc2l2ZSB1cGRhdGVzXG4gICAgICAgICAgICAvLyBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcmlvdC9yaW90L2lzc3Vlcy8yODk1XG4gICAgICAgICAgICBpZiAoIXRoaXNbSVNfQ09NUE9ORU5UX1VQREFUSU5HXSkge1xuICAgICAgICAgICAgICB0aGlzW0lTX0NPTVBPTkVOVF9VUERBVElOR10gPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzW1RFTVBMQVRFX0tFWV9TWU1CT0xdLnVwZGF0ZSh0aGlzLCB0aGlzW1BBUkVOVF9LRVlfU1lNQk9MXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNbT05fVVBEQVRFRF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgICAgICAgIHRoaXNbSVNfQ09NUE9ORU5UX1VQREFUSU5HXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5tb3VudChwcmVzZXJ2ZVJvb3QpIHtcbiAgICAgICAgICAgIHRoaXNbT05fQkVGT1JFX1VOTU9VTlRfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGNvbXB1dGVkIHJvb3QgYXR0cmlidXRlcyBnZXQgcmVtb3ZlZCBpZiB0aGUgcm9vdCBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzMwNTFcbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVJvb3QpXG4gICAgICAgICAgICAgIHRoaXNbUk9PVF9BVFRSSUJVVEVTX0tFWV9TWU1CT0xdLmZvckVhY2goKGF0dHJpYnV0ZSkgPT5cbiAgICAgICAgICAgICAgICB0aGlzW1JPT1RfS0VZXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmVzZXJ2ZVJvb3QgaXMgbnVsbCB0aGUgdGVtcGxhdGUgaHRtbCB3aWxsIGJlIGxlZnQgdW50b3VjaGVkXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgdGhlIERPTSBjbGVhbnVwIHdpbGwgaGFwcGVuIGRpZmZlcmVudGx5IGZyb20gYSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgdGhpc1tURU1QTEFURV9LRVlfU1lNQk9MXS51bm1vdW50KFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICB0aGlzW1BBUkVOVF9LRVlfU1lNQk9MXSxcbiAgICAgICAgICAgICAgcHJlc2VydmVSb290ID09PSBudWxsID8gbnVsbCA6ICFwcmVzZXJ2ZVJvb3QsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpc1tPTl9VTk1PVU5URURfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKSxcbiAgICBPYmplY3Qua2V5cyhjb21wb25lbnQpLmZpbHRlcigocHJvcCkgPT4gaXNGdW5jdGlvbihjb21wb25lbnRbcHJvcF0pKSxcbiAgKVxufVxuXG5leHBvcnQgeyBtYW5hZ2VDb21wb25lbnRMaWZlY3ljbGUgfTtcbiIsIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgeyBST09UX0tFWSwgU0xPVFNfS0VZLCBTVEFURV9LRVksIFBST1BTX0tFWSB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGRlZmluZURlZmF1bHRzIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9vYmplY3RzLmpzJztcbmltcG9ydCB7IENPTVBPTkVOVF9ET01fU0VMRUNUT1JTIH0gZnJvbSAnLi9jb21wb25lbnQtZG9tLXNlbGVjdG9ycy5qcyc7XG5pbXBvcnQgeyBDT01QT05FTlRfTElGRUNZQ0xFX01FVEhPRFMgfSBmcm9tICcuL2NvbXBvbmVudC1saWZlY3ljbGUtbWV0aG9kcy5qcyc7XG5pbXBvcnQgY3NzTWFuYWdlciBmcm9tICcuL2Nzcy1tYW5hZ2VyLmpzJztcbmltcG9ydCBjdXJyeSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvY3VycmkvaW5kZXguanMnO1xuaW1wb3J0IHsgbWFuYWdlQ29tcG9uZW50TGlmZWN5Y2xlIH0gZnJvbSAnLi9tYW5hZ2UtY29tcG9uZW50LWxpZmVjeWNsZS5qcyc7XG5cbi8qKlxuICogQ29tcG9uZW50IGRlZmluaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSAge29iamVjdH0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBpbml0aWFsIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAge3N0cmluZ30gIGNvbXBvbmVudC5jc3MgLSBjb21wb25lbnQgY3NzIHN0cmluZ1xuICogQHBhcmFtICB7VGVtcGxhdGVDaHVua30gY29tcG9uZW50LnRlbXBsYXRlIC0gY29tcG9uZW50IHRlbXBsYXRlIHJlbmRlcmluZ1xuICogQHBhcmFtICB7b2JqZWN0fSBjb21wb25lbnQuY29tcG9uZW50QVBJIC0gY29tcG9uZW50IGV4cG9ydCBkZWZhdWx0IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbXBvbmVudC5uYW1lIC0gY29tcG9uZW50IG5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGEgbmV3IGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVDb21wb25lbnQoeyBjc3MsIHRlbXBsYXRlLCBjb21wb25lbnRBUEksIG5hbWUgfSkge1xuICAvLyBhZGQgdGhlIGNvbXBvbmVudCBjc3MgaW50byB0aGUgRE9NXG4gIGlmIChjc3MgJiYgbmFtZSkgY3NzTWFuYWdlci5hZGQobmFtZSwgY3NzKTtcblxuICByZXR1cm4gY3VycnkobWFuYWdlQ29tcG9uZW50TGlmZWN5Y2xlKShcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgLy8gc2V0IHRoZSBjb21wb25lbnQgZGVmYXVsdHMgd2l0aG91dCBvdmVycmlkaW5nIHRoZSBvcmlnaW5hbCBjb21wb25lbnQgQVBJXG4gICAgICBkZWZpbmVEZWZhdWx0cyhjb21wb25lbnRBUEksIHtcbiAgICAgICAgLi4uQ09NUE9ORU5UX0xJRkVDWUNMRV9NRVRIT0RTLFxuICAgICAgICBbUFJPUFNfS0VZXToge30sXG4gICAgICAgIFtTVEFURV9LRVldOiB7fSxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICAvLyBkZWZpbmVkIGR1cmluZyB0aGUgY29tcG9uZW50IGNyZWF0aW9uXG4gICAgICAgIFtTTE9UU19LRVldOiBudWxsLFxuICAgICAgICBbUk9PVF9LRVldOiBudWxsLFxuICAgICAgICAvLyB0aGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgb3ZlcnJpZGVuXG4gICAgICAgIC4uLkNPTVBPTkVOVF9ET01fU0VMRUNUT1JTLFxuICAgICAgICBuYW1lLFxuICAgICAgICBjc3MsXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgfSxcbiAgICApLFxuICApXG59XG5cbmV4cG9ydCB7IGluc3RhbnRpYXRlQ29tcG9uZW50IH07XG4iLCIvKiBSaW90IHYxMC4wLjAsIEBsaWNlbnNlIE1JVCAqL1xuaW1wb3J0IHsgSVNfUFVSRV9TWU1CT0wsIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlIH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGNhbGxPckFzc2lnbiB9IGZyb20gJy4uL2RlcGVuZGVuY2llcy9AcmlvdGpzL3V0aWwvZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL21pc2MuanMnO1xuaW1wb3J0IHsgTU9DS0VEX1RFTVBMQVRFX0lOVEVSRkFDRSB9IGZyb20gJy4vbW9ja2VkLXRlbXBsYXRlLWludGVyZmFjZS5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICcuL2NvbXBvbmVudC10ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmltcG9ydCB7IGNyZWF0ZVB1cmVDb21wb25lbnQgfSBmcm9tICcuL2NyZWF0ZS1wdXJlLWNvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBpbnN0YW50aWF0ZUNvbXBvbmVudCB9IGZyb20gJy4vaW5zdGFudGlhdGUtY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHN1YmNvbXBvbmVudHMgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW5zaWRlIGEgdGFnIGluIHJ1bnRpbWVcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGNvbXBvbmVudHMgLSBjb21wb25lbnRzIGltcG9ydGVkIGluIHJ1bnRpbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFsbCB0aGUgY29tcG9uZW50cyB0cmFuc2Zvcm1lZCBpbnRvIFJpb3QuQ29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQ29tcG9uZW50c09iamVjdChjb21wb25lbnRzID0ge30pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNhbGxPckFzc2lnbihjb21wb25lbnRzKSkucmVkdWNlKFxuICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgYWNjW2NhbWVsVG9EYXNoQ2FzZShrZXkpXSA9IGNyZWF0ZUNvbXBvbmVudEZyb21XcmFwcGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LFxuICAgIHt9LFxuICApXG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBnZXR0ZXIgZnVuY3Rpb24gdG8gcmVuZGVyIHRoZSBjaGlsZCBjb21wb25lbnRzXG4gKiBAcGFyYW0gICB7UmlvdENvbXBvbmVudFdyYXBwZXJ9IGNvbXBvbmVudFdyYXBwZXIgLSByaW90IGNvbXBpbGVyIGdlbmVyYXRlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVDaGlsZENvbXBvbmVudEdldHRlciA9IChjb21wb25lbnRXcmFwcGVyKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuQ29tcG9uZW50cyA9IGNyZWF0ZUNoaWxkcmVuQ29tcG9uZW50c09iamVjdChcbiAgICBjb21wb25lbnRXcmFwcGVyLmV4cG9ydHMgPyBjb21wb25lbnRXcmFwcGVyLmV4cG9ydHMuY29tcG9uZW50cyA6IHt9LFxuICApO1xuXG4gIHJldHVybiAobmFtZSkgPT4ge1xuICAgIC8vIGltcHJvdmUgc3VwcG9ydCBmb3IgcmVjdXJzaXZlIGNvbXBvbmVudHNcbiAgICBpZiAobmFtZSA9PT0gY29tcG9uZW50V3JhcHBlci5uYW1lKVxuICAgICAgcmV0dXJuIG1lbW9pemVkQ3JlYXRlQ29tcG9uZW50RnJvbVdyYXBwZXIoY29tcG9uZW50V3JhcHBlcilcbiAgICAvLyByZXR1cm4gdGhlIHJlZ2lzdGVyZWQgY29tcG9uZW50c1xuICAgIHJldHVybiBjaGlsZHJlbkNvbXBvbmVudHNbbmFtZV0gfHwgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuZ2V0KG5hbWUpXG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGZvciB0aGUgcmVjdXJzaXZlIGNvbXBvbmVudHNcbiAqIEBwYXJhbSAge1Jpb3RDb21wb25lbnRXcmFwcGVyfSBjb21wb25lbnRXcmFwcGVyIC0gcmlvdCBjb21waWxlciBnZW5lcmF0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBjb21wb25lbnQgbGlrZSBpbnRlcmZhY2VcbiAqL1xuY29uc3QgbWVtb2l6ZWRDcmVhdGVDb21wb25lbnRGcm9tV3JhcHBlciA9IG1lbW9pemUoY3JlYXRlQ29tcG9uZW50RnJvbVdyYXBwZXIpO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgY29tcG9uZW50IGludGVyZmFjZSBuZWVkZWQgZm9yIHRoZSBAcmlvdGpzL2RvbS1iaW5kaW5ncyB0YWcgYmluZGluZ3NcbiAqIEBwYXJhbSAgIHtSaW90Q29tcG9uZW50V3JhcHBlcn0gY29tcG9uZW50V3JhcHBlciAtIHJpb3QgY29tcGlsZXIgZ2VuZXJhdGVkIG9iamVjdFxuICogQHBhcmFtICAge3N0cmluZ30gY29tcG9uZW50V3JhcHBlci5jc3MgLSBjb21wb25lbnQgY3NzXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IGNvbXBvbmVudFdyYXBwZXIudGVtcGxhdGUgLSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBkb20tYmluZGluZ3MgdGVtcGxhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtvYmplY3R9IGNvbXBvbmVudFdyYXBwZXIuZXhwb3J0cyAtIGNvbXBvbmVudCBpbnRlcmZhY2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGNvbXBvbmVudFdyYXBwZXIubmFtZSAtIGNvbXBvbmVudCBuYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBjb21wb25lbnQgbGlrZSBpbnRlcmZhY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RnJvbVdyYXBwZXIoY29tcG9uZW50V3JhcHBlcikge1xuICBjb25zdCB7IGNzcywgdGVtcGxhdGUsIGV4cG9ydHMsIG5hbWUgfSA9IGNvbXBvbmVudFdyYXBwZXI7XG4gIGNvbnN0IHRlbXBsYXRlRm4gPSB0ZW1wbGF0ZVxuICAgID8gY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5KFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgY29tcG9uZW50V3JhcHBlcixcbiAgICAgICAgY3JlYXRlQ2hpbGRDb21wb25lbnRHZXR0ZXIoY29tcG9uZW50V3JhcHBlciksXG4gICAgICApXG4gICAgOiBNT0NLRURfVEVNUExBVEVfSU5URVJGQUNFO1xuXG4gIHJldHVybiAoeyBzbG90cywgYXR0cmlidXRlcywgcHJvcHMgfSkgPT4ge1xuICAgIC8vIHB1cmUgY29tcG9uZW50cyByZW5kZXJpbmcgd2lsbCBiZSBtYW5hZ2VkIGJ5IHRoZSBlbmQgdXNlclxuICAgIGlmIChleHBvcnRzICYmIGV4cG9ydHNbSVNfUFVSRV9TWU1CT0xdKVxuICAgICAgcmV0dXJuIGNyZWF0ZVB1cmVDb21wb25lbnQoZXhwb3J0cywge1xuICAgICAgICBzbG90cyxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGNzcyxcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50QVBJID0gY2FsbE9yQXNzaWduKGV4cG9ydHMpIHx8IHt9O1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gaW5zdGFudGlhdGVDb21wb25lbnQoe1xuICAgICAgY3NzLFxuICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlRm4sXG4gICAgICBjb21wb25lbnRBUEksXG4gICAgICBuYW1lLFxuICAgIH0pKHsgc2xvdHMsIGF0dHJpYnV0ZXMsIHByb3BzIH0pO1xuXG4gICAgLy8gbm90aWNlIHRoYXQgZm9yIHRoZSBjb21wb25lbnRzIGNyZWF0ZWQgdmlhIHRhZyBiaW5kaW5nXG4gICAgLy8gd2UgbmVlZCB0byBpbnZlcnQgdGhlIG1vdW50IChzdGF0ZS9wYXJlbnRTY29wZSkgYXJndW1lbnRzXG4gICAgLy8gdGhlIHRlbXBsYXRlIGJpbmRpbmdzIHdpbGwgb25seSBmb3J3YXJkIHRoZSBwYXJlbnRTY29wZSB1cGRhdGVzXG4gICAgLy8gYW5kIG5ldmVyIGRlYWwgd2l0aCB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdW50KGVsZW1lbnQsIHBhcmVudFNjb3BlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Lm1vdW50KGVsZW1lbnQsIHN0YXRlLCBwYXJlbnRTY29wZSlcbiAgICAgIH0sXG4gICAgICB1cGRhdGUocGFyZW50U2NvcGUsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQudXBkYXRlKHN0YXRlLCBwYXJlbnRTY29wZSlcbiAgICAgIH0sXG4gICAgICB1bm1vdW50KHByZXNlcnZlUm9vdCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LnVubW91bnQocHJlc2VydmVSb290KVxuICAgICAgfSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgY3JlYXRlQ29tcG9uZW50RnJvbVdyYXBwZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///643\n\n}")},708:(n,t,e)=>{"use strict";e.d(t,{A:()=>I});var g=e(9);const I={css:null,exports:null,template:(n,t,e,g)=>n('<h1>Page not found</h1><p>Go back to <a href="/">home</a></p>',[]),name:"not-found"};(()=>{if(n.hot.accept(),n.hot.data){const n=e(708).A;(0,g.A)(n)}})()},732:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $D: () => (/* binding */ isSvg),\n/* harmony export */   B_: () => (/* binding */ isEventAttribute),\n/* harmony export */   Fl: () => (/* binding */ isTemplate),\n/* harmony export */   Gv: () => (/* binding */ isObject),\n/* harmony export */   Lm: () => (/* binding */ isBoolean),\n/* harmony export */   Tn: () => (/* binding */ isFunction),\n/* harmony export */   gD: () => (/* binding */ isNil)\n/* harmony export */ });\n/* unused harmony exports checkType, isNode */\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(604);\n/* Riot WIP, @license MIT */\n\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nfunction isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nfunction isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nfunction isNil(value) {\n  return value === null || value === undefined\n}\n\n/**\n * Detect node js environment\n * @returns {boolean} true if the runtime is node\n */\nfunction isNode() {\n  return typeof globalThis.process !== 'undefined'\n}\n\n/**\n * Check if an attribute is a DOM handler\n * @param   {string} attribute - attribute string\n * @returns {boolean} true only for dom listener attribute nodes\n */\nfunction isEventAttribute(attribute) {\n  return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EVENT_ATTRIBUTE_RE */ .K_.test(attribute)\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL2NoZWNrcy5qcz9iMTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgV0lQLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCB7IEVWRU5UX0FUVFJJQlVURV9SRSB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBRdWljayB0eXBlIGNoZWNraW5nXG4gKiBAcGFyYW0gICB7Kn0gZWxlbWVudCAtIGFueXRoaW5nXG4gKiBAcGFyYW0gICB7c3RyaW5nfSB0eXBlIC0gdHlwZSBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHlwZSBjb3JyZXNwb25kc1xuICovXG5mdW5jdGlvbiBjaGVja1R5cGUoZWxlbWVudCwgdHlwZSkge1xuICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09IHR5cGVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIHBhcnQgb2YgYW4gc3ZnXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHdlIGFyZSBpbiBhbiBzdmcgY29udGV4dFxuICovXG5mdW5jdGlvbiBpc1N2ZyhlbCkge1xuICBjb25zdCBvd25lciA9IGVsLm93bmVyU1ZHRWxlbWVudDtcblxuICByZXR1cm4gISFvd25lciB8fCBvd25lciA9PT0gbnVsbFxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWdcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXQncyBhIDx0ZW1wbGF0ZT5cbiAqL1xuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnXG59XG5cbi8qKlxuICogQ2hlY2sgdGhhdCB3aWxsIGJlIHBhc3NlZCBpZiBpdHMgYXJndW1lbnQgaXMgYSBmdW5jdGlvblxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tUeXBlKHZhbHVlLCAnZnVuY3Rpb24nKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBCb29sZWFuXG4gKiBAcGFyYW0gICB7Kn0gIHZhbHVlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9ubHkgZm9yIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1R5cGUodmFsdWUsICdib29sZWFuJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICogQHBhcmFtICAgeyp9ICB2YWx1ZSAtIGFueXRoaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbmx5IGZvciB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhaXNOaWwodmFsdWUpICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Rcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gKiBAcGFyYW0gICB7Kn0gIHZhbHVlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9ubHkgZm9yIHRoZSAndW5kZWZpbmVkJyBhbmQgJ251bGwnIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogRGV0ZWN0IG5vZGUganMgZW52aXJvbm1lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBydW50aW1lIGlzIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNOb2RlKCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSBET00gaGFuZGxlclxuICogQHBhcmFtICAge3N0cmluZ30gYXR0cmlidXRlIC0gYXR0cmlidXRlIHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb25seSBmb3IgZG9tIGxpc3RlbmVyIGF0dHJpYnV0ZSBub2Rlc1xuICovXG5mdW5jdGlvbiBpc0V2ZW50QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICByZXR1cm4gRVZFTlRfQVRUUklCVVRFX1JFLnRlc3QoYXR0cmlidXRlKVxufVxuXG5leHBvcnQgeyBjaGVja1R5cGUsIGlzQm9vbGVhbiwgaXNFdmVudEF0dHJpYnV0ZSwgaXNGdW5jdGlvbiwgaXNOaWwsIGlzTm9kZSwgaXNPYmplY3QsIGlzU3ZnLCBpc1RlbXBsYXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///732\n\n}")},765:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   n8: () => (/* binding */ defineProperty),\n/* harmony export */   ny: () => (/* binding */ defineProperties),\n/* harmony export */   qI: () => (/* binding */ defineDefaults)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options,\n  });\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} the original object modified\n */\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options);\n  });\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value;\n  });\n\n  return source\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vZGVwZW5kZW5jaWVzL0ByaW90anMvdXRpbC9vYmplY3RzLmpzP2IzMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogUmlvdCBXSVAsIEBsaWNlbnNlIE1JVCAqL1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGFuIGltbXV0YWJsZSBwcm9wZXJ0eVxuICogQHBhcmFtICAge09iamVjdH0gc291cmNlIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGtleSAtIG9iamVjdCBrZXkgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0eSB3aWxsIGJlIHN0b3JlZFxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gdmFsdWUgb2YgdGhlIG5ldyBwcm9wZXJ0eVxuICogQHBhcmFtICAge09iamVjdH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVydHkgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHRoZSBvcmlnaW5hbCBvYmplY3QgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZnAvbm8tbXV0YXRpbmctbWV0aG9kcyAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xuICAvKiBlc2xpbnQtZW5hYmxlIGZwL25vLW11dGF0aW5nLW1ldGhvZHMgKi9cblxuICByZXR1cm4gc291cmNlXG59XG5cbi8qKlxuICogRGVmaW5lIG11bHRpcGxlIHByb3BlcnRpZXMgb24gYSB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBvYmplY3Qgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gb2JqZWN0IGNvbnRhaW5pbmcgYXMga2V5IHBhaXIgdGhlIGtleSArIHZhbHVlIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMgLSBzZXQgdGhlIHByb3BlcnR5IG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gdGhlIG9yaWdpbmFsIG9iamVjdCBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHNvdXJjZSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICB9KTtcblxuICByZXR1cm4gc291cmNlXG59XG5cbi8qKlxuICogRGVmaW5lIGRlZmF1bHQgcHJvcGVydGllcyBpZiB0aGV5IGRvbid0IGV4aXN0IG9uIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGRlZmF1bHQgcHJvcGVydGllc1xuICogQHBhcmFtICAge09iamVjdH0gZGVmYXVsdHMgLSBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIG9wdGlvbmFsIGtleXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBvcmlnaW5hbCBvYmplY3QgcmVjZWl2ZWQgZW5oYW5jZWRcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRGVmYXVsdHMoc291cmNlLCBkZWZhdWx0cykge1xuICBPYmplY3QuZW50cmllcyhkZWZhdWx0cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKCFzb3VyY2Vba2V5XSkgc291cmNlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNvdXJjZVxufVxuXG5leHBvcnQgeyBkZWZpbmVEZWZhdWx0cywgZGVmaW5lUHJvcGVydGllcywgZGVmaW5lUHJvcGVydHkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///765\n\n}")},781:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ay: () => (/* binding */ cssManager)\n/* harmony export */ });\n/* unused harmony exports CSS_BY_NAME, STYLE_NODE_SELECTOR */\n/* harmony import */ var _dependencies_bianco_query_index_next_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(818);\n/* harmony import */ var _dependencies_bianco_attr_index_next_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(397);\n/* Riot v10.0.0, @license MIT */\n\n\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]';\n\n// memoized curried function\nconst getStyleNode = ((style) => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style\n\n    // create a new style element or use an existing one\n    // and cache it internally\n    style = (0,_dependencies_bianco_query_index_next_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    (0,_dependencies_bianco_attr_index_next_js__WEBPACK_IMPORTED_MODULE_1__/* .set */ .h)(style, 'type', 'text/css');\n\n    /* istanbul ignore next */\n    if (!style.parentNode) document.head.appendChild(style);\n\n    return style\n  }\n})();\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nconst cssManager = {\n  CSS_BY_NAME,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this\n  },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmlvdC9lc20vY29yZS9jc3MtbWFuYWdlci5qcz9mMjQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjEwLjAuMCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgJCBmcm9tICcuLi9kZXBlbmRlbmNpZXMvYmlhbmNvLnF1ZXJ5L2luZGV4Lm5leHQuanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2JpYW5jby5hdHRyL2luZGV4Lm5leHQuanMnO1xuXG5jb25zdCBDU1NfQllfTkFNRSA9IG5ldyBNYXAoKTtcbmNvbnN0IFNUWUxFX05PREVfU0VMRUNUT1IgPSAnc3R5bGVbcmlvdF0nO1xuXG4vLyBtZW1vaXplZCBjdXJyaWVkIGZ1bmN0aW9uXG5jb25zdCBnZXRTdHlsZU5vZGUgPSAoKHN0eWxlKSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgLy8gbGF6eSBldmFsdWF0aW9uOlxuICAgIC8vIGlmIHRoaXMgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkIGJlZm9yZVxuICAgIC8vIHdlIHJldHVybiBpdHMgY2FjaGVkIHJlc3VsdFxuICAgIGlmIChzdHlsZSkgcmV0dXJuIHN0eWxlXG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCBvciB1c2UgYW4gZXhpc3Rpbmcgb25lXG4gICAgLy8gYW5kIGNhY2hlIGl0IGludGVybmFsbHlcbiAgICBzdHlsZSA9ICQoU1RZTEVfTk9ERV9TRUxFQ1RPUilbMF0gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzZXQoc3R5bGUsICd0eXBlJywgJ3RleHQvY3NzJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghc3R5bGUucGFyZW50Tm9kZSkgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgICByZXR1cm4gc3R5bGVcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBPYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gaW5qZWN0IGFuZCBtYW5hZ2UgdGhlIGNzcyBvZiBldmVyeSB0YWcgaW5zdGFuY2VcbiAqL1xuY29uc3QgY3NzTWFuYWdlciA9IHtcbiAgQ1NTX0JZX05BTUUsXG4gIC8qKlxuICAgKiBTYXZlIGEgdGFnIHN0eWxlIHRvIGJlIGxhdGVyIGluamVjdGVkIGludG8gRE9NXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IG5hbWUgLSBpZiBpdCdzIHBhc3NlZCB3ZSB3aWxsIG1hcCB0aGUgY3NzIHRvIGEgdGFnbmFtZVxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBjc3MgLSBjc3Mgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHNlbGZcbiAgICovXG4gIGFkZChuYW1lLCBjc3MpIHtcbiAgICBpZiAoIUNTU19CWV9OQU1FLmhhcyhuYW1lKSkge1xuICAgICAgQ1NTX0JZX05BTUUuc2V0KG5hbWUsIGNzcyk7XG4gICAgICB0aGlzLmluamVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8qKlxuICAgKiBJbmplY3QgYWxsIHByZXZpb3VzbHkgc2F2ZWQgdGFnIHN0eWxlcyBpbnRvIERPTVxuICAgKiBpbm5lckhUTUwgc2VlbXMgc2xvdzogaHR0cDovL2pzcGVyZi5jb20vcmlvdC1pbnNlcnQtc3R5bGVcbiAgICogQHJldHVybnMge29iamVjdH0gc2VsZlxuICAgKi9cbiAgaW5qZWN0KCkge1xuICAgIGdldFN0eWxlTm9kZSgpLmlubmVySFRNTCA9IFsuLi5DU1NfQllfTkFNRS52YWx1ZXMoKV0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIHN0eWxlIGZyb20gdGhlIERPTVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBhIHJlZ2lzdGVyZWQgdGFnbmFtZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZWxmXG4gICAqL1xuICByZW1vdmUobmFtZSkge1xuICAgIGlmIChDU1NfQllfTkFNRS5oYXMobmFtZSkpIHtcbiAgICAgIENTU19CWV9OQU1FLmRlbGV0ZShuYW1lKTtcbiAgICAgIHRoaXMuaW5qZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbn07XG5cbmV4cG9ydCB7IENTU19CWV9OQU1FLCBTVFlMRV9OT0RFX1NFTEVDVE9SLCBjc3NNYW5hZ2VyIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///781\n\n}")},818:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ $)\n/* harmony export */ });\n/* harmony import */ var _bianco_dom_to_array_index_next_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(550);\n/* Riot WIP, @license MIT */\n\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return (0,_bianco_dom_to_array_index_next_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvYmlhbmNvLnF1ZXJ5L2luZGV4Lm5leHQuanM/ZjVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG5pbXBvcnQgZG9tVG9BcnJheSBmcm9tICcuLi9iaWFuY28uZG9tLXRvLWFycmF5L2luZGV4Lm5leHQuanMnO1xuXG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgdG8gZmluZCBET00gbm9kZXMgcmV0dXJuaW5nIHRoZW0gYXMgYXJyYXkgbGlrZSBsb29wYWJsZSBvYmplY3RcbiAqIEBwYXJhbSAgIHsgc3RyaW5nfERPTU5vZGVMaXN0IH0gc2VsZWN0b3IgLSBlaXRoZXIgdGhlIHF1ZXJ5IG9yIHRoZSBET00gbm9kZXMgdG8gYXJyYWlmeVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9ICAgICAgICBzY29wZSAgICAgIC0gY29udGV4dCBkZWZpbmluZyB3aGVyZSB0aGUgcXVlcnkgd2lsbCBzZWFyY2ggZm9yIHRoZSBET00gbm9kZXNcbiAqIEByZXR1cm5zIHsgQXJyYXkgfSBET00gbm9kZXMgZm91bmQgYXMgYXJyYXlcbiAqL1xuZnVuY3Rpb24gJChzZWxlY3Rvciwgc2NvcGUpIHtcbiAgcmV0dXJuIGRvbVRvQXJyYXkodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyA/XG4gICAgKHNjb3BlIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSA6XG4gICAgc2VsZWN0b3JcbiAgKVxufVxuXG5leHBvcnQgeyAkIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///818\n\n}")},823:(n,t,e)=>{"use strict";e.d(t,{A:()=>I});var g=e(9);const I={css:'loader,[is="loader"]{ padding: 1rem 0; }loader svg,[is="loader"] svg{ overflow: visible; }',exports:null,template:(n,t,e,g)=>n('<svg width="38" height="38" viewBox="0 0 38 38" xmlns="http://www.w3.org/2000/svg" stroke="#000"><g fill="none" fill-rule="evenodd"><g transform="translate(1 1)" stroke-width="2"><circle stroke-opacity=".5" cx="18" cy="18" r="18"/><path d="M36 18c0-9.94-8.06-18-18-18"/><animatetransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s" repeatCount="indefinite"></animatetransform></g></g></svg>',[]),name:"loader"};(()=>{if(n.hot.accept(),n.hot.data){const n=e(823).A;(0,g.A)(n)}})()},867:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ dashToCamelCase),\n/* harmony export */   e: () => (/* binding */ camelToDashCase)\n/* harmony export */ });\n/* Riot WIP, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvQHJpb3Rqcy91dGlsL3N0cmluZ3MuanM/MDUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgZnJvbSBjYW1lbCBjYXNlIHRvIGRhc2gtY2FzZVxuICogQHBhcmFtICAge3N0cmluZ30gc3RyaW5nIC0gcHJvYmFibHkgYSBjb21wb25lbnQgdGFnIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBvbmVudCBuYW1lIG5vcm1hbGl6ZWRcbiAqL1xuZnVuY3Rpb24gY2FtZWxUb0Rhc2hDYXNlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgZGFzaGVzIHRvIGNhbWVsIGNhc2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IHN0cmluZyAtIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gbXktc3RyaW5nIC0+IG15U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGRhc2hUb0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSlcbn1cblxuZXhwb3J0IHsgY2FtZWxUb0Rhc2hDYXNlLCBkYXNoVG9DYW1lbENhc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///867\n\n}")},877:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>I});var g=e(9);const I={css:null,exports:null,template:(n,t,e,g)=>n('<a class="navbar-brand ml-2" href="/"><img src="assets/images/Vault_Lambda_Logo.png" height="35"/></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav mr-auto"><li class="nav-item"><a class="nav-link" href="ideal">Ideal</a></li><li class="nav-item"><a class="nav-link" href="team">Team</a></li><li class="nav-item"><a class="nav-link" href="projects">Projects</a></li><li class="nav-item"><a class="nav-link" href="contact">Contact</a></li></ul></div>',[{expressions:[{type:t.ATTRIBUTE,isBoolean:!1,name:"class",evaluate:n=>"row navbar navbar-expand-lg navbar-light bg-light"}]}]),name:"global-nav"};(()=>{if(n.hot.accept(),n.hot.data){const n=e(877).default;(0,g.A)(n)}})()},904:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  s: () => (/* binding */ component)\n});\n\n;// ./node_modules/riot/esm/dependencies/cumpa/index.js\n/* Riot WIP, @license MIT */\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nfunction compose(...fns) {\n  return fns.reduce((f, g) => (...args) => f(g(...args)))\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/core/create-component-from-wrapper.js + 18 modules\nvar create_component_from_wrapper = __webpack_require__(643);\n;// ./node_modules/riot/esm/api/component.js\n/* Riot v10.0.0, @license MIT */\n\n\n\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\nfunction component(implementation) {\n  return (el, props, { slots, attributes, parentScope } = {}) =>\n    compose(\n      (c) => c.mount(el, parentScope),\n      (c) => c({ props, slots, attributes }),\n      create_component_from_wrapper/* createComponentFromWrapper */.T,\n    )(implementation)\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yaW90L2VzbS9kZXBlbmRlbmNpZXMvY3VtcGEvaW5kZXguanM/NmQ0MSIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Jpb3QvZXNtL2FwaS9jb21wb25lbnQuanM/M2FlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBSaW90IFdJUCwgQGxpY2Vuc2UgTUlUICovXG4vKipcbiAqIFNpbWlsYXIgdG8gY29tcG9zZSBidXQgcGVyZm9ybXMgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiB7QGxpbmsgaHR0cHM6Ly8zMHNlY29uZHNvZmNvZGUub3JnL2Z1bmN0aW9uI2NvbXBvc2VyaWdodCBzZWUgYWxzb31cbiAqIEBwYXJhbSAgIHsuLi5bZnVuY3Rpb25dfSBmbnMpIC0gbGlzdCBvZiB1bmFyeSBmdW5jdGlvblxuICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb25cbiAqL1xuXG4vKipcbiAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgZnVuY3Rpb24gY29tcG9zaXRpb24uPGJyLz5cbiAqIFVzZSBBcnJheS5wcm90b3R5cGUucmVkdWNlKCkgdG8gcGVyZm9ybSByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiBUaGUgbGFzdCAocmlnaHRtb3N0KSBmdW5jdGlvbiBjYW4gYWNjZXB0IG9uZSBvciBtb3JlIGFyZ3VtZW50czsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS48YnIvPlxuICoge0BsaW5rIGh0dHBzOi8vMzBzZWNvbmRzb2Zjb2RlLm9yZy9mdW5jdGlvbiNjb21wb3NlIG9yaWdpbmFsIHNvdXJjZSBjb2RlfVxuICogQHBhcmFtICAgey4uLltmdW5jdGlvbl19IGZucykgLSBsaXN0IG9mIHVuYXJ5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Kn0gcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvblxuICovXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZucykge1xuICByZXR1cm4gZm5zLnJlZHVjZSgoZiwgZykgPT4gKC4uLmFyZ3MpID0+IGYoZyguLi5hcmdzKSkpXG59XG5cbmV4cG9ydCB7IGNvbXBvc2UgYXMgZGVmYXVsdCB9O1xuIiwiLyogUmlvdCB2MTAuMC4wLCBAbGljZW5zZSBNSVQgKi9cbmltcG9ydCBjb21wb3NlIGZyb20gJy4uL2RlcGVuZGVuY2llcy9jdW1wYS9pbmRleC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnRGcm9tV3JhcHBlciB9IGZyb20gJy4uL2NvcmUvY3JlYXRlLWNvbXBvbmVudC1mcm9tLXdyYXBwZXIuanMnO1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gY3JlYXRlIGNvbXBvbmVudCB3aXRob3V0IHJlbHlpbmcgb24gdGhlIHJlZ2lzdGVyZWQgb25lc1xuICogQHBhcmFtICAge29iamVjdH0gaW1wbGVtZW50YXRpb24gLSBjb21wb25lbnQgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCB3aWxsIGFsbG93IHlvdSB0byBtb3VudCBhIHJpb3QgY29tcG9uZW50IG9uIGEgRE9NIG5vZGVcbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50KGltcGxlbWVudGF0aW9uKSB7XG4gIHJldHVybiAoZWwsIHByb3BzLCB7IHNsb3RzLCBhdHRyaWJ1dGVzLCBwYXJlbnRTY29wZSB9ID0ge30pID0+XG4gICAgY29tcG9zZShcbiAgICAgIChjKSA9PiBjLm1vdW50KGVsLCBwYXJlbnRTY29wZSksXG4gICAgICAoYykgPT4gYyh7IHByb3BzLCBzbG90cywgYXR0cmlidXRlcyB9KSxcbiAgICAgIGNyZWF0ZUNvbXBvbmVudEZyb21XcmFwcGVyLFxuICAgICkoaW1wbGVtZW50YXRpb24pXG59XG5cbmV4cG9ydCB7IGNvbXBvbmVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///904\n\n}")},989:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lazy)\n});\n\n// EXTERNAL MODULE: ./node_modules/riot/esm/api/pure.js\nvar pure = __webpack_require__(503);\n// EXTERNAL MODULE: ./node_modules/riot/esm/api/component.js + 1 modules\nvar component = __webpack_require__(904);\n;// ./node_modules/@riotjs/util/dom.js\n\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n\n// Ignore this helper because it's needed only for svg tags\nfunction moveChildren(source, target) {\n  // eslint-disable-next-line fp/no-loops\n  while (source.firstChild) target.appendChild(source.firstChild)\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild)\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nfunction clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0; i < children.length; i++) removeChild(children[i])\n}\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nconst removeChild = (node) => node.remove()\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nconst insertBefore = (newNode, refNode) =>\n  refNode &&\n  refNode.parentNode &&\n  refNode.parentNode.insertBefore(newNode, refNode)\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nconst replaceChild = (newNode, replaced) =>\n  replaced &&\n  replaced.parentNode &&\n  replaced.parentNode.replaceChild(newNode, replaced)\n\n;// ./node_modules/@riotjs/lazy/index.js\n\n\n\n// this object will contain all the components implementations lazy loaded\nconst cache = new WeakMap();\n\n// expose the cache as static property\nlazy.cache = cache;\n\n// static attribute in case we want to just export a lazy riot component\nlazy.export = function lazyExport(Loader, Component) {\n  // it could be that the user doesn't want to use a loader for whatever reason\n  const hasLoader = Loader && Component;\n  const LazyComponent = hasLoader ? Component : Loader;\n  const load = () =>\n    typeof LazyComponent === 'function'\n      ? LazyComponent()\n      : Promise.resolve(LazyComponent);\n  const cachedComponent = cache.get(LazyComponent);\n\n  return (0,pure/* pure */.L)(({ slots, attributes, props }) => ({\n    mount(el, parentScope) {\n      this.el = el;\n      this.isMounted = true;\n      const mount = () => {\n        this.mountLazyComponent(parentScope);\n        this.el.dispatchEvent(new Event('load'));\n      };\n\n      if (cachedComponent) {\n        mount();\n      } else {\n        if (hasLoader) this.createManagedComponent(Loader, parentScope);\n\n        load().then((data) => {\n          cache.set(LazyComponent, data.default || data);\n          mount();\n        });\n      }\n    },\n    createManagedComponent(Child, parentScope) {\n      this.component = (0,component/* component */.s)(Child)(this.el, props, {\n        attributes,\n        slots,\n        parentScope,\n      });\n    },\n    mountLazyComponent(parentScope) {\n      // if this component was unmounted just return here\n      if (!this.isMounted) return\n\n      // unmount the loader if it was previously created\n      if (this.component) {\n        // unmount the bindings (keeping the root node)\n        this.component.unmount(true);\n        // clean the DOM\n        if (this.el.children.length) cleanNode(this.el);\n      }\n\n      // replace the old component instance with the new lazy loaded component\n      this.createManagedComponent(cache.get(LazyComponent), parentScope);\n    },\n    update(parentScope) {\n      if (this.isMounted && this.component)\n        this.component.update({}, parentScope);\n    },\n    unmount(...args) {\n      this.isMounted = false;\n\n      if (this.component) this.component.unmount(...args);\n    },\n  }))\n};\n\nfunction lazy(Loader, Component) {\n  return {\n    name: 'lazy',\n    exports: lazy.export(Loader, Component),\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByaW90anMvdXRpbC9kb20uanM/YjdjZiIsIndlYnBhY2s6Ly92bC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByaW90anMvbGF6eS9pbmRleC5qcz8yYzUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJy4vc3RyaW5ncy5qcydcblxuLyoqXG4gKiBHZXQgYWxsIHRoZSBlbGVtZW50IGF0dHJpYnV0ZXMgYXMgb2JqZWN0XG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbGwgdGhlIGF0dHJpYnV0ZXMgZm91bmQgYXMgYSBrZXkgdmFsdWUgcGFpcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIERPTWF0dHJpYnV0ZXNUb09iamVjdChlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuYXR0cmlidXRlcykucmVkdWNlKChhY2MsIGF0dHJpYnV0ZSkgPT4ge1xuICAgIGFjY1tkYXNoVG9DYW1lbENhc2UoYXR0cmlidXRlLm5hbWUpXSA9IGF0dHJpYnV0ZS52YWx1ZVxuICAgIHJldHVybiBhY2NcbiAgfSwge30pXG59XG5cbi8qKlxuICogTW92ZSBhbGwgdGhlIGNoaWxkIG5vZGVzIGZyb20gYSBzb3VyY2UgdGFnIHRvIGFub3RoZXJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gc291cmNlIC0gc291cmNlIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IG5vZGVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGl0J3MgYSB2b2lkIG1ldGhvZCDCr1xcXyjjg4QpXy/Cr1xuICovXG5cbi8vIElnbm9yZSB0aGlzIGhlbHBlciBiZWNhdXNlIGl0J3MgbmVlZGVkIG9ubHkgZm9yIHN2ZyB0YWdzXG5leHBvcnQgZnVuY3Rpb24gbW92ZUNoaWxkcmVuKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmcC9uby1sb29wc1xuICB3aGlsZSAoc291cmNlLmZpcnN0Q2hpbGQpIHRhcmdldC5hcHBlbmRDaGlsZChzb3VyY2UuZmlyc3RDaGlsZClcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGNoaWxkIG5vZGVzIGZyb20gYW55IERPTSBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSB0YXJnZXQgbm9kZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuTm9kZShub2RlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmcC9uby1sb29wc1xuICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZClcbn1cblxuLyoqXG4gKiBDbGVhciBtdWx0aXBsZSBjaGlsZHJlbiBpbiBhIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudFtdfSBjaGlsZHJlbiAtIGRpcmVjdCBjaGlsZHJlbiBub2Rlc1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZwL25vLWxvb3BzLGZwL25vLWxldFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSByZW1vdmVDaGlsZChjaGlsZHJlbltpXSlcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fW5vZGUgLSBub2RlIHRvIHJlbW92ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUNoaWxkID0gKG5vZGUpID0+IG5vZGUucmVtb3ZlKClcblxuLyoqXG4gKiBJbnNlcnQgYmVmb3JlIGEgbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbmV3Tm9kZSAtIG5vZGUgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZOb2RlIC0gcmVmIGNoaWxkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgaW5zZXJ0QmVmb3JlID0gKG5ld05vZGUsIHJlZk5vZGUpID0+XG4gIHJlZk5vZGUgJiZcbiAgcmVmTm9kZS5wYXJlbnROb2RlICYmXG4gIHJlZk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmTm9kZSlcblxuLyoqXG4gKiBSZXBsYWNlIGEgbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbmV3Tm9kZSAtIG5ldyBub2RlIHRvIGFkZCB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZXBsYWNlZCAtIG5vZGUgdG8gcmVwbGFjZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VDaGlsZCA9IChuZXdOb2RlLCByZXBsYWNlZCkgPT5cbiAgcmVwbGFjZWQgJiZcbiAgcmVwbGFjZWQucGFyZW50Tm9kZSAmJlxuICByZXBsYWNlZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCByZXBsYWNlZClcbiIsImltcG9ydCB7IHB1cmUsIGNvbXBvbmVudCB9IGZyb20gJ3Jpb3QnO1xuaW1wb3J0IHsgY2xlYW5Ob2RlIH0gZnJvbSAnQHJpb3Rqcy91dGlsL2RvbSc7XG5cbi8vIHRoaXMgb2JqZWN0IHdpbGwgY29udGFpbiBhbGwgdGhlIGNvbXBvbmVudHMgaW1wbGVtZW50YXRpb25zIGxhenkgbG9hZGVkXG5jb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIGV4cG9zZSB0aGUgY2FjaGUgYXMgc3RhdGljIHByb3BlcnR5XG5sYXp5LmNhY2hlID0gY2FjaGU7XG5cbi8vIHN0YXRpYyBhdHRyaWJ1dGUgaW4gY2FzZSB3ZSB3YW50IHRvIGp1c3QgZXhwb3J0IGEgbGF6eSByaW90IGNvbXBvbmVudFxubGF6eS5leHBvcnQgPSBmdW5jdGlvbiBsYXp5RXhwb3J0KExvYWRlciwgQ29tcG9uZW50KSB7XG4gIC8vIGl0IGNvdWxkIGJlIHRoYXQgdGhlIHVzZXIgZG9lc24ndCB3YW50IHRvIHVzZSBhIGxvYWRlciBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gIGNvbnN0IGhhc0xvYWRlciA9IExvYWRlciAmJiBDb21wb25lbnQ7XG4gIGNvbnN0IExhenlDb21wb25lbnQgPSBoYXNMb2FkZXIgPyBDb21wb25lbnQgOiBMb2FkZXI7XG4gIGNvbnN0IGxvYWQgPSAoKSA9PlxuICAgIHR5cGVvZiBMYXp5Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IExhenlDb21wb25lbnQoKVxuICAgICAgOiBQcm9taXNlLnJlc29sdmUoTGF6eUNvbXBvbmVudCk7XG4gIGNvbnN0IGNhY2hlZENvbXBvbmVudCA9IGNhY2hlLmdldChMYXp5Q29tcG9uZW50KTtcblxuICByZXR1cm4gcHVyZSgoeyBzbG90cywgYXR0cmlidXRlcywgcHJvcHMgfSkgPT4gKHtcbiAgICBtb3VudChlbCwgcGFyZW50U2NvcGUpIHtcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHRoaXMuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG1vdW50ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm1vdW50TGF6eUNvbXBvbmVudChwYXJlbnRTY29wZSk7XG4gICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2xvYWQnKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoY2FjaGVkQ29tcG9uZW50KSB7XG4gICAgICAgIG1vdW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzTG9hZGVyKSB0aGlzLmNyZWF0ZU1hbmFnZWRDb21wb25lbnQoTG9hZGVyLCBwYXJlbnRTY29wZSk7XG5cbiAgICAgICAgbG9hZCgpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBjYWNoZS5zZXQoTGF6eUNvbXBvbmVudCwgZGF0YS5kZWZhdWx0IHx8IGRhdGEpO1xuICAgICAgICAgIG1vdW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlTWFuYWdlZENvbXBvbmVudChDaGlsZCwgcGFyZW50U2NvcGUpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50KENoaWxkKSh0aGlzLmVsLCBwcm9wcywge1xuICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICBzbG90cyxcbiAgICAgICAgcGFyZW50U2NvcGUsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1vdW50TGF6eUNvbXBvbmVudChwYXJlbnRTY29wZSkge1xuICAgICAgLy8gaWYgdGhpcyBjb21wb25lbnQgd2FzIHVubW91bnRlZCBqdXN0IHJldHVybiBoZXJlXG4gICAgICBpZiAoIXRoaXMuaXNNb3VudGVkKSByZXR1cm5cblxuICAgICAgLy8gdW5tb3VudCB0aGUgbG9hZGVyIGlmIGl0IHdhcyBwcmV2aW91c2x5IGNyZWF0ZWRcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAvLyB1bm1vdW50IHRoZSBiaW5kaW5ncyAoa2VlcGluZyB0aGUgcm9vdCBub2RlKVxuICAgICAgICB0aGlzLmNvbXBvbmVudC51bm1vdW50KHRydWUpO1xuICAgICAgICAvLyBjbGVhbiB0aGUgRE9NXG4gICAgICAgIGlmICh0aGlzLmVsLmNoaWxkcmVuLmxlbmd0aCkgY2xlYW5Ob2RlKHRoaXMuZWwpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXBsYWNlIHRoZSBvbGQgY29tcG9uZW50IGluc3RhbmNlIHdpdGggdGhlIG5ldyBsYXp5IGxvYWRlZCBjb21wb25lbnRcbiAgICAgIHRoaXMuY3JlYXRlTWFuYWdlZENvbXBvbmVudChjYWNoZS5nZXQoTGF6eUNvbXBvbmVudCksIHBhcmVudFNjb3BlKTtcbiAgICB9LFxuICAgIHVwZGF0ZShwYXJlbnRTY29wZSkge1xuICAgICAgaWYgKHRoaXMuaXNNb3VudGVkICYmIHRoaXMuY29tcG9uZW50KVxuICAgICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGUoe30sIHBhcmVudFNjb3BlKTtcbiAgICB9LFxuICAgIHVubW91bnQoLi4uYXJncykge1xuICAgICAgdGhpcy5pc01vdW50ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB0aGlzLmNvbXBvbmVudC51bm1vdW50KC4uLmFyZ3MpO1xuICAgIH0sXG4gIH0pKVxufTtcblxuZnVuY3Rpb24gbGF6eShMb2FkZXIsIENvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdsYXp5JyxcbiAgICBleHBvcnRzOiBsYXp5LmV4cG9ydChMb2FkZXIsIENvbXBvbmVudCksXG4gIH1cbn1cblxuZXhwb3J0IHsgbGF6eSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///989\n\n}")}},n=>{n.O(0,[524],()=>{[845,751,826,819,694,364].map(n.E)},5),n(n.s=455)}]);